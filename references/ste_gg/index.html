<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶ï STE.GG</title>
    <style>
        :root {
            --primary: #00ff41;
            --primary-dim: #00aa2a;
            --primary-glow: rgba(0, 255, 65, 0.4);
            --secondary: #00d4ff;
            --accent: #7c3aed;
            --warning: #ffd000;
            --error: #ff3333;
            --bg-dark: #0a0a0a;
            --bg-card: #0d1117;
            --bg-hover: #161b22;
            --text: #00ff41;
            --text-dim: #555;
            --border: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            color: var(--primary);
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Matrix scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 65, 0.015) 2px,
                rgba(0, 255, 65, 0.015) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 20px 0;
        }

        .banner {
            font-size: 8px;
            line-height: 1.1;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary-glow);
            white-space: pre;
            overflow-x: auto;
        }

        .subtitle {
            color: var(--secondary);
            font-size: 14px;
            margin-top: 10px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin: 20px 0;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }

        .tab:hover {
            color: var(--secondary);
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        /* Panels */
        .panel {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, var(--border), transparent);
        }

        /* Grid layout */
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.03) 0%, rgba(0, 212, 255, 0.03) 100%);
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.08) 0%, rgba(0, 212, 255, 0.05) 100%);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.15);
        }

        .drop-zone input {
            display: none;
        }

        .drop-zone-text {
            color: var(--primary);
            font-size: 13px;
        }

        .drop-zone-hint {
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 8px;
        }

        /* Image preview */
        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-top: 10px;
        }

        .image-info {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 8px;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--primary);
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-row > * {
            flex: 1;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--accent);
            color: white;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--bg-dark);
        }

        .btn-primary:hover {
            background: var(--primary-dim);
            box-shadow: 0 0 20px var(--primary-glow);
        }

        .btn-secondary {
            background: var(--secondary);
            color: var(--bg-dark);
        }

        .btn-secondary:hover {
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        .btn-purple {
            background: #9333ea;
            color: white;
        }

        .btn-purple:hover {
            background: #7c22ce;
            box-shadow: 0 0 20px rgba(147, 51, 234, 0.4);
        }

        .btn-pink {
            background: var(--accent);
            color: white;
        }

        .btn-pink:hover {
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.4);
        }

        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Capacity meter */
        .capacity-meter {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            margin: 12px 0;
        }

        .capacity-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .capacity-bar {
            height: 6px;
            background: var(--bg-card);
            border-radius: 3px;
            overflow: hidden;
        }

        .capacity-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 3px;
            transition: width 0.3s, background 0.3s;
        }

        .capacity-fill.warning { background: var(--warning); }
        .capacity-fill.error { background: var(--error); }

        .capacity-footer {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 8px;
        }

        /* Results table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 12px;
        }

        .results-table th, .results-table td {
            padding: 8px;
            text-align: left;
            border: 1px solid var(--border);
        }

        .results-table th {
            background: var(--bg-hover);
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .results-table tr:hover {
            background: var(--bg-hover);
        }

        .status-found { color: var(--primary); }
        .status-text { color: var(--secondary); }
        .status-possible { color: var(--warning); }
        .status-none { color: var(--text-dim); }

        /* Terminal output */
        .terminal {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 16px;
            font-family: inherit;
            font-size: 13px;
            color: var(--primary);
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Toggle switch */
        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .toggle-switch {
            width: 40px;
            height: 20px;
            background: var(--border);
            border-radius: 10px;
            position: relative;
            transition: background 0.3s;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle input {
            display: none;
        }

        .toggle input:checked + .toggle-switch {
            background: var(--primary);
        }

        .toggle input:checked + .toggle-switch::after {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 13px;
            color: var(--secondary);
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: var(--primary);
            color: var(--bg-dark);
        }

        .notification.error {
            background: var(--error);
            color: white;
        }

        .notification.info {
            background: var(--secondary);
            color: var(--bg-dark);
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
            font-size: 12px;
        }

        .hatch-animation {
            font-family: monospace;
            font-size: 11px;
            line-height: 1.15;
            color: var(--primary);
            white-space: pre;
            display: inline-block;
            margin-bottom: 8px;
            min-width: 60px;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            padding: 5px;
        }

        @keyframes egg-shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-3deg); }
            75% { transform: rotate(3deg); }
        }

        .egg-shaking {
            animation: egg-shake 0.1s ease-in-out;
        }

        /* Matryoshka easter egg trigger */
        .matryoshka-trigger {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 16px;
            height: 16px;
            z-index: 99999;
            background: transparent;
            pointer-events: auto !important;
        }

        /* Matryoshka panel */
        .matryoshka-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 16px;
            z-index: 9998;
            min-width: 280px;
            display: none;
        }

        .matryoshka-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .matryoshka-title {
            color: var(--accent);
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
        }

        .matryoshka-subtitle {
            color: #a78bfa;
            font-size: 11px;
            text-align: center;
            margin-bottom: 12px;
        }

        .matryoshka-depth {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .matryoshka-depth label {
            color: #a78bfa;
            font-size: 13px;
        }

        .matryoshka-depth input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        .matryoshka-depth span {
            color: var(--accent);
            font-weight: bold;
            min-width: 20px;
        }

        .matryoshka-hint {
            color: var(--text-dim);
            font-size: 10px;
            text-align: center;
            margin-top: 8px;
        }

        .matryoshka-close {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            margin-top: 12px;
            width: 100%;
        }

        .matryoshka-close:hover {
            background: rgba(255, 0, 255, 0.2);
        }

        /* Matryoshka encode */
        .matryoshka-carrier-list {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            max-height: 120px;
            overflow-y: auto;
        }

        .matryoshka-no-carriers {
            color: #666;
            font-size: 10px;
            text-align: center;
        }

        .matryoshka-carrier-item {
            color: #8b5cf6;
            font-size: 10px;
            padding: 3px 6px;
            background: rgba(255, 0, 255, 0.1);
            border-radius: 3px;
            margin-bottom: 2px;
        }

        .matryoshka-encode-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 10px;
        }

        .btn-pink {
            background: rgba(255, 0, 255, 0.3);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn-pink:hover {
            background: rgba(255, 0, 255, 0.5);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .w-full {
            width: 100%;
        }

        .mt-2 {
            margin-top: 8px;
        }

        .mt-3 {
            margin-top: 12px;
        }

        .mt-4 {
            margin-top: 16px;
        }

        .btn-lg {
            padding: 12px 24px;
            font-size: 14px;
        }

        .text-pink {
            color: var(--accent) !important;
        }

        .text-muted {
            color: #888;
            font-size: 12px;
        }

        /* Matryoshka tab button */
        .tab-matryoshka {
            color: var(--accent) !important;
            border-color: var(--accent) !important;
        }

        .tab-matryoshka.active {
            background: var(--accent) !important;
            color: #000 !important;
        }

        /* GODMODE tab button */
        .tab-godmode {
            color: #ff3333 !important;
            border-color: #ff3333 !important;
            text-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
        }

        .tab-godmode.active {
            background: linear-gradient(135deg, #ff3333 0%, #ff0000 100%) !important;
            color: #000 !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        /* Text Lab tab button */
        .tab-textlab {
            color: #7c3aed !important;
            border-color: #7c3aed !important;
        }

        .tab-textlab.active {
            background: #7c3aed !important;
            color: #fff !important;
        }

        /* Audio tab button */
        .tab-audio {
            color: #00d4ff !important;
            border-color: #00d4ff !important;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .tab-audio.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%) !important;
            color: #000 !important;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        /* Audio panel styles */
        .audio-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .audio-main-title {
            color: #00d4ff;
            font-size: 28px;
            margin: 0;
        }

        .audio-main-subtitle {
            color: #66e0ff;
            font-size: 14px;
            margin-top: 4px;
        }

        /* Waveform canvas */
        .waveform-container {
            background: #0a0a0a;
            border: 1px solid #00d4ff33;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }

        .waveform-canvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        /* Audio player controls */
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .audio-controls button {
            background: #00d4ff22;
            border: 1px solid #00d4ff;
            color: #00d4ff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .audio-controls button:hover {
            background: #00d4ff44;
        }

        .audio-time {
            color: #00d4ff;
            font-family: monospace;
            font-size: 12px;
        }

        .audio-seek {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #00d4ff33;
            border-radius: 3px;
            cursor: pointer;
        }

        .audio-seek::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Spectrogram canvas */
        .spectrogram-container {
            background: #0a0a0a;
            border: 1px solid #00d4ff33;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }

        .spectrogram-canvas {
            width: 100%;
            height: 200px;
            display: block;
            image-rendering: pixelated;
        }

        .spectrogram-label {
            color: #00d4ff;
            font-size: 11px;
            margin-bottom: 5px;
        }

        /* Audio method buttons */
        .audio-method-btn {
            background: transparent;
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .audio-method-btn:hover {
            background: #00d4ff22;
        }

        .audio-method-btn.active {
            background: #00d4ff;
            color: #000;
        }

        /* GODMODE panel styles */
        .godmode-header {
            text-align: center;
            margin-bottom: 24px;
            position: relative;
        }

        .godmode-main-title {
            color: #ff3333;
            font-size: 28px;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.6);
            animation: godmodePulse 2s ease-in-out infinite;
        }

        @keyframes godmodePulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 20px rgba(255, 51, 51, 0.6); }
            50% { opacity: 0.8; text-shadow: 0 0 40px rgba(255, 51, 51, 0.9); }
        }

        .godmode-main-subtitle {
            color: #ff6666;
            font-size: 14px;
            margin-top: 4px;
        }

        .text-red {
            color: #ff3333;
        }

        .btn-red {
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            color: #fff;
            border: none;
        }

        .btn-red:hover {
            background: linear-gradient(135deg, #ff3333 0%, #cc0000 100%);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        .godmode-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, #ff3333 0%, #990000 100%);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .godmode-indicator:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.7);
        }

        .godmode-indicator .indicator-text {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        .godmode-indicator .indicator-hint {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
        }

        .cipher-pattern-input {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(255, 51, 51, 0.1);
            border: 1px solid #ff3333;
            color: #ff6666;
            padding: 12px;
            border-radius: 4px;
            width: 100%;
            font-size: 14px;
        }

        .cipher-pattern-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.3);
        }

        .cipher-preview {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            font-family: monospace;
            font-size: 11px;
            color: #888;
            margin-top: 8px;
        }

        /* Matryoshka panel header */
        .matryoshka-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .matryoshka-main-title {
            color: var(--accent);
            font-size: 28px;
            margin: 0;
        }

        .matryoshka-main-subtitle {
            color: #a78bfa;
            font-size: 14px;
            margin-top: 4px;
        }

        /* Matryoshka depth control */
        .matryoshka-depth-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .matryoshka-depth-control input[type="range"] {
            flex-grow: 1;
            accent-color: var(--accent);
        }

        .depth-value {
            color: var(--accent);
            font-weight: bold;
            font-size: 18px;
            min-width: 24px;
            text-align: center;
        }

        /* Matryoshka indicator */
        .matryoshka-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            background: linear-gradient(135deg, #1a0020 0%, #0d0015 100%);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .matryoshka-indicator:hover {
            background: rgba(255, 0, 255, 0.2);
        }

        .indicator-text {
            color: var(--accent);
            font-weight: bold;
        }

        .indicator-hint {
            color: #a78bfa;
            font-size: 10px;
        }

        /* Matryoshka results */
        .matryoshka-results {
            background: #000;
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
        }

        .matryoshka-layer {
            padding: 8px;
            margin-bottom: 4px;
            border-left: 3px solid var(--accent);
            background: rgba(255, 0, 255, 0.1);
            border-radius: 0 4px 4px 0;
        }

        .matryoshka-layer-header {
            color: var(--accent);
            font-weight: bold;
            margin-bottom: 4px;
        }

        .matryoshka-layer-info {
            color: #aaa;
            font-size: 11px;
        }

        .matryoshka-layer-preview {
            color: #ccc;
            font-size: 11px;
            margin-top: 4px;
            max-height: 60px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--primary-dim); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary); }

        /* Utility */
        .hidden { display: none !important; }
        .text-cyan { color: var(--secondary); }
        .text-pink { color: var(--accent); }
        .text-yellow { color: var(--warning); }
        .text-green { color: var(--primary); }
        .mt-2 { margin-top: 8px; }
        .mt-3 { margin-top: 12px; }
        .mt-4 { margin-top: 16px; }
        .mb-2 { margin-bottom: 8px; }
        .mb-4 { margin-bottom: 16px; }
        .w-full { width: 100%; }

        /* Matryoshka Encode/Decode grids */
        .matryoshka-encode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .matryoshka-decode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .matryoshka-encode-settings,
        .matryoshka-encode-payload,
        .matryoshka-decode-input,
        .matryoshka-decode-results {
            display: flex;
            flex-direction: column;
        }

        /* Smaller drop zones for matryoshka */
        .drop-zone-sm {
            border: 2px dashed var(--accent);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            background: rgba(255, 0, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drop-zone-sm:hover {
            background: rgba(255, 0, 255, 0.15);
            border-color: #8b5cf6;
        }

        .drop-zone-sm.drag-over {
            background: rgba(255, 0, 255, 0.25);
            border-color: #8b5cf6;
        }

        .drop-zone-sm input[type="file"] {
            display: none;
        }

        .drop-zone-sm .drop-zone-text {
            color: var(--accent);
            font-size: 12px;
        }

        /* Smaller image preview for matryoshka */
        .image-preview-sm {
            max-width: 150px;
            max-height: 100px;
            border-radius: 4px;
            border: 1px solid var(--accent);
        }

        /* Button groups */
        .btn-group {
            display: flex;
            gap: 4px;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 11px;
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--text-dim);
            color: var(--text-dim);
        }

        .btn-secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-lg {
            padding: 14px 28px;
            font-size: 16px;
        }

        .btn-pink {
            background: linear-gradient(135deg, var(--accent) 0%, #cc00cc 100%);
            border: none;
        }

        .btn-pink:hover {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }

        /* Checkbox styling */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            accent-color: var(--accent);
            width: 16px;
            height: 16px;
        }

        @media (max-width: 768px) {
            .matryoshka-encode-grid,
            .matryoshka-decode-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <pre class="banner">
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            </pre>
            <p class="subtitle" style="font-size: 10px; letter-spacing: 3px; margin-top: -10px; opacity: 0.7;">O SAURUS WRECKS</p>
        </header>

        <!-- Tabs -->
        <nav class="tabs">
            <button class="tab active" data-tab="encode">Encode</button>
            <button class="tab" data-tab="decode">Decode</button>
            <button class="tab" data-tab="analyze">Analyze</button>
            <button class="tab tab-matryoshka" data-tab="matryoshka" id="matryoshka-tab-btn" style="display: none;">ü™Ü Nested Stegg</button>
            <button class="tab tab-godmode" data-tab="godmode" id="godmode-tab-btn" style="display: none;">üëÅ GODMODE</button>
            <button class="tab tab-textlab" data-tab="textlab" id="textlab-tab-btn" style="display: none;">üî§ Text Lab</button>
        </nav>

        <!-- Encode Panel -->
        <section class="panel active" id="encode-panel">
            <div class="grid">
                <div class="card" id="encode-carrier-card">
                    <h2 class="card-title" id="encode-carrier-title">Carrier Media</h2>
                    <div class="drop-zone" id="encode-carrier-drop">
                        <input type="file" id="encode-carrier-input" accept="image/png,image/jpeg,image/webp,image/gif,audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/flac,audio/*">
                        <div class="drop-zone-text">Drop image or audio file</div>
                        <div class="drop-zone-hint">Images: PNG/JPEG/WebP/GIF | Audio: WAV/MP3/OGG/FLAC</div>
                    </div>
                    <!-- Image preview (shown for images) -->
                    <img id="encode-carrier-preview" class="image-preview hidden">
                    <div id="encode-carrier-info" class="image-info"></div>

                    <!-- Audio preview (shown for audio) -->
                    <div id="encode-audio-preview" class="hidden">
                        <div class="waveform-container">
                            <canvas id="encode-audio-waveform" class="waveform-canvas"></canvas>
                        </div>
                        <div class="audio-controls">
                            <button id="encode-audio-play-btn" onclick="toggleEncodeAudioPlayback()">‚ñ∂</button>
                            <span id="encode-audio-current-time" class="audio-time">0:00</span>
                            <input type="range" id="encode-audio-seek" class="audio-seek" min="0" max="100" value="0">
                            <span id="encode-audio-duration" class="audio-time">0:00</span>
                        </div>
                        <div id="encode-audio-metadata" class="text-muted mt-2" style="font-size: 11px;"></div>
                        <div class="spectrogram-container mt-2">
                            <div class="spectrogram-label">Spectrogram</div>
                            <canvas id="encode-audio-spectrogram" class="spectrogram-canvas"></canvas>
                        </div>
                    </div>

                    <!-- Generate carrier (image only) -->
                    <div class="mt-4" id="encode-generate-carrier">
                        <div class="form-label">Or generate a carrier:</div>
                        <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                            <select class="form-select" id="carrier-size" style="width: auto;">
                                <option value="512">512√ó512</option>
                                <option value="768">768√ó768</option>
                                <option value="900" selected>900√ó900</option>
                                <option value="1024">1024√ó1024</option>
                                <option value="1200">1200√ó1200</option>
                                <option value="1600">1600√ó1600</option>
                                <option value="2048">2048√ó2048</option>
                            </select>
                            <button class="btn btn-secondary" onclick="generateCarrier('noise')">Noise</button>
                            <button class="btn btn-secondary" onclick="generateCarrier('black')">Black</button>
                            <button class="btn btn-secondary" onclick="generateCarrier('white')">White</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2 class="card-title">Payload Data</h2>
                    <div class="form-group">
                        <div class="btn-group">
                            <button class="btn" id="payload-text-btn" onclick="setPayloadMode('text')">Text</button>
                            <button class="btn btn-secondary" id="payload-file-btn" onclick="setPayloadMode('file')">File</button>
                        </div>
                    </div>

                    <div id="payload-text-mode">
                        <div class="form-group">
                            <label class="form-label">Secret Message</label>
                            <textarea class="form-textarea" id="encode-text" placeholder="Enter your hidden message here..."></textarea>
                            <div style="margin-top: 8px; display: flex; align-items: center; gap: 12px;">
                                <label class="form-check" style="margin: 0;">
                                    <input type="checkbox" id="zerowidth-toggle" onchange="toggleZeroWidth()">
                                    <span style="font-size: 11px;">Zero-Width Unicode Mode</span>
                                </label>
                                <span id="zerowidth-hint" class="text-muted" style="font-size: 10px; display: none;">Hide text IN text using invisible chars</span>
                            </div>
                            <div id="zerowidth-cover-input" class="hidden" style="margin-top: 10px;">
                                <label class="form-label" style="color: #7c3aed;">Cover Text (the visible message)</label>
                                <textarea class="form-textarea" id="zerowidth-cover" placeholder="Enter the innocent-looking cover text that will contain the hidden message..." style="border-color: #7c3aed55; min-height: 80px;"></textarea>
                                <button class="btn" style="margin-top: 8px; background: #7c3aed;" onclick="encodeZeroWidth()">Encode Zero-Width</button>
                                <div id="zerowidth-result" class="hidden" style="margin-top: 10px;">
                                    <label class="form-label" style="color: #7c3aed;">Stego Text (copy this)</label>
                                    <textarea class="form-textarea" id="zerowidth-output" readonly style="border-color: #7c3aed; background: #1a1a2e; min-height: 60px;"></textarea>
                                    <button class="btn btn-secondary" style="margin-top: 6px;" onclick="copyZeroWidthOutput()">Copy to Clipboard</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="payload-file-mode" class="hidden">
                        <div class="drop-zone" id="encode-file-drop">
                            <input type="file" id="encode-file-input">
                            <div class="drop-zone-text">Drop file or click to browse</div>
                            <div class="drop-zone-hint">Any file type supported</div>
                        </div>
                        <div id="encode-file-info" class="image-info"></div>
                    </div>

                    <div class="card-title mt-4" id="encode-settings-title">Settings</div>

                    <!-- Image encoding methods (shown for images) -->
                    <div class="form-group" id="image-method-group">
                        <label class="form-label">Encoding Method</label>
                        <select class="form-select" id="encode-method" onchange="updateMethodOptions()">
                            <option value="LSB">LSB (Least Significant Bit)</option>
                            <option value="PVD">PVD (Pixel Value Differencing)</option>
                            <option value="DCT">DCT (Survives JPEG compression)</option>
                            <option value="F5">F5 (JPEG domain steganography)</option>
                            <option value="SPREAD">Spread Spectrum (Password-based)</option>
                            <option value="PALETTE">Palette (Color index encoding)</option>
                            <option value="CHROMA">Chroma (Color channel hiding)</option>
                            <option value="PNGCHUNK">PNG Chunks (Metadata hiding)</option>
                        </select>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;" id="method-hint">
                            Classic steganography - high capacity, fragile to compression
                        </div>
                    </div>

                    <!-- Audio encoding methods (shown for audio) -->
                    <div class="form-group hidden" id="audio-method-group">
                        <label class="form-label" style="color: #00d4ff;">Audio Encoding Method</label>
                        <select class="form-select" id="audio-encode-method" onchange="updateAudioMethodOptions()" style="border-color: #00d4ff55;">
                            <option value="AUDIO_LSB">LSB (Sample bits)</option>
                            <option value="AUDIO_FFT">FFT (Frequency domain)</option>
                            <option value="AUDIO_ECHO">Echo Hiding</option>
                            <option value="AUDIO_SPECART">Spectrogram Art üé®</option>
                        </select>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;" id="audio-method-hint">
                            Modify least significant bits of audio samples. High capacity.
                        </div>
                    </div>

                    <!-- LSB Options -->
                    <div id="lsb-options">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Channels</label>
                                <select class="form-select" id="encode-channels">
                                    <option value="RGB">RGB</option>
                                    <option value="RGBA">RGBA</option>
                                    <option value="R">R only</option>
                                    <option value="G">G only</option>
                                    <option value="B">B only</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Bits/Channel</label>
                                <select class="form-select" id="encode-bits">
                                    <option value="1">1 bit</option>
                                    <option value="2">2 bits</option>
                                    <option value="4">4 bits</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- DCT Options -->
                    <div id="dct-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Robustness</label>
                                <select class="form-select" id="dct-robustness">
                                    <option value="low">Low (more capacity)</option>
                                    <option value="medium" selected>Medium (balanced)</option>
                                    <option value="high">High (survives heavy compression)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Block Size</label>
                                <select class="form-select" id="dct-blocksize">
                                    <option value="8" selected>8x8 (standard)</option>
                                    <option value="16">16x16 (more robust)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- F5 Options (JPEG domain steganography) -->
                    <div id="f5-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Password (encryption key)</label>
                            <input type="password" class="form-input" id="f5-password" placeholder="Enter password for F5 encoding...">
                            <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                                Password is required. Used to shuffle DCT coefficient positions.
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">JPEG Quality</label>
                            <select class="form-select" id="f5-quality">
                                <option value="0.98">98% (highest quality)</option>
                                <option value="0.95" selected>95% (recommended)</option>
                                <option value="0.92">92% (good balance)</option>
                                <option value="0.90">90% (smaller file)</option>
                            </select>
                        </div>
                        <div class="alert" style="background: #1a3a1a; border-color: #0a0; margin-top: 10px;">
                            <strong>F5 outputs JPEG!</strong> Operates directly on JPEG DCT coefficients for better statistical security. Output is always JPEG format. Note: does NOT survive social media recompression.
                        </div>
                    </div>

                    <!-- Spread Spectrum Options -->
                    <div id="spread-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Password (seed for spreading)</label>
                            <input type="password" class="form-input" id="spread-password" placeholder="Enter password...">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Spread Factor</label>
                                <select class="form-select" id="spread-factor">
                                    <option value="8">8x (more capacity)</option>
                                    <option value="16" selected>16x (balanced)</option>
                                    <option value="32">32x (more robust)</option>
                                    <option value="64">64x (maximum robustness)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Strength</label>
                                <select class="form-select" id="spread-strength">
                                    <option value="1">Subtle (¬±1)</option>
                                    <option value="2" selected>Normal (¬±2)</option>
                                    <option value="3">Strong (¬±3)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Palette Options -->
                    <div id="palette-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Color Count</label>
                                <select class="form-select" id="palette-colors">
                                    <option value="256" selected>256 colors (8-bit)</option>
                                    <option value="128">128 colors</option>
                                    <option value="64">64 colors</option>
                                    <option value="32">32 colors</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Encoding Mode</label>
                                <select class="form-select" id="palette-mode">
                                    <option value="index" selected>Index LSB</option>
                                    <option value="order">Palette ordering</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Chroma Options -->
                    <div id="chroma-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Color Space</label>
                                <select class="form-select" id="chroma-space">
                                    <option value="ycbcr" selected>YCbCr (Best hiding)</option>
                                    <option value="hsl">HSL (Hue/Saturation)</option>
                                    <option value="lab">LAB (Perceptual)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Target Channel</label>
                                <select class="form-select" id="chroma-channel">
                                    <option value="both" selected>Both Chroma (Cb+Cr)</option>
                                    <option value="cb">Blue Chroma (Cb)</option>
                                    <option value="cr">Red Chroma (Cr)</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Intensity</label>
                                <select class="form-select" id="chroma-intensity">
                                    <option value="1">Minimal (¬±1)</option>
                                    <option value="2" selected>Low (¬±2)</option>
                                    <option value="3">Medium (¬±3)</option>
                                    <option value="5">High (¬±5)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Pattern</label>
                                <select class="form-select" id="chroma-pattern">
                                    <option value="sequential" selected>Sequential</option>
                                    <option value="checkerboard">Checkerboard</option>
                                    <option value="edges">Edge Areas</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- PVD Options -->
                    <div id="pvd-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Scan Direction</label>
                                <select class="form-select" id="pvd-direction">
                                    <option value="horizontal" selected>Horizontal</option>
                                    <option value="vertical">Vertical</option>
                                    <option value="both">Both (more capacity)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Range Table</label>
                                <select class="form-select" id="pvd-range">
                                    <option value="wu-tsai" selected>Wu-Tsai (standard)</option>
                                    <option value="wide">Wide ranges (more capacity)</option>
                                    <option value="narrow">Narrow ranges (more subtle)</option>
                                </select>
                            </div>
                        </div>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                            Encodes based on pixel pair differences. More robust than LSB, harder to detect.
                        </div>
                    </div>

                    <!-- PNG Chunk Options -->
                    <div id="pngchunk-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Chunk Type</label>
                            <select class="form-select" id="pngchunk-type">
                                <option value="tEXt" selected>tEXt (uncompressed)</option>
                                <option value="zTXt">zTXt (compressed)</option>
                                <option value="iTXt">iTXt (international text)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Keyword (chunk identifier)</label>
                            <input type="text" class="form-input" id="pngchunk-keyword" value="Comment" placeholder="Chunk keyword...">
                            <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                                Common keywords: Comment, Description, Copyright, Source. Data hidden inside the chunk.
                            </div>
                        </div>
                        <div class="alert" style="background: #1a2a3a; border-color: #06a; margin-top: 10px;">
                            <strong>PNG only!</strong> This method only works with PNG output. Data survives most platforms that don't re-encode images.
                        </div>
                    </div>

                    <!-- Audio LSB Options (shown for audio) -->
                    <div id="audio-lsb-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Bits/Sample</label>
                                <select class="form-select" id="audio-lsb-bits" style="border-color: #00d4ff55;">
                                    <option value="1">1 bit (subtle)</option>
                                    <option value="2" selected>2 bits (balanced)</option>
                                    <option value="4">4 bits (more capacity)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Channels</label>
                                <select class="form-select" id="audio-lsb-channels" style="border-color: #00d4ff55;">
                                    <option value="both" selected>Both (L+R)</option>
                                    <option value="left">Left only</option>
                                    <option value="right">Right only</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Audio FFT Options -->
                    <div id="audio-fft-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Frequency Range</label>
                                <select class="form-select" id="audio-fft-range" style="border-color: #00d4ff55;">
                                    <option value="high" selected>High (14-20kHz) - Inaudible</option>
                                    <option value="mid">Mid (8-14kHz) - Subtle</option>
                                    <option value="low">Low (4-8kHz) - Audible</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Strength</label>
                                <select class="form-select" id="audio-fft-strength" style="border-color: #00d4ff55;">
                                    <option value="low">Low (subtle)</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="high">High (robust)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Echo Options -->
                    <div id="audio-echo-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Echo Delay (ms)</label>
                                <select class="form-select" id="audio-echo-delay" style="border-color: #00d4ff55;">
                                    <option value="0.5">0.5ms (subtle)</option>
                                    <option value="1" selected>1ms (balanced)</option>
                                    <option value="2">2ms (audible)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Echo Amplitude</label>
                                <select class="form-select" id="audio-echo-amp" style="border-color: #00d4ff55;">
                                    <option value="0.1">10% (quiet)</option>
                                    <option value="0.2" selected>20% (balanced)</option>
                                    <option value="0.3">30% (loud)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Spectrogram Art Options -->
                    <div id="audio-specart-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label" style="color: #66e0ff;">Image to Embed in Spectrogram</label>
                            <div class="drop-zone drop-zone-sm" id="audio-specart-drop" style="border-color: #00d4ff55;">
                                <input type="file" id="audio-specart-input" accept="image/*">
                                <div class="drop-zone-text" style="font-size: 11px;">Drop image for spectrogram art</div>
                            </div>
                            <img id="audio-specart-preview" class="hidden mt-2" style="max-width: 100px; max-height: 60px;">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Freq Range</label>
                                <select class="form-select" id="audio-specart-freq" style="border-color: #00d4ff55;">
                                    <option value="2000-10000" selected>2-10kHz (visible)</option>
                                    <option value="500-8000">0.5-8kHz (full)</option>
                                    <option value="10000-20000">10-20kHz (hidden)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label" style="color: #66e0ff;">Intensity</label>
                                <input type="range" id="audio-specart-intensity" min="10" max="100" value="50" class="form-range">
                            </div>
                        </div>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px; color: #66e0ff;">
                            üé® Aphex Twin style! Your image will appear in spectrogram viewers.
                        </div>
                    </div>

                    <div id="encode-capacity" class="capacity-meter">
                        <div class="capacity-header">
                            <span class="text-green">CAPACITY</span>
                            <span id="capacity-bytes">-- bytes</span>
                        </div>
                        <div class="capacity-bar">
                            <div class="capacity-fill" id="capacity-fill" style="width: 0%"></div>
                        </div>
                        <div class="capacity-footer">
                            <span id="capacity-status">Load an image</span>
                            <span id="capacity-percent">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="btn-group" style="justify-content: center;">
                <button class="btn btn-primary" onclick="doEncode()">ENCODE</button>
                <button class="btn btn-secondary hidden" id="quick-download-btn" onclick="downloadResult()">DOWNLOAD</button>
            </div>

            <div id="encode-result" class="card mt-4 hidden">
                <h2 class="card-title text-green">Encoded Image</h2>
                <img id="encode-result-preview" class="image-preview">
                <div id="encode-result-info" class="image-info"></div>
                <div class="form-group mt-3" style="margin-bottom: 10px;">
                    <label class="form-label" style="font-size: 11px;">Filename</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" class="form-input" id="download-filename" value="stego_output" style="flex: 1;" placeholder="filename">
                        <span id="download-extension" style="color: var(--primary); font-family: monospace;">.png</span>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="downloadResult()">Download</button>
            </div>
        </section>

        <!-- Decode Panel -->
        <section class="panel" id="decode-panel">
            <div class="grid">
                <div class="card" id="decode-media-card">
                    <h2 class="card-title" id="decode-media-title">Stego Media</h2>
                    <div class="drop-zone" id="decode-image-drop">
                        <input type="file" id="decode-image-input" accept="image/png,image/jpeg,image/webp,image/gif,audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/flac,audio/*">
                        <div class="drop-zone-text">Drop image/audio, paste, or click to browse</div>
                        <div class="drop-zone-hint">Image or audio file with hidden data</div>
                    </div>
                    <img id="decode-image-preview" class="image-preview hidden">

                    <!-- Audio preview for decode -->
                    <div id="decode-audio-preview" class="hidden">
                        <div class="waveform-container">
                            <canvas id="decode-audio-waveform" class="waveform-canvas"></canvas>
                        </div>
                        <div class="audio-controls">
                            <button id="decode-audio-play-btn" onclick="toggleDecodeAudioPlayback()">‚ñ∂</button>
                            <span id="decode-audio-current-time" class="audio-time">0:00</span>
                            <input type="range" id="decode-audio-seek" class="audio-seek" min="0" max="100" value="0">
                            <span id="decode-audio-duration" class="audio-time">0:00</span>
                        </div>
                        <div id="decode-audio-metadata" class="text-muted mt-2" style="font-size: 11px;"></div>
                        <div class="spectrogram-container mt-2">
                            <canvas id="decode-audio-spectrogram" class="spectrogram-canvas"></canvas>
                        </div>
                    </div>

                    <div id="decode-image-info" class="image-info"></div>
                    <div id="decode-detection" class="mt-2"></div>
                </div>

                <div class="card" id="decode-options-card">
                    <h2 class="card-title" id="decode-options-title">Decode Options</h2>

                    <!-- Image decode methods (default) -->
                    <div class="form-group" id="image-decode-method-group">
                        <label class="form-label">Decoding Method</label>
                        <select class="form-select" id="decode-method" onchange="updateDecodeMethodOptions()">
                            <option value="AUTO" selected>Auto Detect</option>
                            <option value="LSB">LSB (Least Significant Bit)</option>
                            <option value="PVD">PVD (Pixel Value Differencing)</option>
                            <option value="DCT">DCT (Frequency domain)</option>
                            <option value="F5">F5 (JPEG domain)</option>
                            <option value="SPREAD">Spread Spectrum (Password-based)</option>
                            <option value="PALETTE">Palette (Color index encoding)</option>
                            <option value="CHROMA">Chroma (Color channel hiding)</option>
                            <option value="PNGCHUNK">PNG Chunks (Metadata)</option>
                        </select>
                    </div>

                    <!-- Audio decode methods (shown for audio) -->
                    <div class="form-group hidden" id="audio-decode-method-group">
                        <label class="form-label" style="color: #00d4ff;">Audio Decoding Method</label>
                        <select class="form-select" id="audio-decode-method" onchange="updateAudioDecodeMethodOptions()">
                            <option value="AUDIO_AUTO" selected>Auto Detect</option>
                            <option value="AUDIO_LSB">LSB (Sample bits)</option>
                            <option value="AUDIO_FFT">FFT (Frequency domain)</option>
                            <option value="AUDIO_ECHO">Echo Hiding</option>
                        </select>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;" id="audio-decode-method-hint">
                            Attempts LSB, FFT, and Echo methods
                        </div>
                    </div>

                    <!-- Audio decode option sections -->
                    <div id="audio-decode-lsb-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Channel</label>
                                <select class="form-select" id="audio-decode-channel">
                                    <option value="mono">Mono/Left</option>
                                    <option value="stereo">Stereo (Both)</option>
                                    <option value="right">Right Only</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Bits/Sample</label>
                                <select class="form-select" id="audio-decode-bits">
                                    <option value="1">1 bit</option>
                                    <option value="2">2 bits</option>
                                    <option value="4">4 bits</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="audio-decode-fft-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Frequency Range</label>
                                <select class="form-select" id="audio-decode-freq-range">
                                    <option value="high" selected>High (14-20kHz)</option>
                                    <option value="mid">Mid (8-14kHz)</option>
                                    <option value="low">Low (2-8kHz)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="audio-decode-echo-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Echo Delays (ms)</label>
                                <div class="text-muted" style="font-size: 10px;">
                                    Default: 0.5ms (0) / 1.0ms (1)
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- LSB Decode Options -->
                    <div id="lsb-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Channels</label>
                                <select class="form-select" id="decode-channels">
                                    <option value="RGB">RGB</option>
                                    <option value="RGBA">RGBA</option>
                                    <option value="R">R only</option>
                                    <option value="G">G only</option>
                                    <option value="B">B only</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Bits/Channel</label>
                                <select class="form-select" id="decode-bits">
                                    <option value="1">1 bit</option>
                                    <option value="2">2 bits</option>
                                    <option value="4">4 bits</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- DCT Decode Options -->
                    <div id="dct-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Block Size</label>
                                <select class="form-select" id="dct-decode-blocksize">
                                    <option value="8" selected>8x8</option>
                                    <option value="16">16x16</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- F5 Decode Options -->
                    <div id="f5-decode-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Password</label>
                            <input type="password" class="form-input" id="f5-decode-password" placeholder="Enter F5 password...">
                            <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                                Must match the password used during encoding.
                            </div>
                        </div>
                    </div>

                    <!-- Spread Spectrum Decode Options -->
                    <div id="spread-decode-options" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Password</label>
                            <input type="password" class="form-input" id="spread-decode-password" placeholder="Enter password...">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Spread Factor</label>
                                <select class="form-select" id="spread-decode-factor">
                                    <option value="8">8x</option>
                                    <option value="16" selected>16x</option>
                                    <option value="32">32x</option>
                                    <option value="64">64x</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Palette Decode Options -->
                    <div id="palette-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Encoding Mode</label>
                                <select class="form-select" id="palette-decode-mode">
                                    <option value="index" selected>Index LSB</option>
                                    <option value="order">Palette ordering</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Chroma Decode Options -->
                    <div id="chroma-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Color Space</label>
                                <select class="form-select" id="chroma-decode-space">
                                    <option value="ycbcr" selected>YCbCr</option>
                                    <option value="hsl">HSL</option>
                                    <option value="lab">LAB</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Target Channel</label>
                                <select class="form-select" id="chroma-decode-channel">
                                    <option value="both" selected>Both Chroma</option>
                                    <option value="cb">Blue Chroma (Cb)</option>
                                    <option value="cr">Red Chroma (Cr)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- PVD Decode Options -->
                    <div id="pvd-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Scan Direction</label>
                                <select class="form-select" id="pvd-decode-direction">
                                    <option value="horizontal" selected>Horizontal</option>
                                    <option value="vertical">Vertical</option>
                                    <option value="both">Both</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Range Table</label>
                                <select class="form-select" id="pvd-decode-range">
                                    <option value="wu-tsai" selected>Wu-Tsai (standard)</option>
                                    <option value="wide">Wide ranges</option>
                                    <option value="narrow">Narrow ranges</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- PNG Chunk Decode Options -->
                    <div id="pngchunk-decode-options" class="hidden">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Chunk Type</label>
                                <select class="form-select" id="pngchunk-decode-type">
                                    <option value="tEXt" selected>tEXt</option>
                                    <option value="zTXt">zTXt</option>
                                    <option value="iTXt">iTXt</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Keyword</label>
                                <input type="text" class="form-input" id="pngchunk-decode-keyword" value="Comment">
                            </div>
                        </div>
                    </div>

                    <!-- Quick Decode Result (shows right here after decode) -->
                    <div id="quick-decode-result" class="hidden mt-3" style="border-top: 1px solid var(--border); padding-top: 12px;">
                        <label class="form-label text-cyan">Extracted Message</label>
                        <pre id="quick-decode-content" style="background: #111; padding: 10px; border-radius: 4px; max-height: 150px; overflow: auto; font-size: 12px; color: var(--primary); white-space: pre-wrap; word-break: break-all;"></pre>
                        <button class="btn btn-sm btn-secondary mt-2" onclick="downloadExtracted()">Download</button>
                    </div>
                </div>
            </div>

            <div class="btn-group" style="justify-content: center;">
                <button class="btn btn-purple" onclick="doSmartScan()">SMART SCAN</button>
                <button class="btn btn-primary" onclick="doDecode()">DECODE</button>
                <button class="btn btn-pink hidden" id="matryoshka-decode-btn" onclick="doMatryoshkaDecode()">NESTED STEGG DECODE</button>
            </div>

            <div id="scan-results" class="card mt-4 hidden">
                <h2 class="card-title text-pink">Scan Results</h2>
                <div id="scan-results-content"></div>
            </div>

            <div id="matryoshka-results" class="card mt-4 hidden">
                <h2 class="card-title text-pink">Nested Stegg Results</h2>
                <div id="matryoshka-results-content" class="matryoshka-results"></div>
            </div>

            <div id="decode-result" class="card mt-4 hidden">
                <h2 class="card-title text-cyan">Extracted Data</h2>
                <div id="decode-result-content" class="terminal"></div>
                <div class="btn-group mt-2">
                    <button class="btn btn-secondary" id="download-extracted-btn" onclick="downloadExtracted()">Download</button>
                </div>
            </div>
        </section>

        <!-- Analyze Panel -->
        <section class="panel" id="analyze-panel">
            <div class="grid">
                <div class="card" id="analyze-media-card">
                    <h2 class="card-title" id="analyze-media-title">Media to Analyze</h2>
                    <div class="drop-zone" id="analyze-image-drop">
                        <input type="file" id="analyze-image-input" accept="image/png,image/jpeg,image/webp,image/gif,audio/wav,audio/mp3,audio/mpeg,audio/ogg,audio/flac,audio/*">
                        <div class="drop-zone-text">Drop image or audio file</div>
                        <div class="drop-zone-hint">Analyze for hidden data signatures</div>
                    </div>
                    <img id="analyze-image-preview" class="image-preview hidden">

                    <!-- Audio preview for analyze -->
                    <div id="analyze-audio-preview" class="hidden">
                        <div class="waveform-container">
                            <canvas id="analyze-audio-waveform" class="waveform-canvas"></canvas>
                        </div>
                        <div class="audio-controls">
                            <button id="analyze-audio-play-btn" onclick="toggleAnalyzeAudioPlayback()">‚ñ∂</button>
                            <span id="analyze-audio-current-time" class="audio-time">0:00</span>
                            <input type="range" id="analyze-audio-seek" class="audio-seek" min="0" max="100" value="0">
                            <span id="analyze-audio-duration" class="audio-time">0:00</span>
                        </div>
                        <div id="analyze-audio-metadata" class="text-muted mt-2" style="font-size: 11px;"></div>
                    </div>

                    <div id="analyze-image-info" class="image-info"></div>
                </div>

                <div class="card" id="analyze-results-card">
                    <h2 class="card-title" id="analyze-results-title">Analysis Results</h2>
                    <div id="analyze-result" class="terminal" style="max-height: 500px;">Click ANALYZE to inspect media...</div>
                </div>
            </div>

            <div class="btn-group" style="justify-content: center;">
                <button class="btn btn-primary" onclick="doAnalyze()">ANALYZE</button>
            </div>

            <!-- Audio Analysis Section (shown for audio) -->
            <div id="audio-analysis-section" class="hidden" style="margin-top: 20px;">
                <div class="card">
                    <h2 class="card-title" style="color: #00d4ff;">üéµ Audio Analysis</h2>

                    <!-- Large Spectrogram -->
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #00d4ff; font-size: 12px; margin-bottom: 10px;">SPECTROGRAM ANALYSIS</h3>
                        <p class="text-muted" style="font-size: 11px; margin-bottom: 10px;">
                            Hidden images in spectrograms appear as visible patterns (Aphex Twin style)
                        </p>
                        <canvas id="analyze-spectrogram-large" style="width: 100%; height: 200px; border: 1px solid #00d4ff55; background: #000;"></canvas>
                    </div>

                    <!-- Waveform Analysis -->
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #00d4ff; font-size: 12px; margin-bottom: 10px;">WAVEFORM ANALYSIS</h3>
                        <p class="text-muted" style="font-size: 11px; margin-bottom: 10px;">
                            Unusual patterns or anomalies in waveform shape
                        </p>
                        <canvas id="analyze-waveform-large" style="width: 100%; height: 100px; border: 1px solid #00d4ff55; background: #000;"></canvas>
                    </div>

                    <!-- Sample Statistics -->
                    <div class="grid" style="grid-template-columns: repeat(2, 1fr); gap: 15px;">
                        <div>
                            <h3 style="color: #00d4ff; font-size: 12px; margin-bottom: 10px;">LSB DISTRIBUTION</h3>
                            <p class="text-muted" style="font-size: 11px; margin-bottom: 10px;">
                                Non-random LSB patterns indicate hidden data
                            </p>
                            <canvas id="analyze-audio-lsb-hist" style="width: 100%; height: 120px; border: 1px solid #00d4ff55; background: #000;"></canvas>
                        </div>
                        <div>
                            <h3 style="color: #00d4ff; font-size: 12px; margin-bottom: 10px;">FREQUENCY SPECTRUM</h3>
                            <p class="text-muted" style="font-size: 11px; margin-bottom: 10px;">
                                Unusual high-freq energy may indicate FFT steg
                            </p>
                            <canvas id="analyze-audio-freq" style="width: 100%; height: 120px; border: 1px solid #00d4ff55; background: #000;"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Channel Visualization -->
            <div id="channel-layers-section" class="hidden" style="margin-top: 20px;">
                <div class="card">
                    <h2 class="card-title">Color Channel Layers</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Separate R/G/B/A channels can reveal hidden text or patterns
                    </p>
                    <div class="btn-group mb-3">
                        <button class="btn btn-sm" onclick="setChannelView('normal')" id="cv-normal">Normal</button>
                        <button class="btn btn-sm btn-secondary" onclick="setChannelView('enhanced')" id="cv-enhanced">Enhanced</button>
                        <button class="btn btn-sm btn-secondary" onclick="setChannelView('bitplane')" id="cv-bitplane">Bit Planes</button>
                    </div>
                    <div id="channel-layers-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <div style="text-align: center;">
                            <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 5px;">RED Channel</div>
                            <canvas id="channel-r" style="max-width: 100%; border: 1px solid #ff6b6b; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #51cf66; font-weight: bold; margin-bottom: 5px;">GREEN Channel</div>
                            <canvas id="channel-g" style="max-width: 100%; border: 1px solid #51cf66; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #339af0; font-weight: bold; margin-bottom: 5px;">BLUE Channel</div>
                            <canvas id="channel-b" style="max-width: 100%; border: 1px solid #339af0; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #868e96; font-weight: bold; margin-bottom: 5px;">ALPHA Channel</div>
                            <canvas id="channel-a" style="max-width: 100%; border: 1px solid #868e96; background: #000;"></canvas>
                        </div>
                    </div>

                    <!-- Bit Plane Selector (hidden by default) -->
                    <div id="bitplane-controls" class="hidden" style="margin-top: 15px; text-align: center;">
                        <label class="text-muted" style="font-size: 12px;">Bit Plane (0=LSB, 7=MSB): </label>
                        <input type="range" id="bitplane-slider" min="0" max="7" value="0" style="width: 150px;">
                        <span id="bitplane-value" style="margin-left: 10px;">0 (LSB)</span>
                    </div>
                </div>

                <!-- Additional Transforms -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">Steganalysis Transforms</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Advanced transforms to detect hidden data
                    </p>
                    <div id="transforms-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <div style="text-align: center;">
                            <div style="color: #ffd43b; font-weight: bold; margin-bottom: 5px;">Luminance (Y)</div>
                            <canvas id="transform-luma" style="max-width: 100%; border: 1px solid #ffd43b; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #ff922b; font-weight: bold; margin-bottom: 5px;">Inverted</div>
                            <canvas id="transform-invert" style="max-width: 100%; border: 1px solid #ff922b; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #cc5de8; font-weight: bold; margin-bottom: 5px;">Edge Detection</div>
                            <canvas id="transform-edge" style="max-width: 100%; border: 1px solid #cc5de8; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #20c997; font-weight: bold; margin-bottom: 5px;">Noise Residual</div>
                            <canvas id="transform-noise" style="max-width: 100%; border: 1px solid #20c997; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #f783ac; font-weight: bold; margin-bottom: 5px;">XOR Checkerboard</div>
                            <canvas id="transform-xor" style="max-width: 100%; border: 1px solid #f783ac; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #74c0fc; font-weight: bold; margin-bottom: 5px;">LSB Randomness</div>
                            <canvas id="transform-random" style="max-width: 100%; border: 1px solid #74c0fc; background: #000;"></canvas>
                        </div>
                    </div>
                </div>

                <!-- YCbCr Chrominance -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">YCbCr Color Space</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        JPEG uses YCbCr - hidden data may appear in Cb/Cr chrominance channels
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <div style="text-align: center;">
                            <div style="color: #fff; font-weight: bold; margin-bottom: 5px;">Y (Luminance)</div>
                            <canvas id="ycbcr-y" style="max-width: 100%; border: 1px solid #888; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #5c7cfa; font-weight: bold; margin-bottom: 5px;">Cb (Blue Chroma)</div>
                            <canvas id="ycbcr-cb" style="max-width: 100%; border: 1px solid #5c7cfa; background: #000;"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #ff8787; font-weight: bold; margin-bottom: 5px;">Cr (Red Chroma)</div>
                            <canvas id="ycbcr-cr" style="max-width: 100%; border: 1px solid #ff8787; background: #000;"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Histogram -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">Histogram Analysis</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Uneven distributions or gaps can indicate steganography
                    </p>
                    <canvas id="histogram-canvas" style="width: 100%; height: 150px; border: 1px solid var(--border);"></canvas>
                    <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px; font-size: 12px;">
                        <span style="color: #ff6b6b;">‚ñ† Red</span>
                        <span style="color: #51cf66;">‚ñ† Green</span>
                        <span style="color: #339af0;">‚ñ† Blue</span>
                        <span style="color: #868e96;">‚ñ† Luminance</span>
                    </div>
                </div>

                <!-- Zoom/Magnify -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">Pixel Zoom</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Click on the image to zoom - inspect individual pixels
                    </p>
                    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 15px;">
                        <div>
                            <canvas id="zoom-source" style="max-width: 100%; border: 1px solid var(--border); cursor: crosshair;"></canvas>
                        </div>
                        <div>
                            <canvas id="zoom-view" width="160" height="160" style="border: 1px solid var(--primary); image-rendering: pixelated;"></canvas>
                            <div id="zoom-info" class="text-muted" style="font-size: 10px; margin-top: 5px; font-family: monospace;"></div>
                        </div>
                    </div>
                </div>

                <!-- Chi-Square Heatmap -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">Chi-Square Analysis</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Statistical detection - red areas have abnormal LSB distribution (likely steg)
                    </p>
                    <canvas id="chisquare-canvas" style="max-width: 100%; border: 1px solid var(--border); background: #000;"></canvas>
                    <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px; font-size: 12px;">
                        <span style="color: #51cf66;">‚ñ† Normal (œá¬≤ &lt; 10)</span>
                        <span style="color: #ffd43b;">‚ñ† Suspicious (10-50)</span>
                        <span style="color: #ff6b6b;">‚ñ† Likely Steg (œá¬≤ &gt; 50)</span>
                    </div>
                </div>

                <!-- DCT Block Visualization -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">DCT Block Analysis</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Visualize DCT coefficients - anomalies reveal DCT-based steganography
                    </p>
                    <div class="btn-group mb-2">
                        <button class="btn btn-sm" onclick="setDctView('dc')" id="dct-dc">DC Component</button>
                        <button class="btn btn-sm btn-secondary" onclick="setDctView('ac')" id="dct-ac">AC Energy</button>
                        <button class="btn btn-sm btn-secondary" onclick="setDctView('coeff')" id="dct-coeff">Mid-Freq Coeff</button>
                    </div>
                    <canvas id="dct-canvas" style="max-width: 100%; border: 1px solid #be4bdb; background: #000;"></canvas>
                </div>

                <!-- File Structure Analysis -->
                <div class="card" style="margin-top: 15px;">
                    <h2 class="card-title">File Structure Analysis</h2>
                    <p class="text-muted" style="font-size: 12px; margin-bottom: 10px;">
                        Check for data hidden after image end marker or in metadata
                    </p>
                    <div id="file-structure-result" class="terminal" style="font-size: 11px; max-height: 200px; overflow-y: auto;">
                        Load a file via the file input to analyze structure...
                    </div>
                    <div style="margin-top: 10px;">
                        <input type="file" id="file-structure-input" accept="image/*" style="display: none;">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('file-structure-input').click()">
                            Analyze File Structure
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Matryoshka Panel (Hidden Tab) -->
        <section class="panel" id="matryoshka-panel">
            <div class="matryoshka-header">
                <h1 class="matryoshka-main-title">ü™Ü NESTED STEGG ü™Ü</h1>
                <p class="matryoshka-main-subtitle">Multi-Layer Steganography</p>
            </div>

            <!-- ========== ENCODE SECTION (TOP) ========== -->
            <div class="card mb-4">
                <h2 class="card-title text-pink">üîê Nested Encode</h2>
                <p class="text-muted">Hide your payload inside N auto-generated nested layers, wrapped in your carrier image.</p>

                <div class="matryoshka-encode-grid">
                    <!-- Left: Settings -->
                    <div class="matryoshka-encode-settings">
                        <div class="form-group">
                            <label class="form-label text-pink">Nesting Depth</label>
                            <div class="matryoshka-depth-control">
                                <input type="range" id="matryoshka-encode-depth" min="1" max="11" value="3" oninput="document.getElementById('matryoshka-encode-depth-value').textContent = this.value">
                                <span id="matryoshka-encode-depth-value" class="depth-value">3</span>
                            </div>
                            <div class="text-muted" style="font-size: 10px;">Inner layers auto-generated (512x512 noise)</div>
                        </div>

                        <div class="form-group mt-3">
                            <label class="form-label text-pink">Outer Carrier (Final Image)</label>
                            <div class="drop-zone drop-zone-sm" id="matryoshka-outer-drop">
                                <input type="file" id="matryoshka-outer-input" accept="image/png,image/jpeg,image/webp">
                                <div class="drop-zone-text">Drop outer carrier</div>
                            </div>
                            <img id="matryoshka-outer-preview" class="image-preview-sm hidden mt-2">
                            <div id="matryoshka-outer-info" class="text-muted mt-1"></div>
                        </div>

                        <div class="form-group mt-3">
                            <label class="checkbox-label">
                                <input type="checkbox" id="matryoshka-autosize" checked>
                                <span class="text-pink">Auto-size carrier</span>
                            </label>
                            <div class="text-muted" style="font-size: 10px;">Shrink to minimum size needed</div>
                            <div id="matryoshka-size-info" class="mt-1" style="font-size: 11px; color: var(--primary);"></div>
                        </div>

                        <!-- Encoding Options -->
                        <div class="form-group mt-3">
                            <label class="form-label text-pink">Encoding Options</label>
                            <div style="display: flex; gap: 12px;">
                                <div style="flex: 1;">
                                    <label class="text-muted" style="font-size: 10px;">Mode</label>
                                    <select class="form-select" id="matryoshka-embed-mode" style="font-size: 12px; padding: 6px;">
                                        <option value="lsb" selected>LSB (high capacity)</option>
                                        <option value="dct">DCT (compression-resistant)</option>
                                    </select>
                                </div>
                                <div style="flex: 1;" id="matryoshka-channels-group">
                                    <label class="text-muted" style="font-size: 10px;">Channels</label>
                                    <select class="form-select" id="matryoshka-channels" style="font-size: 12px; padding: 6px;">
                                        <option value="RGB" selected>RGB (recommended)</option>
                                        <option value="R">R only</option>
                                        <option value="G">G only</option>
                                        <option value="B">B only</option>
                                        <option value="RGBA">RGBA (may cause issues)</option>
                                    </select>
                                </div>
                                <div style="flex: 1;" id="matryoshka-bits-group">
                                    <label class="text-muted" style="font-size: 10px;">Bits/Channel</label>
                                    <select class="form-select" id="matryoshka-bits" style="font-size: 12px; padding: 6px;">
                                        <option value="1">1 bit</option>
                                        <option value="2" selected>2 bits</option>
                                        <option value="4">4 bits</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: Payload -->
                    <div class="matryoshka-encode-payload">
                        <div class="form-group">
                            <label class="form-label text-pink">Payload (Innermost Secret)</label>
                            <div class="btn-group mb-2">
                                <button class="btn btn-sm" id="m-payload-text-btn" onclick="setMatryoshkaPayloadMode('text')">Text</button>
                                <button class="btn btn-sm btn-secondary" id="m-payload-file-btn" onclick="setMatryoshkaPayloadMode('file')">File</button>
                            </div>
                        </div>

                        <div id="m-payload-text-mode">
                            <textarea class="form-textarea" id="matryoshka-text" placeholder="Enter secret message..." style="height: 100px;"></textarea>
                        </div>

                        <div id="m-payload-file-mode" class="hidden">
                            <div class="drop-zone drop-zone-sm" id="matryoshka-file-drop">
                                <input type="file" id="matryoshka-file-input">
                                <div class="drop-zone-text">Drop secret file</div>
                            </div>
                            <div id="matryoshka-file-info" class="text-muted mt-1"></div>
                        </div>
                    </div>
                </div>

                <button class="btn btn-pink btn-lg w-full mt-4" onclick="doMatryoshkaEncode()">
                    ü™Ü ENCODE NESTED STEGG
                </button>
            </div>

            <!-- ========== DECODE SECTION (BOTTOM) ========== -->
            <div class="card">
                <h2 class="card-title text-pink">üîì Nested Decode</h2>
                <p class="text-muted">Upload a nested image and recursively extract all hidden layers.</p>

                <div class="matryoshka-decode-grid">
                    <div class="matryoshka-decode-input">
                        <div class="form-group">
                            <label class="form-label text-pink">Max Depth</label>
                            <div class="matryoshka-depth-control">
                                <input type="range" id="matryoshka-depth" min="1" max="11" value="3" oninput="updateMatryoshkaDepth(this.value)">
                                <span id="matryoshka-depth-value" class="depth-value">3</span>
                            </div>
                        </div>

                        <div class="drop-zone drop-zone-sm mt-3" id="matryoshka-decode-drop">
                            <input type="file" id="matryoshka-decode-input" accept="image/png,image/jpeg,image/webp,image/gif">
                            <div class="drop-zone-text">Drop nested image</div>
                        </div>
                        <img id="matryoshka-decode-preview" class="image-preview-sm hidden mt-2">

                        <button class="btn btn-pink w-full mt-3" onclick="doMatryoshkaDecode()">
                            ü™Ü DECODE
                        </button>
                    </div>

                    <div class="matryoshka-decode-results">
                        <div id="matryoshka-panel-results" class="hidden">
                            <h3 class="text-pink" style="font-size: 14px;">ü™Ü Extracted Layers</h3>
                            <div id="matryoshka-panel-results-content" class="matryoshka-results"></div>
                        </div>

                        <div id="matryoshka-extracted" class="mt-3 hidden">
                            <h4 class="text-pink" style="font-size: 13px;">üíé Deepest Payload</h4>
                            <div id="matryoshka-extracted-info" class="text-muted"></div>
                            <pre id="matryoshka-extracted-preview" class="mt-2" style="background: #111; padding: 8px; border-radius: 4px; max-height: 120px; overflow: auto; font-size: 10px; color: #0f0;"></pre>
                            <button class="btn btn-pink btn-sm mt-2" onclick="downloadMatryoshkaExtracted()">Download</button>
                        </div>

                        <div id="matryoshka-no-results" class="text-muted" style="text-align: center; padding: 20px;">
                            Results will appear here
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- GODMODE Panel (Hidden Tab) -->
        <section class="panel" id="godmode-panel">
            <div class="godmode-header">
                <h1 class="godmode-main-title">üëÅ GODMODE ENABLED üëÅ</h1>
                <p class="godmode-main-subtitle">Channel Cipher Steganography ‚Ä¢ Virtually Untraceable</p>
            </div>

            <div class="grid">
                <!-- Left: Cipher Configuration -->
                <div class="card">
                    <h2 class="card-title text-red">üîê Channel Cipher</h2>
                    <p class="text-muted">Data hops between channels using your secret pattern as the key.</p>

                    <div class="form-group mt-3">
                        <label class="form-label text-red">Cipher Mode</label>
                        <div class="btn-group">
                            <button class="btn btn-sm" id="cipher-manual-btn" onclick="setCipherMode('manual')">Manual Pattern</button>
                            <button class="btn btn-sm btn-secondary" id="cipher-password-btn" onclick="setCipherMode('password')">Password Seed</button>
                        </div>
                    </div>

                    <div id="cipher-manual-mode" class="mt-3">
                        <label class="form-label text-red">Channel Pattern</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" class="cipher-pattern-input" id="cipher-pattern"
                                   placeholder="R1-G2-B1-RGB2-RG1"
                                   oninput="updateCipherPreview()" style="flex: 1;">
                            <button class="btn btn-red btn-sm" onclick="generateRandomPattern()" title="Generate random pattern">üé≤</button>
                        </div>
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                            Format: CHANNEL+BITS (R1, G2, B1, RGB2, RGBA1, etc.) separated by dashes
                        </div>
                        <div class="cipher-preview" id="cipher-preview">
                            Pattern preview will appear here...
                        </div>
                    </div>

                    <div id="cipher-password-mode" class="mt-3 hidden">
                        <label class="form-label text-red">Cipher Password</label>
                        <input type="password" class="cipher-pattern-input" id="cipher-password"
                               placeholder="Enter secret password..."
                               oninput="updateCipherPreview()">
                        <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                            Password generates a deterministic channel-hopping sequence
                        </div>
                        <div class="cipher-preview" id="cipher-password-preview">
                            Generated pattern will appear here...
                        </div>
                    </div>

                    <div class="form-group mt-4">
                        <label class="form-label text-red">Embedding Mode</label>
                        <div class="btn-group">
                            <button class="btn btn-sm" id="godmode-lsb-btn" onclick="setGodmodeEmbedMode('lsb')">LSB (Pixel)</button>
                            <button class="btn btn-sm btn-secondary" id="godmode-dct-btn" onclick="setGodmodeEmbedMode('dct')">DCT (Survives JPEG)</button>
                        </div>
                        <div id="godmode-embed-info" class="text-muted" style="font-size: 10px; margin-top: 4px;">
                            LSB: Higher capacity, fragile to compression
                        </div>
                    </div>

                    <div class="form-group mt-3">
                        <label class="form-label text-red">üëª Ghost Mode</label>
                        <div class="mt-2" style="background: rgba(100,100,100,0.2); padding: 10px; border-radius: 6px; border: 1px solid #666;">
                            <label class="checkbox-label">
                                <input type="checkbox" id="godmode-ghost">
                                <span style="color: #aaa; font-weight: bold;">ENABLE GHOST MODE</span>
                            </label>
                            <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                                AES-256-GCM + Bit Scrambling + 50% Noise Decoys<br>
                                ‚ö†Ô∏è Requires password mode ‚Ä¢ Halves capacity
                            </div>
                        </div>
                    </div>

                    <div class="form-group mt-3">
                        <label class="form-label text-red">Stealth Options</label>
                        <div class="mt-2">
                            <label class="checkbox-label">
                                <input type="checkbox" id="godmode-encrypt" checked>
                                <span class="text-red">Basic encryption</span>
                            </label>
                            <div class="text-muted" style="font-size: 10px;">XOR cipher (fast, basic obfuscation)</div>
                        </div>
                        <div class="mt-2">
                            <label class="checkbox-label">
                                <input type="checkbox" id="godmode-balance" checked>
                                <span class="text-red">Statistical balancing</span>
                            </label>
                            <div class="text-muted" style="font-size: 10px;">¬±1 modifications to preserve histogram</div>
                        </div>
                    </div>

                    <div class="form-group mt-3">
                        <label class="form-label text-red">Density</label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="range" id="godmode-density" min="1" max="100" value="50"
                                   oninput="document.getElementById('godmode-density-value').textContent = this.value + '%'"
                                   style="flex: 1;">
                            <span id="godmode-density-value" style="color: #ff3333; min-width: 40px;">50%</span>
                        </div>
                        <div class="text-muted" style="font-size: 10px;">Lower = more sparse, harder to detect</div>
                    </div>
                </div>

                <!-- Right: Carrier & Payload -->
                <div class="card">
                    <h2 class="card-title text-red">ü™Ü Payload</h2>

                    <div class="form-group">
                        <label class="form-label text-red">Carrier Image</label>
                        <div class="drop-zone drop-zone-sm" id="godmode-carrier-drop">
                            <input type="file" id="godmode-carrier-input" accept="image/png,image/jpeg,image/webp,image/gif">
                            <div class="drop-zone-text">Drop carrier image</div>
                        </div>
                        <img id="godmode-carrier-preview" class="image-preview-sm hidden mt-2">
                        <div id="godmode-carrier-info" class="text-muted mt-1"></div>
                    </div>

                    <div class="form-group mt-3">
                        <label class="form-label text-red">Secret Data</label>
                        <div class="btn-group mb-2">
                            <button class="btn btn-sm" id="godmode-text-btn" onclick="setGodmodePayloadMode('text')">Text</button>
                            <button class="btn btn-sm btn-secondary" id="godmode-file-btn" onclick="setGodmodePayloadMode('file')">File</button>
                        </div>

                        <div id="godmode-text-mode">
                            <textarea class="form-textarea" id="godmode-text" placeholder="Enter secret message..." style="height: 80px;"></textarea>
                        </div>

                        <div id="godmode-file-mode" class="hidden">
                            <div class="drop-zone drop-zone-sm" id="godmode-file-drop">
                                <input type="file" id="godmode-file-input">
                                <div class="drop-zone-text">Drop secret file</div>
                            </div>
                            <div id="godmode-file-info" class="text-muted mt-1"></div>
                        </div>
                    </div>

                    <div id="godmode-capacity" class="mt-3" style="font-size: 12px; color: #666;"></div>

                    <button class="btn btn-red btn-lg w-full mt-4" onclick="doGodmodeEncode()">
                        üëÅ ENCODE GODMODE
                    </button>
                </div>
            </div>

            <!-- Decode Section -->
            <div class="card mt-4">
                <h2 class="card-title text-red">üîì Decode GODMODE</h2>
                <p class="text-muted">Provide the same cipher pattern/password to decode.</p>

                <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <div class="form-group">
                            <label class="form-label text-red">Stego Image</label>
                            <div class="drop-zone drop-zone-sm" id="godmode-decode-drop">
                                <input type="file" id="godmode-decode-input" accept="image/png,image/jpeg,image/webp,image/gif">
                                <div class="drop-zone-text">Drop encoded image</div>
                            </div>
                            <img id="godmode-decode-preview" class="image-preview-sm hidden mt-2">
                        </div>
                    </div>
                    <div>
                        <div class="form-group">
                            <label class="form-label text-red">Cipher Key</label>
                            <input type="text" class="cipher-pattern-input" id="cipher-decode-key"
                                   placeholder="Pattern or password...">
                            <div class="text-muted" style="font-size: 10px; margin-top: 4px;">
                                Enter the same pattern or password used for encoding
                            </div>
                        </div>
                        <button class="btn btn-red w-full mt-3" onclick="doGodmodeDecode()">
                            üîì DECODE
                        </button>
                    </div>
                </div>

                <div id="godmode-decode-result" class="mt-3 hidden">
                    <label class="form-label text-red">Decoded Data</label>
                    <pre id="godmode-decode-output" style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 4px; color: var(--primary); max-height: 200px; overflow: auto;"></pre>
                    <button class="btn btn-red btn-sm mt-2" onclick="downloadGodmodeDecoded()">Download</button>
                </div>
            </div>
        </section>

        <!-- Text Lab Panel (Hidden Easter Egg Tab) -->
        <section class="panel" id="textlab-panel">
            <div class="card" style="border-color: #7c3aed55; max-width: 800px; margin: 0 auto;">
                <h2 class="card-title" style="color: #7c3aed; text-align: center;">üî§ Text Steganography Lab</h2>
                <p class="text-muted" style="text-align: center; margin-bottom: 20px; font-size: 11px;">
                    Hide messages in plain text using invisible characters and visual tricks
                </p>

                <!-- Method Selection -->
                <div class="form-group">
                    <label class="form-label" style="color: #7c3aed;">Method</label>
                    <select class="form-select" id="textlab-method" onchange="updateTextLabMethod()" style="border-color: #7c3aed55;">
                        <option value="zerowidth">Zero-Width Unicode (invisible chars)</option>
                        <option value="homoglyph">Homoglyph Substitution (lookalike chars)</option>
                        <option value="whitespace">Whitespace Encoding (spaces/tabs)</option>
                        <option value="invisible">Invisible Ink (Unicode tags)</option>
                    </select>
                </div>

                <!-- Method Descriptions -->
                <div id="textlab-desc-zerowidth" class="textlab-desc" style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px; padding: 8px; background: rgba(124,58,237,0.1); border-radius: 4px;">
                    Embeds secret as invisible zero-width characters between visible letters. Completely invisible in most applications.
                </div>
                <div id="textlab-desc-homoglyph" class="textlab-desc hidden" style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px; padding: 8px; background: rgba(124,58,237,0.1); border-radius: 4px;">
                    Replaces letters with similar-looking Unicode characters (e.g., 'a' ‚Üí '–∞' Cyrillic). Visually identical but different bytes.
                </div>
                <div id="textlab-desc-whitespace" class="textlab-desc hidden" style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px; padding: 8px; background: rgba(124,58,237,0.1); border-radius: 4px;">
                    Encodes data in trailing whitespace at end of lines. Spaces = 0, Tabs = 1. Survives most copy/paste.
                </div>
                <div id="textlab-desc-invisible" class="textlab-desc hidden" style="font-size: 10px; color: var(--text-dim); margin-bottom: 15px; padding: 8px; background: rgba(124,58,237,0.1); border-radius: 4px;">
                    Uses Unicode Tag Characters (U+E0000 range) to embed hidden text. Very obscure, rarely detected.
                </div>

                <div class="form-row" style="margin-top: 15px;">
                    <!-- Secret Message -->
                    <div class="form-group" style="flex: 1;">
                        <label class="form-label">Secret Message</label>
                        <textarea class="form-textarea" id="textlab-secret" placeholder="The message you want to hide..." style="min-height: 80px;"></textarea>
                    </div>
                    <!-- Cover Text -->
                    <div class="form-group" style="flex: 1;">
                        <label class="form-label">Cover Text</label>
                        <textarea class="form-textarea" id="textlab-cover" placeholder="The innocent-looking text that will contain your secret..." style="min-height: 80px;"></textarea>
                    </div>
                </div>

                <!-- Encode Button -->
                <div style="margin-top: 15px;">
                    <button class="btn" style="width: 100%; background: #7c3aed;" onclick="textLabEncode()">Encode ‚Üí</button>
                </div>

                <!-- Encode Output -->
                <div class="form-group" style="margin-top: 15px;">
                    <label class="form-label" style="color: #7c3aed;">Encoded Output</label>
                    <textarea class="form-textarea" id="textlab-output" readonly placeholder="Encoded text will appear here..." style="min-height: 80px; background: #1a1a2e; border-color: #7c3aed;"></textarea>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button class="btn btn-secondary btn-sm" onclick="copyTextLabOutput()">üìã Copy</button>
                        <span id="textlab-stats" class="text-muted" style="font-size: 10px; margin-left: auto; align-self: center;"></span>
                    </div>
                </div>

                <!-- Decode Section -->
                <div style="margin-top: 25px; border-top: 1px solid var(--border); padding-top: 20px;">
                    <h3 style="color: #7c3aed; font-size: 14px; margin-bottom: 15px;">Decode Hidden Message</h3>

                    <div class="form-group">
                        <label class="form-label">Stego Text Input</label>
                        <textarea class="form-textarea" id="textlab-decode-input" placeholder="Paste text with hidden message here..." style="min-height: 80px;"></textarea>
                    </div>

                    <div style="margin-top: 10px;">
                        <button class="btn btn-secondary" style="width: 100%;" onclick="textLabDecode()">‚Üê Decode</button>
                    </div>

                    <div class="form-group" style="margin-top: 15px;">
                        <label class="form-label" style="color: #7c3aed;">Decoded Message</label>
                        <textarea class="form-textarea" id="textlab-decode-output" readonly placeholder="Hidden message will appear here..." style="min-height: 60px; background: #1a1a2e; border-color: #7c3aed;"></textarea>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="btn btn-secondary btn-sm" onclick="copyTextLabDecodeOutput()">üìã Copy</button>
                            <button class="btn btn-secondary btn-sm" onclick="clearTextLab()">Clear All</button>
                            <span id="textlab-decode-stats" class="text-muted" style="font-size: 10px; margin-left: auto; align-self: center;"></span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer">
            <div class="hatch-animation" id="hatch-animation"></div>
            <div>.-.-.-.-<={LOVE PLINY}=>-.-.-.-.</div>
        </footer>
    </div>

    <!-- Matryoshka Easter Egg Trigger -->
    <div class="matryoshka-trigger" id="matryoshka-trigger"></div>

    <!-- Matryoshka Mode Indicator (shown when active) -->
    <div class="matryoshka-indicator hidden" id="matryoshka-indicator" onclick="deactivateMatryoshka()">
        <span class="indicator-text">ü™Ü NESTED STEGG MODE</span>
        <span class="indicator-hint">click to deactivate</span>
    </div>

    <!-- GODMODE Indicator (shown when active) -->
    <div class="godmode-indicator hidden" id="godmode-indicator" onclick="deactivateGodmode()">
        <span class="indicator-text">üëÅ GODMODE ACTIVE</span>
        <span class="indicator-hint">click to deactivate</span>
    </div>

    <!-- Hidden canvas for image processing -->
    <canvas id="work-canvas" style="display: none;"></canvas>

    <!-- F5 Steganography Library (inlined) -->
    <script>
/*	This software is licensed under the MIT License.

	Copyright (c) 2016 desudesutalk

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	the Software, and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	https://github.com/desudesutalk/f5stegojs

	This library is based on https://github.com/owencm/js-steg by Owen Campbell-
	Moore. Decoder and encoder was optimized for speed, F5 algorithm and metadata
	manipulation utils was added to library.

	Original code was released under MIT and Apache licenses, so here follows
	original licenses of Owen code:

	jpeg decoder license:

	Modified JPEG decoder for Steganography by Owen Campbell-Moore, based on one
	released by Adobe.

	Copyright 2011 notmasteryet

	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at

	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed
	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	specific language governing permissions and limitations under the License.


	jpeg encoder license:

	JPEG encoder ported to JavaScript, optimized by Andreas Ritter
	(www.bytestrom.eu, 11/2009) and made suitable for steganography by Owen
	Campbell-Moore (www.owencampbellmoore.com, 03/13)

	Based on v 0.9a

	Licensed under the MIT License

	Copyright (c) 2009 Andreas Ritter

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	the Software, and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	Copyright (c) 2008, Adobe Systems Incorporated All rights reserved.

	Redistribution and use in source and binary forms, with or without modification,
	are permitted provided that the following conditions are met:

	Redistributions of source code must retain the above copyright notice, this list
	of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright notice, this
	list of conditions and the following disclaimer in the documentation and/or
	other materials provided with the distribution.

	Neither the name of Adobe Systems Incorporated nor the names of its contributors
	may be used to endorse or promote products derived from this software without
	specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

/* global define, module, exports */
/* jshint sub:true */
;(function(root, factory) {
	'use strict';
	if (typeof define === 'function' && define.amd) {
		define([], factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		root.f5stego = factory();
	}
}(typeof window !== 'undefined' ? window : this, function() {
	'use strict';

	var f5stego = function(key, maxPixels) {
		this.maxPixels = maxPixels || 4096 * 4096;
		this.shuffleInit(key);
	};

	// Shuffle used in f5 algo
	// ===========================================================================================================
		f5stego.prototype.shuffleInit = function(key) {
			this.randPool = new ArrayBuffer(this.maxPixels * 4.125);

			if (!key.length) throw 'key needed';

			var i = 0,
				j = 0,
				t = 0,
				k = 0,
				S = new Uint8Array(256),
				rnd = new Uint8Array(this.randPool);

			// init state from key
			for (i = 0; i < 256; ++i) S[i] = i;

			for (i = 0; i < 256; ++i) {
				j = (j + S[i] + key[i % key.length]) & 255;
				t = S[i];
				S[i] = S[j];
				S[j] = t;
			}
			i = 0;
			j = 0;

			// shuffle data
			for (k = 0; k < this.maxPixels * 4.125; ++k) {
				i = (i + 1) & 255;
				j = (j + S[i]) & 255;
				t = S[i];
				S[i] = S[j];
				S[j] = t;
				rnd[k] = S[(t + S[i]) & 255];
			}
		};

		f5stego.prototype.stegShuffle = function(pm) {
			var t, l, k, random_index,
				rand32Array = new Uint32Array(this.randPool);

			if (typeof pm == 'number') {
				l = pm;
				pm = new Uint32Array(l);
				for (k = 1; k < l; k++) {
					random_index = rand32Array[k] % (k + 1);
					if (random_index != k) pm[k] = pm[random_index];
					pm[random_index] = k;
				}
			} else {
				l = pm.length;
				for (k = 1; k < l; k++) {
					random_index = rand32Array[k] % (k + 1);
					// if (random_index != k) {
						t = pm[k];
						pm[k] = pm[random_index];
						pm[random_index] = t;
					// }
				}
			}
			return { pm: pm, gamma: new Uint8Array(this.randPool, l * 4) };
		};

	// Internal f5 algo functions
	// ===========================================================================================================
		f5stego.prototype._analyze = function(coeff) {
			var _one = 0,
				_zero = 0,
				_large, _ratio, usable, i, k, embedded, matched, changed;

			for (i = 0; i < coeff.length; i++) {
				if (i % 64 === 0) continue;
				if (coeff[i] === 0) _zero++;
				if (coeff[i] == 1 || coeff[i] == -1) _one++;
			}

			_large = coeff.length - _zero - _one - coeff.length / 64;
			_ratio = _one / (_large + _one);

			var res = {
				'capacity': [0, ((_large + (0.49 * _one)) >> 3) - 1],
				'coeff_total': coeff.length,
				'coeff_large': _large,
				'coeff_zero': _zero,
				'coeff_one': _one,
				'coeff_one_ratio': _one / (_large + _one)
			};

			for (i = 2; i < 17; i++) {
				k = (1 << i) - 1;
				usable = _large + _one;
				embedded = 0;
				while (usable > k) {
					matched = (usable / k / (1 << i) / (1 << i)) | 0;
					usable -= matched * k;

					changed = (usable * (1 - _ratio) / k * 0.96) | 0;
					usable -= changed * k;
					embedded += changed + matched;

					k++;
				}
				res.capacity[i] = ((i * embedded) >> 3) - 1;
			}

			return res;
		};

		f5stego.prototype._f5write = function(coeff, data, k) {
			var coeff_count = coeff.length;

			var _changed = 0,
				_embedded = 0,
				_examined = 0,
				_thrown = 0,
				shuffled_index = 0,
				i, n, ii;

			var pm = this.stegShuffle(coeff_count);
			var gamma = pm.gamma,
				gammaI = 0;
			pm = pm.pm;

			var next_bit_to_embed = 0,
				byte_to_embed = data.length,
				data_idx = 0,
				available_bits_to_embed = 0;

			n = (1 << k) - 1;

			byte_to_embed = k - 1;
			byte_to_embed ^= gamma[gammaI++];
			next_bit_to_embed = byte_to_embed & 1;
			byte_to_embed >>= 1;
			available_bits_to_embed = 3;

			for (ii = 0; ii < coeff_count; ii++) {
				shuffled_index = pm[ii];

				if (shuffled_index % 64 === 0 || coeff[shuffled_index] === 0) continue;

				var cc = coeff[shuffled_index];
				_examined++;

				if (cc > 0 && (cc & 1) != next_bit_to_embed) {
					coeff[shuffled_index]--;
					_changed++;
				} else if (cc < 0 && (cc & 1) == next_bit_to_embed) {
					coeff[shuffled_index]++;
					_changed++;
				}

				if (coeff[shuffled_index] !== 0) {
					_embedded++;
					if (available_bits_to_embed === 0) {
						if (k != 1 || data_idx >= data.length) break;
						byte_to_embed = data[data_idx++];
						byte_to_embed ^= gamma[gammaI++];
						available_bits_to_embed = 8;
					}
					next_bit_to_embed = byte_to_embed & 1;
					byte_to_embed >>= 1;
					available_bits_to_embed--;
				} else {
					_thrown++;
				}
			}

			if (k == 1 && _embedded < data.length * 8) throw 'capacity exceeded ' + (_embedded / 8) + ' ' + data.length;

			if (k != 1) {
				//ii--;
				var is_last_byte = false,
					k_bits_to_embed = 0;

				while (!is_last_byte || (available_bits_to_embed !== 0 && is_last_byte)) {
					k_bits_to_embed = 0;

					for (i = 0; i < k; i++) {
						if (available_bits_to_embed === 0) {
							if (data_idx >= data.length) {
								is_last_byte = true;
								break;
							}
							byte_to_embed = data[data_idx++];
							byte_to_embed ^= gamma[gammaI++];
							available_bits_to_embed = 8;
						}
						next_bit_to_embed = byte_to_embed & 1;
						byte_to_embed >>= 1;
						available_bits_to_embed--;
						k_bits_to_embed |= next_bit_to_embed << i;

					}

					var code_word = [];
					var ci = null;

					for (i = 0; i < n; i++) {
						while (true) {
							if (++ii >= coeff_count) {
								throw 'capacity exceeded ' + (_embedded / 8);
							}
							ci = pm[ii];

							if (ci % 64 !== 0 && coeff[ci] !== 0) break;
						}
						code_word.push(ci);
					}
					_examined += n;

					while (true) {
						var vhash = 0,
							extracted_bit;

						for (i = 0; i < code_word.length; i++) {
							if (coeff[code_word[i]] > 0) {
								extracted_bit = coeff[code_word[i]] & 1;
							} else {
								extracted_bit = 1 - (coeff[code_word[i]] & 1);
							}

							if (extracted_bit == 1)
								vhash ^= i + 1;
						}

						i = vhash ^ k_bits_to_embed;
						if (!i) {
							_embedded += k;
							break;
						}

						i--;
						coeff[code_word[i]] += coeff[code_word[i]] < 0 ? 1 : -1;
						_changed++;

						if (coeff[code_word[i]] === 0) {
							_thrown++;
							code_word.splice(i, 1);

							while (true) {
								if (++ii >= coeff_count) {
									throw 'capacity exceeded ' + (_embedded / 8);
								}
								ci = pm[ii];
								if (ci % 64 !== 0 && coeff[ci] !== 0) break;

							}
							_examined++;
							code_word.push(ci);
						} else {
							_embedded += k;
							break;
						}
					}
				}
			}

			return {
				'k': k,
				'embedded': _embedded / 8,
				'examined': _examined,
				'changed': _changed,
				'thrown': _thrown,
				'efficiency': (_embedded / _changed).toFixed(2)
			};
		};

	// Public f5 algo functions
	// ===========================================================================================================
		f5stego.prototype.analyze = function() {
			var i, comp = this.frame.components[0];

			if (comp.componentId != 1) {
				for (i = 0; i < this.frame.components.length; i++) {
					if (this.frame.components[i].componentId == 1) {
						comp = this.frame.components[i];
						break;
					}
				}
			}

			return this._analyze(comp.blocks);
		};

		f5stego.prototype.f5put = function(data, k) {
			var t, i, comp = this.frame.components[0];

			// Looks funny, but who knows?
			// From the other hand you need ~80MB jpeg to hide 8MB of data and this will be bigger than 4096x4096 pixels
			if (data.length > 8388607) throw 'Data too big. Max 8388607 bytes allowed.';

			if (data.length < 32768) {
				t = new Uint8Array(2 + data.length);
				t[0] = data.length & 255;
				t[1] = data.length >>> 8;
				t.set(data, 2);
			} else {
				t = new Uint8Array(3 + data.length);
				t[0] = data.length & 255;
				t[1] = ((data.length >>> 8) & 127) + 128;
				t[2] = data.length >>> 15;
				t.set(data, 3);
			}

			if (comp.componentId != 1) {
				for (i = 0; i < this.frame.components.length; i++) {
					if (this.frame.components[i].componentId == 1) {
						comp = this.frame.components[i];
						break;
					}
				}
			}

			if (k) {
				return this._f5write(comp.blocks, t, k);
			}

			var ret, prop = this._analyze(comp.blocks);

			k = 0;

			for (i = prop.capacity.length - 1; i >= 0; i--) {
				if (prop.capacity[i] >= t.length) {
					k = i;
					break;
				}
			}

			if (k === 0) throw 'capacity exceeded';

			try {
				ret = this._f5write(comp.blocks, t, k);
			} catch (e) {
				k--;
				if (k === 0) throw 'capacity exceeded';
				ret = this._f5write(comp.blocks, t, k);
			}

			ret['stats'] = prop;

			return ret;
		};

		f5stego.prototype.f5get = function() {
			var comp = this.frame.components[0];

			if (comp.componentId != 1) {
				for (var i = 0; i < this.frame.components.length; i++) {
					if (this.frame.components[i].componentId == 1) {
						comp = this.frame.components[i];
						break;
					}
				}
			}

			var coeff = new Int16Array(comp.blocks.length);
			coeff.set(comp.blocks);

			var pos = -1,
				extrBit = 0,
				cCount = coeff.length - 1;

			var pm = this.stegShuffle(coeff),
				gamma = pm.gamma,
				gammaI = 0;

			var n, k = 0;

			var out = new Uint8Array((coeff.length / 8) | 0),
				extrByte = 0,
				outPos = 0,
				bitsAvail = 0,
				code = 0,
				hash = 0;

			while (bitsAvail < 4) {
				pos++;

				if (coeff[pos] === 0) {
					continue;
				}

				extrBit = coeff[pos] & 1;


				if (coeff[pos] < 0) {
					extrBit = 1 - extrBit;
				}

				k |= extrBit << bitsAvail;
				bitsAvail++;
			}

			k = (k ^ gamma[gammaI++] & 15) + 1;
			n = (1 << k) - 1;

			bitsAvail = 0;

			if (k == 1) {
				while (pos < cCount) {
					pos++;

					if (coeff[pos] === 0) {
						continue;
					}

					extrBit = coeff[pos] & 1;

					if (coeff[pos] < 0) {
						extrBit = 1 - extrBit;
					}

					extrByte |= extrBit << bitsAvail;
					bitsAvail++;

					if (bitsAvail == 8) {
						out[outPos++] = extrByte ^ gamma[gammaI++];
						extrByte = 0;
						bitsAvail = 0;
					}
				}
			} else {
				while (pos < cCount) {
					pos++;

					if (coeff[pos] === 0) {
						continue;
					}

					extrBit = coeff[pos] & 1;

					if (coeff[pos] < 0) {
						extrBit = 1 - extrBit;
					}

					hash ^= extrBit * ++code;

					if (code == n) {
						extrByte |= hash << bitsAvail;
						bitsAvail += k;
						code = 0;
						hash = 0;

						while (bitsAvail >= 8) {
							out[outPos++] = (extrByte & 0xFF) ^ gamma[gammaI++];
							bitsAvail -= 8;
							extrByte = extrByte >> 8;
						}
					}
				}
			}

			while (bitsAvail > 0) {
				out[outPos++] = (extrByte & 0xFF) ^ gamma[gammaI++];
				bitsAvail -= 8;
				extrByte = extrByte >> 8;
			}

			var s = 2,
				l = out[0];

			if (out[1] & 128) {
				s++;
				l += ((out[1] & 127) << 8) + (out[2] << 15);
			} else {
				l += out[1] << 8;
			}

			return out.subarray(s, s + l);
		};

	// JPEG decoder
	// ===========================================================================================================
		f5stego.prototype.parse = function(data) {
			var offset = 0;

			function _buildHuffmanTable(nrcodes, values) {
				var codevalue = 0,
					pos_in_table = 0,
					HT = new Uint16Array(65536);
				for (var k = 0; k < 16; k++) {
					for (var j = 0; j < nrcodes[k]; j++) {
						for (var i = codevalue << (15 - k), cntTo = ((codevalue + 1) << (15 - k)); i < cntTo; i++) {
							HT[i] = values[pos_in_table] + ((k + 1) << 8);
						}
						pos_in_table++;
						codevalue++;
					}
					codevalue *= 2;
				}
				return HT;
			}

			function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {

				var startOffset = offset,
					bitsData = 0,
					bitsCount = 0,
					eobrun = 0,
					p1 = 1 << successive,  /*  1 in the bit position being coded */
					m1 = -1 << successive; /* -1 in the bit position being coded */

				function decodeBaseline(component, pos) {
					while (bitsCount < 16) {
						bitsData = (bitsData << 8) + (data[offset] | 0);
						bitsCount += 8;
						if (data[offset] == 0xFF) offset++;
						offset++;
					}
					var t = component.huffmanTableDC[(bitsData >>> (bitsCount - 16)) & 0xFFFF];
					if (!t) throw "invalid huffman sequence";
					bitsCount -= t >>> 8;
					t &= 255;

					var diff = 0;
					if (t !== 0) {
						while (bitsCount < t) {
							bitsData = (bitsData << 8) + data[offset++];
							if ((bitsData & 0xff) == 0xFF) offset++;
							bitsCount += 8;
						}
						diff = (bitsData >>> (bitsCount - t)) & ((1 << t) - 1);
						bitsCount -= t;
						if (diff < 1 << (t - 1)) diff += (-1 << t) + 1;
					}
					component.blocksDC[pos >> 6] = (component.pred += diff);

					var k = 1,
						s, r;
					while (k < 64) {

						while (bitsCount < 16) {
							bitsData = (bitsData << 8) + (data[offset] | 0);
							bitsCount += 8;
							if (data[offset] == 0xFF) offset++;
							offset++;
						}
						s = component.huffmanTableAC[(bitsData >>> (bitsCount - 16)) & 0xFFFF];
						if (!s) throw "invalid huffman sequence";
						bitsCount -= s >>> 8;
						r = (s >> 4) & 15;
						s &= 15;

						if (s === 0) {
							if (r < 15) {
								break;
							}
							k += 16;
							continue;
						}
						k += r;
						while (bitsCount < s) {
							bitsData = (bitsData << 8) + data[offset++];
							if ((bitsData & 0xff) == 0xFF) offset++;
							bitsCount += 8;
						}
						component.blocks[pos + k] = (bitsData >>> (bitsCount - s)) & ((1 << s) - 1);
						bitsCount -= s;
						if (component.blocks[pos + k] < 1 << (s - 1)) component.blocks[pos + k] += (-1 << s) + 1;
						k++;
					}
				}

				function decodeDCFirst(component, pos) {
					var diff = 0;
					while (bitsCount < 16) {
						bitsData = (bitsData << 8) + (data[offset] | 0);
						bitsCount += 8;
						if (data[offset] == 0xFF) offset++;
						offset++;
					}
					var t = component.huffmanTableDC[(bitsData >>> (bitsCount - 16)) & 0xFFFF];
					if (!t) throw "invalid huffman sequence";
					bitsCount -= t >>> 8;
					t &= 255;

					if (t !== 0) {
						while (bitsCount < t) {
							bitsData = (bitsData << 8) + data[offset++];
							if ((bitsData & 0xff) == 0xFF) offset++;
							bitsCount += 8;
						}
						diff = (bitsData >>> (bitsCount - t)) & ((1 << t) - 1);
						bitsCount -= t;
						if (diff < 1 << (t - 1)) diff += (-1 << t) + 1;
					}
					component.blocksDC[pos >> 6] = (component.pred += diff << successive);
				}

				function decodeDCSuccessive(component, pos) {
					if (!bitsCount) {
						bitsData = data[offset++];
						if (bitsData == 0xFF) offset++;
						bitsCount = 8;
					}
					component.blocksDC[pos >> 6] |= ((bitsData >>> --bitsCount) & 1) << successive;
				}

				function decodeACFirst(component, pos) {
					if (eobrun > 0) {
						eobrun--;
						return;
					}

					var k = spectralStart,
						s, r;

					while (k <= spectralEnd) {
						while (bitsCount < 16) {
							bitsData = (bitsData << 8) + (data[offset] | 0);
							bitsCount += 8;
							if (data[offset] == 0xFF) offset++;
							offset++;
						}
						s = component.huffmanTableAC[(bitsData >>> (bitsCount - 16)) & 0xFFFF];
						if (!s) throw "invalid huffman sequence";
						bitsCount -= s >>> 8;
						r = (s >> 4) & 15;
						s &= 15;

						if (s === 0) {
							if (r != 15) {
								eobrun = (1 << r) - 1;
								if (r) {
									while (bitsCount < r) {
										bitsData = (bitsData << 8) + data[offset++];
										if ((bitsData & 0xff) == 0xFF) offset++;
										bitsCount += 8;
									}
									eobrun += (bitsData >>> (bitsCount - r)) & ((1 << r) - 1);
									bitsCount -= r;
								}
								break;
							}
							k += 16;
							continue;
						}

						k += r;
						while (bitsCount < s) {
							bitsData = (bitsData << 8) + data[offset++];
							if ((bitsData & 0xff) == 0xFF) offset++;
							bitsCount += 8;
						}
						component.blocks[pos + k] = (bitsData >>> (bitsCount - s)) & ((1 << s) - 1);
						bitsCount -= s;
						if (component.blocks[pos + k] < 1 << (s - 1)) component.blocks[pos + k] += (-1 << s) + 1;
						component.blocks[pos + k] *= p1;
						k++;
					}
				}

				function decodeACSuccessive(component, pos) {
					var k = spectralStart,
						r, s;

					if (!eobrun) {
						while (k <= spectralEnd) {
							while (bitsCount < 16) {
								bitsData = (bitsData << 8) + (data[offset] | 0);
								bitsCount += 8;
								if (data[offset] == 0xFF) offset++;
								offset++;
							}
							s = component.huffmanTableAC[(bitsData >>> (bitsCount - 16)) & 0xFFFF];
							if (!s) throw "invalid huffman sequence";
							bitsCount -= s >>> 8;
							r = (s >> 4) & 15;
							s &= 15;

							if (s) {
								if (s != 1) throw "bad jpeg";
								if (!bitsCount) {
									bitsData = data[offset++];
									if (bitsData == 0xFF) offset++;
									bitsCount = 8;
								}
								s = ((bitsData >>> --bitsCount) & 1) ? p1 : m1;
							} else {
								if (r != 15) {
									eobrun = (1 << r);
									if (r) {
										while (bitsCount < r) {
											bitsData = (bitsData << 8) + data[offset++];
											if ((bitsData & 0xff) == 0xFF) offset++;
											bitsCount += 8;
										}
										eobrun += (bitsData >>> (bitsCount - r)) & ((1 << r) - 1);
										bitsCount -= r;
									}
									break;
								}
							}

							while (k <= spectralEnd) {
								if (component.blocks[pos + k]) {
									if (!bitsCount) {
										bitsData = data[offset++];
										if (bitsData == 0xFF) offset++;
										bitsCount = 8;
									}
									component.blocks[pos + k] += ((bitsData >>> --bitsCount) & 1) * (component.blocks[pos + k] >= 0 ? p1 : m1);
								} else {
									if (--r < 0) break;
								}
								k++;
							}

							if (s) component.blocks[pos + k] = s;
							k++;
						}
					}

					if (eobrun) {
						while (k <= spectralEnd) {
							if (component.blocks[pos + k]) {
								if (!bitsCount) {
									bitsData = data[offset++];
									if (bitsData == 0xFF) offset++;
									bitsCount = 8;
								}
								component.blocks[pos + k] += ((bitsData >>> --bitsCount) & 1) * (component.blocks[pos + k] >= 0 ? p1 : m1);
							}
							k++;
						}
						eobrun--;
					}
				}

				var decodeFn;

				if (frame.progressive) {
					if (spectralStart === 0)
						decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
					else
						decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
				} else {
					decodeFn = decodeBaseline;
				}

				var marker, mcuExpected, i, j, k, n, mcusPerLine, mcusPerRow, x, y;

				if (components.length == 1) {
					mcusPerLine = components[0].blocksPerLine;
					mcusPerRow = components[0].blocksPerColumn;
					mcuExpected = mcusPerRow * mcusPerLine;

					if (!resetInterval) resetInterval = mcuExpected;
					n = resetInterval;
					components[0].pred = 0;
					eobrun = 0;

					for (y = 0; y < mcusPerRow; y++) {
						for (x = 0; x < mcusPerLine; x++) {
							if (!n) {
								n = resetInterval;
								components[0].pred = 0;
								eobrun = 0;

								// find marker
								offset -= (bitsCount / 8) | 0;
								if (data[offset - 1] == 0xFF) offset--;
								bitsCount = 0;
								marker = (data[offset] << 8) | data[offset + 1];

								if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
									offset += 2;
								} else {
									if (marker <= 0xFF00) {
										throw "bad jpeg";
									}
									break;
								}
							}
							n--;
							for (i = 0; i < components.length; i++) {
								decodeFn(components[i], (y * components[i].blocksPerLineForMcu + x) * 64);
							}

						}
					}
				} else {
					mcusPerLine = frame.mcusPerLine;
					mcusPerRow = frame.mcusPerColumn;
					mcuExpected = mcusPerRow * mcusPerLine;

					if (!resetInterval) resetInterval = mcuExpected;
					n = resetInterval;
					for (i = 0; i < components.length; i++) components[i].pred = 0;
					eobrun = 0;

					for (y = 0; y < mcusPerRow; y++) {
						for (x = 0; x < mcusPerLine; x++) {
							if (!n) {
								n = resetInterval;
								for (i = 0; i < components.length; i++) components[i].pred = 0;
								eobrun = 0;

								// find marker
								offset -= (bitsCount / 8) | 0;
								if (data[offset - 1] == 0xFF) offset--;
								bitsCount = 0;
								marker = (data[offset] << 8) | data[offset + 1];

								if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
									offset += 2;
								} else {
									if (marker <= 0xFF00) {
										throw "bad jpeg";
									}
									break;
								}
							}
							n--;
							for (i = 0; i < components.length; i++) {
								for (j = 0; j < components[i].v; j++) {
									for (k = 0; k < components[i].h; k++) {
										decodeFn(components[i], ((y * components[i].v + j) * components[i].blocksPerLineForMcu + x * components[i].h + k) * 64);
									}
								}
							}
						}
					}
				}
				offset -= (bitsCount / 8) | 0;
				if (data[offset - 1] == 0xFF) offset--;
				return offset - startOffset;
			}

			function readUint16() {
				var value = (data[offset] << 8) | data[offset + 1];
				offset += 2;
				return value;
			}

			function readDataBlock() {
				var length = readUint16();
				var array = data.subarray(offset, offset + length - 2);
				offset += array.length;
				return array;
			}

			this['_raw'] = data;
			this['jfif'] = null;
			this['APPn'] = [];
			this['qts'] = [];
			this['frame'] = null;
			this['tail'] = null;

			var markerHi, markerLo, i, j, resetInterval, component;
			var huffmanTablesAC = [],
				huffmanTablesDC = [];

			while (1) {
				if (offset >= data.length) throw "unexpected EOF";

				markerHi = data[offset++];
				markerLo = data[offset++];

				if (markerHi == 0xFF) {
					if (markerLo == 0xE0) { //APP0 - JFIF header
						this.jfif = readDataBlock();
					}

					if ((markerLo > 0xE0 && markerLo < 0xF0) || markerLo == 0xFE) { //APPn + COM
						this.APPn.push({
							'app': markerLo,
							'data': readDataBlock()
						});
					}

					if (markerLo == 0xDB) { // DQT (Define Quantization Tables)
						this.qts.push(readDataBlock());
					}

					if (markerLo >= 0xC0 && markerLo <= 0xC2) {
						// SOF0 (Start of Frame, Baseline DCT)
						// SOF1 (Start of Frame, Extended DCT)
						// SOF2 (Start of Frame, Progressive DCT)
						if (this.frame) throw "Only single frame JPEGs supported";
						readUint16(); // skip data length

						this.frame = {
							'extended': (markerLo === 0xC1),
							'progressive': (markerLo === 0xC2),
							'precision': data[offset++],
							'scanLines': readUint16(),
							'samplesPerLine': readUint16(),
							'components': [],
							'componentIds': {},
							'maxH': 1,
							'maxV': 1
						};

						if (this.frame.scanLines * this.frame.samplesPerLine > this.maxPixels) throw "Image is too big.";

						var componentsCount = data[offset++],
							componentId;
						var maxH = 0,
							maxV = 0;
						for (i = 0; i < componentsCount; i++) {
							componentId = data[offset];
							var h = data[offset + 1] >> 4;
							var v = data[offset + 1] & 15;
							if (maxH < h) maxH = h;
							if (maxV < v) maxV = v;
							var qId = data[offset + 2];
							var l = this.frame.components.push({
								'componentId': componentId,
								'h': h,
								'v': v,
								'quantizationTable': qId
							});
							this.frame.componentIds[componentId] = l - 1;
							offset += 3;
						}
						this.frame.maxH = maxH;
						this.frame.maxV = maxV;

						var mcusPerLine = Math.ceil(this.frame.samplesPerLine / 8 / maxH);
						var mcusPerColumn = Math.ceil(this.frame.scanLines / 8 / maxV);
						for (i = 0; i < this.frame.components.length; i++) {
							component = this.frame.components[i];
							var blocksPerLine = Math.ceil(Math.ceil(this.frame.samplesPerLine / 8) * component.h / maxH);
							var blocksPerColumn = Math.ceil(Math.ceil(this.frame.scanLines / 8) * component.v / maxV);
							var blocksPerLineForMcu = mcusPerLine * component.h;
							var blocksPerColumnForMcu = mcusPerColumn * component.v;

							component['blocks'] = new Int16Array(blocksPerColumnForMcu * blocksPerLineForMcu * 64);
							component['blocksDC'] = new Int16Array(blocksPerColumnForMcu * blocksPerLineForMcu);
							component['blocksPerLine'] = blocksPerLine;
							component['blocksPerColumn'] = blocksPerColumn;
							component['blocksPerLineForMcu'] = blocksPerLineForMcu;
							component['blocksPerColumnForMcu'] = blocksPerColumnForMcu;
						}
						this.frame['mcusPerLine'] = mcusPerLine;
						this.frame['mcusPerColumn'] = mcusPerColumn;
					}

					if (markerLo == 0xC4) { // DHT (Define Huffman Tables)
						var huffmanLength = readUint16();
						for (i = 2; i < huffmanLength;) {
							var huffmanTableSpec = data[offset++];
							var codeLengths = new Uint8Array(16);
							var codeLengthSum = 0;
							for (j = 0; j < 16; j++, offset++)
								codeLengthSum += (codeLengths[j] = data[offset]);
							var huffmanValues = new Uint8Array(codeLengthSum);
							for (j = 0; j < codeLengthSum; j++, offset++)
								huffmanValues[j] = data[offset];
							i += 17 + codeLengthSum;
							((huffmanTableSpec >> 4) === 0 ?
								huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = _buildHuffmanTable(codeLengths, huffmanValues);
						}
					}

					if (markerLo == 0xDD) { // DRI (Define Restart Interval)
						resetInterval = readUint16();
					}

					if (markerLo == 0xDA) { // SOS (Start of Scan)
						readUint16();
						var selectorsCount = data[offset++];
						var components = [];

						for (i = 0; i < selectorsCount; i++) {
							var componentIndex = this.frame.componentIds[data[offset++]];
							component = this.frame.components[componentIndex];
							var tableSpec = data[offset++];
							component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
							component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
							components.push(component);
						}

						var spectralStart = data[offset++];
						var spectralEnd = data[offset++];
						var successiveApproximation = data[offset++];
						var processed = decodeScan(data, offset,
							this.frame, components, resetInterval,
							spectralStart, spectralEnd,
							successiveApproximation >> 4, successiveApproximation & 15);
						offset += processed;
					}

					if (markerLo == 0xD9) { // EOI (End of image)
						break;
					}
				} else {
					if (data[offset - 3] == 0xFF &&
						data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
						// could be incorrect encoding -- last 0xFF byte of the previous
						// block was eaten by the encoder
						offset -= 3;
					}
					while (data[offset] != 0xFF && offset < data.length) {
						// file could be damaged and have some extra data between blocks
						offset++;
					}

					if (data[offset] != 0xFF) {
						throw "bad jpeg ";
					}
				}
			}

			if (!this.frame) throw 'bad jpeg';

			if (offset < data.length) this.tail = data.subarray(offset);

			return this;
		};

	// Standard Huffman tables for coder initialization
	// ===========================================================================================================
		var bitcode = new Array(65535),
			category = new Array(65535),
			std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
			std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
			std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d],
			std_ac_luminance_values = [
				0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
				0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
				0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
				0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
				0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
				0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
				0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
				0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
				0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
				0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
				0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
				0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
				0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
				0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
				0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
				0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
				0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
				0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
				0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
				0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
				0xf9, 0xfa
			],
			std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
			std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
			std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77],
			std_ac_chrominance_values = [
				0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
				0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
				0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
				0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
				0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
				0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
				0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
				0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
				0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
				0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
				0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
				0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
				0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
				0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
				0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
				0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
				0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
				0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
				0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
				0xf9, 0xfa
			];

		function _initCategoryNumber() {
			var nrlower = 1;
			var nrupper = 2;
			for (var cat = 1; cat <= 15; cat++) {
				//Positive numbers
				for (var nr = nrlower; nr < nrupper; nr++) {
					category[32767 + nr] = cat;
					bitcode[32767 + nr] = [];
					bitcode[32767 + nr][1] = cat;
					bitcode[32767 + nr][0] = nr;
				}
				//Negative numbers
				for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
					category[32767 + nrneg] = cat;
					bitcode[32767 + nrneg] = [];
					bitcode[32767 + nrneg][1] = cat;
					bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
		}

		_initCategoryNumber();

		function _computeHuffmanTbl(nrcodes, std_table) {
			var codevalue = 0;
			var pos_in_table = 0;
			var HT = [];
			for (var k = 1; k <= 16; k++) {
				for (var j = 1; j <= nrcodes[k]; j++) {
					HT[std_table[pos_in_table]] = [];
					HT[std_table[pos_in_table]][0] = codevalue;
					HT[std_table[pos_in_table]][1] = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue *= 2;
			}
			return HT;
		}

		var YDC_HT = _computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values),
			UVDC_HT = _computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values),
			YAC_HT = _computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values),
			UVAC_HT = _computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);

	// JPEG encoder
	// ===========================================================================================================
		f5stego.prototype.pack = function() {
			var byteout, bytenew, bytepos, poslast, outpos, byte;

			// IO functions
			function writeByte(value) {
				var t;

				byteout[outpos++] = value;
				if (outpos > poslast) {
					t = new Uint8Array(byteout.length * 2);
					t.set(byteout);
					byteout = t;
					poslast = t.length - 128;
				}
			}

			function writeWord(value) {
				writeByte((value >> 8) & 0xFF);
				writeByte((value) & 0xFF);
			}

			function writeBlock(block) {
				var t;
				if (outpos + block.length > poslast) {
					t = new Uint8Array(byteout.length * 2 + block.length);
					t.set(byteout);
					byteout = t;
					poslast = t.length - 128;
				}

				byteout.set(block, outpos);
				outpos += block.length;
			}

			function writeAPP0(self) {
				writeWord(0xFFE0); // marker
				if (!self.jfif) {
					writeWord(16); // length
					writeByte(0x4A); // J
					writeByte(0x46); // F
					writeByte(0x49); // I
					writeByte(0x46); // F
					writeByte(0); // = "JFIF",'\0'
					writeByte(1); // versionhi
					writeByte(1); // versionlo
					writeByte(0); // xyunits
					writeWord(1); // xdensity
					writeWord(1); // ydensity
					writeByte(0); // thumbnwidth
					writeByte(0); // thumbnheight
				} else {
					writeWord(self.jfif.length + 2); // length
					writeBlock(self.jfif);
				}
			}

			function writeDQT(self) {
				for (var i = 0; i < self.qts.length; i++) {
					writeWord(0xFFDB); // marker
					writeWord(self.qts[i].length + 2); // length
					writeBlock(self.qts[i]);
				}
			}

			function writeAPPn(self) {
				for (var i = 0; i < self.APPn.length; i++) {
					writeWord(0xFF00 | self.APPn[i].app);
					writeWord(self.APPn[i].data.length + 2);
					writeBlock(self.APPn[i].data);
				}
			}

			function writeSOF0(self) {
				writeWord(0xFFC0); // marker
				writeWord(8 + self.frame.components.length * 3); // length
				writeByte(self.frame.precision); // precision
				writeWord(self.frame.scanLines);
				writeWord(self.frame.samplesPerLine);
				writeByte(self.frame.components.length); // nrofcomponents

				for (var i = 0; i < self.frame.components.length; i++) {
					var c = self.frame.components[i];
					writeByte(c.componentId);
					writeByte(c.h << 4 | c.v);
					writeByte(c.quantizationTable);
				}
			}

			function writeDHT(self) {
				writeWord(0xFFC4); // marker
				writeWord(31); // length
				writeByte(0); // HTYDCinfo
				for (var i = 0; i < 16; i++) {
					writeByte(std_dc_luminance_nrcodes[i + 1]);
				}
				for (var j = 0; j <= 11; j++) {
					writeByte(std_dc_luminance_values[j]);
				}

				writeWord(0xFFC4); // marker
				writeWord(181); // length
				writeByte(0x10); // HTYACinfo
				for (var k = 0; k < 16; k++) {
					writeByte(std_ac_luminance_nrcodes[k + 1]);
				}
				for (var l = 0; l <= 161; l++) {
					writeByte(std_ac_luminance_values[l]);
				}

				if (self.frame.components.length != 1) {
					writeWord(0xFFC4); // marker
					writeWord(31); // length
					writeByte(1); // HTUDCinfo
					for (var m = 0; m < 16; m++) {
						writeByte(std_dc_chrominance_nrcodes[m + 1]);
					}
					for (var n = 0; n <= 11; n++) {
						writeByte(std_dc_chrominance_values[n]);
					}

					writeWord(0xFFC4); // marker
					writeWord(181); // length
					writeByte(0x11); // HTUACinfo
					for (var o = 0; o < 16; o++) {
						writeByte(std_ac_chrominance_nrcodes[o + 1]);
					}
					for (var p = 0; p <= 161; p++) {
						writeByte(std_ac_chrominance_values[p]);
					}
				}
			}

			function writeSOS(self) {
				writeWord(0xFFDA); // marker
				writeWord(6 + self.frame.components.length * 2); // length
				writeByte(self.frame.components.length); // nrofcomponents

				for (var i = 0; i < self.frame.components.length; i++) {
					var c = self.frame.components[i];
					writeByte(c.componentId);
					if (i === 0) {
						writeByte(0);
					} else {
						writeByte(0x11);
					}
				}

				writeByte(0); // Ss
				writeByte(0x3f); // Se
				writeByte(0); // Bf
			}

			function processDU(comp, POS, DC, HTDC, HTAC) {
				var pos, posval, t;

				if (bytepos === 0) bytenew = 0;

				var Diff = comp.blocksDC[POS >> 6] - DC;
				DC = comp.blocksDC[POS >> 6];
				//Encode DC
				if (Diff === 0) {
					posval = HTDC[0][1];

					bytenew <<= posval;
					bytenew += HTDC[0][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}

				} else {
					pos = 32767 + Diff;

					posval = HTDC[category[pos]][1];
					bytenew <<= posval;
					bytenew += HTDC[category[pos]][0];
					bytepos += posval;

					posval = bitcode[pos][1];
					bytenew <<= posval;
					bytenew += bitcode[pos][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}
				}
				//Encode ACs
				var end0pos = 63; // was const... which is crazy
				for (;
					(end0pos > 0) && (comp.blocks[POS + end0pos] === 0); end0pos--) {}
				//end0pos = first element in reverse order !=0
				if (end0pos === 0) {
					posval = HTAC[0x00][1];
					bytenew <<= posval;
					bytenew += HTAC[0x00][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}
					return DC;
				}
				var i = 1;
				var lng;
				while (i <= end0pos) {
					var startpos = i;
					for (;
						(comp.blocks[POS + i] === 0) && (i <= end0pos); ++i) {}
					var nrzeroes = i - startpos;
					if (nrzeroes >= 16) {
						lng = nrzeroes >> 4;
						for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) {
							posval = HTAC[0xF0][1];
							bytenew <<= posval;
							bytenew += HTAC[0xF0][0];
							bytepos += posval;

							while (bytepos > 7) {
								byte = 0xFF & (bytenew >>> (bytepos - 8));
								byteout[outpos++] = byte;
								if (byte == 0xFF) {
									outpos++;
								}
								bytepos -= 8;
								bytenew &= (1 << bytepos) - 1;
							}
						}
						nrzeroes = nrzeroes & 0xF;
					}
					pos = 32767 + comp.blocks[POS + i];

					posval = HTAC[(nrzeroes << 4) + category[pos]][1];
					bytenew <<= posval;
					bytenew += HTAC[(nrzeroes << 4) + category[pos]][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}

					posval = bitcode[pos][1];
					bytenew <<= posval;
					bytenew += bitcode[pos][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}
					i++;
				}
				if (end0pos != 63) {
					posval = HTAC[0x00][1];
					bytenew <<= posval;
					bytenew += HTAC[0x00][0];
					bytepos += posval;

					while (bytepos > 7) {
						byte = 0xFF & (bytenew >>> (bytepos - 8));
						byteout[outpos++] = byte;
						if (byte == 0xFF) {
							outpos++;
						}
						bytepos -= 8;
						bytenew &= (1 << bytepos) - 1;
					}
				}

				if (outpos > poslast) {
					t = new Uint8Array(byteout.length * 2);
					t.set(byteout);
					byteout = t;
					poslast = t.length - 128;
				}

				return DC;
			}

			// Initialize bit writer
			byteout = new Uint8Array(65536);
			poslast = 65536 - 128;
			outpos = 0;
			bytenew = 0;
			bytepos = 0;

			// Add JPEG headers
			writeWord(0xFFD8); // SOI
			writeAPP0(this);
			writeAPPn(this);
			writeDQT(this);
			writeSOF0(this);
			writeDHT(this);
			writeSOS(this);

			bytenew = 0;
			bytepos = 0;

			var c, mcuRow, mcuCol, blockRow, blockCol, mcu, i, v, h;

			var DCdiff = [];
			for (i = 0; i < this.frame.components.length; i++) {
				DCdiff.push(0);
			}

			for (mcu = 0; mcu < this.frame.mcusPerLine * this.frame.mcusPerColumn; mcu++) {
				mcuRow = (mcu / this.frame.mcusPerLine) | 0;
				mcuCol = mcu % this.frame.mcusPerLine;
				for (i = 0; i < this.frame.components.length; i++) {
					c = this.frame.components[i];
					for (v = 0; v < c.v; v++) {
						blockRow = mcuRow * c.v + v;
						for (h = 0; h < c.h; h++) {
							blockCol = mcuCol * c.h + h;
							if (i === 0) {
								DCdiff[i] = processDU(c, (blockRow * this.frame.mcusPerLine * c.h + blockCol) * 64, DCdiff[i], YDC_HT, YAC_HT);
							} else {
								DCdiff[i] = processDU(c, (blockRow * this.frame.mcusPerLine * c.h + blockCol) * 64, DCdiff[i], UVDC_HT, UVAC_HT);
							}
						}
					}
				}
			}

			// Write last bytes from coder
			while (bytepos > 7) {
				byte = 0xFF & (bytenew >>> (bytepos - 8));
				byteout[outpos++] = byte;
				if (byte == 0xFF) {
					outpos++;
				}
				bytepos -= 8;
			}
			// And do the bit alignment of the EOI marker
			if (bytepos > 0) {
				bytenew <<= 8 - bytepos;
				bytenew += (1 << (8 - bytepos)) - 1;
				byteout[outpos++] = 0xFF & bytenew;
			}

			writeWord(0xFFD9); //EOI
			if (this.tail) writeBlock(this.tail);

			return byteout.slice(0, outpos);
		};

	// Metadata manipulation
	// ===========================================================================================================
		f5stego.prototype.clearTail = function() {
			if (!this.tail) return null;

			var t = this.tail;
			this.tail = null;

			return t;
		};

		f5stego.prototype.setTail = function(data) {
			this.tail = data;
		};

		f5stego.prototype.getTail = function() {
			return this.tail;
		};

		f5stego.prototype.clearAPPs = function() {
			var t = this.APPn;
			this.APPn = [];
			return t;
		};

		f5stego.prototype.getAPPn = function(id, remove) {
			var i, t, ret = new Uint8Array(0),
				n = [];

			id &= 0xFF;
			if (id < 16) id += 0xE0;
			if (id === 0xE0) return this.jfif;

			for (i = 0; i < this.APPn.length; i++) {
				if (this.APPn[i].app == id) {
					t = new Uint8Array(ret.length + this.APPn[i].data.length);
					t.set(ret);
					t.set(this.APPn[i].data, ret.length);
					ret = t;
				} else if (remove) n.push(this.APPn[i]);
			}

			if (remove) this.APPn = n;

			if (ret.length === 0) return null;

			return ret;
		};

		f5stego.prototype.setAPPn = function(id, data) {
			var i, t, ret;

			id &= 0xFF;
			if (id < 16) id += 0xE0;

			if (id === 0xE0) {
				t = this.jfif;
				this.jfif = data;
				return t;
			}

			ret = this.getAPPn(id, true);

			if (data.length < 65534) {
				this.APPn.push({ 'app': id, 'data': data });
				return ret;
			}

			i = 0;

			while (i < data.length) {
				this.APPn.push({ 'app': id, 'data': data.subarray(i, i + 65533) });
				i += 65533;
			}

			return ret;
		};

		f5stego.prototype.strip = function() {
			this.clearTail();
			this.clearAPPs();
			return true;
		};

	// Shorthand functions to embed/extract f5 data
	// ===========================================================================================================
		f5stego.prototype.embed = function(image, data) {
			this.parse(image).f5put(data);
			return this.pack();
		};

		f5stego.prototype.extract = function(image) {
			return this.parse(image).f5get();
		};

	return f5stego;
}));

    </script>

    <script>
        // ============== CONSTANTS ==============
        const MAGIC_BYTES = [0x53, 0x54, 0x45, 0x47]; // 'STEG'
        const HEADER_SIZE = 32;
        const FORMAT_VERSION = 3;

        const CHANNEL_PRESETS = {
            'R': [0],
            'G': [1],
            'B': [2],
            'A': [3],
            'RG': [0, 1],
            'RB': [0, 2],
            'GB': [1, 2],
            'RGB': [0, 1, 2],
            'RGBA': [0, 1, 2, 3]
        };

        // ============== STATE ==============
        let state = {
            mediaType: 'image', // 'image' or 'audio'
            carrierImage: null,
            carrierCanvas: null,
            payloadMode: 'text',
            payloadFile: null,
            payloadFileName: null,
            decodeImage: null,
            decodeCanvas: null,
            analyzeImage: null,
            encodedResult: null,
            encodedJpegResult: null, // For F5 JPEG output
            encodedPngChunkResult: null, // For PNG Chunk output
            decodeJpegData: null, // For F5 - original JPEG bytes
            decodePngData: null, // For PNG Chunk - original PNG bytes
            extractedData: null,
            extractedFileName: null,
            matryoshkaMode: false,
            matryoshkaDepth: 3,
            matryoshkaCarriers: [],  // List of {canvas, name, width, height}
            matryoshkaDecodeCanvas: null,  // Separate canvas for Matryoshka decode
            matryoshkaExtractedData: null,
            matryoshkaExtractedFilename: null,
            // Matryoshka-specific encode state
            matryoshkaOuterCarrier: null,  // Canvas for outer carrier in matryoshka tab
            matryoshkaPayloadMode: 'text',  // 'text' or 'file'
            matryoshkaPayloadFile: null,
            matryoshkaPayloadFileName: null,
            // GODMODE state
            godmodeActive: false,
            godmodeCipherMode: 'manual',  // 'manual' or 'password'
            godmodeEmbedMode: 'lsb',  // 'lsb' or 'dct'
            godmodeCarrierCanvas: null,
            godmodePayloadMode: 'text',
            godmodePayloadFile: null,
            godmodePayloadFileName: null,
            godmodeDecodeCanvas: null,
            godmodeDecodedData: null,
            // Audio steg state
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            audioIsPlaying: false,
            audioMethod: 'lsb',
            audioPayloadMode: 'text',
            audioPayloadFile: null,
            audioPayloadFileName: null,
            audioSpecartImage: null,
            audioEncodedSamples: null,
            audioDecodedData: null
        };

        // ============== UTILITY FUNCTIONS ==============
        function notify(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function imageToCanvas(img) {
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth || img.width;
            canvas.height = img.naturalHeight || img.height;
            // Use willReadFrequently for steganography pixel operations
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            const table = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c;
            }
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // Simple compression using deflate (browser built-in via Response)
        async function compress(data) {
            const stream = new Blob([data]).stream();
            const compressed = stream.pipeThrough(new CompressionStream('deflate'));
            return new Uint8Array(await new Response(compressed).arrayBuffer());
        }

        async function decompress(data) {
            try {
                const stream = new Blob([data]).stream();
                const decompressed = stream.pipeThrough(new DecompressionStream('deflate'));
                const result = new Uint8Array(await new Response(decompressed).arrayBuffer());
                return result;
            } catch (e) {
                return data; // Return original if decompression fails
            }
        }

        // ============== BIT MANIPULATION ==============
        function bytesToBits(data, bitsPerUnit = 1) {
            const bits = [];
            for (let i = 0; i < data.length; i++) {
                for (let j = 7; j >= 0; j--) {
                    bits.push((data[i] >> j) & 1);
                }
            }

            if (bitsPerUnit === 1) return bits;

            // Group bits
            const result = [];
            for (let i = 0; i < bits.length; i += bitsPerUnit) {
                let value = 0;
                for (let j = 0; j < bitsPerUnit && i + j < bits.length; j++) {
                    value = (value << 1) | bits[i + j];
                }
                result.push(value);
            }
            return result;
        }

        function bitsToBytes(bits, bitsPerUnit = 1) {
            // Expand to individual bits if needed
            let bitArray = [];
            if (bitsPerUnit === 1) {
                bitArray = bits;
            } else {
                for (let i = 0; i < bits.length; i++) {
                    for (let j = bitsPerUnit - 1; j >= 0; j--) {
                        bitArray.push((bits[i] >> j) & 1);
                    }
                }
            }

            // Pack into bytes
            const bytes = [];
            for (let i = 0; i < bitArray.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8 && i + j < bitArray.length; j++) {
                    byte = (byte << 1) | bitArray[i + j];
                }
                // Pad remaining bits with zeros
                if (i + 8 > bitArray.length) {
                    byte <<= (8 - (bitArray.length - i));
                }
                bytes.push(byte);
            }
            return new Uint8Array(bytes);
        }

        // ============== HEADER ==============
        function createHeader(payloadLength, originalLength, crc, channels, bits, compressed = true) {
            const header = new Uint8Array(HEADER_SIZE);

            // Magic bytes
            header[0] = MAGIC_BYTES[0];
            header[1] = MAGIC_BYTES[1];
            header[2] = MAGIC_BYTES[2];
            header[3] = MAGIC_BYTES[3];

            // Version
            header[4] = FORMAT_VERSION;

            // Channel mask
            let channelMask = 0;
            for (const ch of channels) {
                channelMask |= (1 << ch);
            }
            header[5] = channelMask;

            // Bits per channel
            header[6] = bits;

            // Bit offset
            header[7] = 0;

            // Flags (compression = bit 0, interleaved = bit 1)
            header[8] = (compressed ? 1 : 0) | 2; // Always interleaved

            // Reserved + seed (9-15)

            // Payload length (16-19, big endian)
            header[16] = (payloadLength >> 24) & 0xFF;
            header[17] = (payloadLength >> 16) & 0xFF;
            header[18] = (payloadLength >> 8) & 0xFF;
            header[19] = payloadLength & 0xFF;

            // Original length (20-23, big endian)
            header[20] = (originalLength >> 24) & 0xFF;
            header[21] = (originalLength >> 16) & 0xFF;
            header[22] = (originalLength >> 8) & 0xFF;
            header[23] = originalLength & 0xFF;

            // CRC32 (24-27, big endian)
            header[24] = (crc >> 24) & 0xFF;
            header[25] = (crc >> 16) & 0xFF;
            header[26] = (crc >> 8) & 0xFF;
            header[27] = crc & 0xFF;

            return header;
        }

        function parseHeader(data) {
            if (data.length < HEADER_SIZE) return null;

            // Check magic
            if (data[0] !== MAGIC_BYTES[0] || data[1] !== MAGIC_BYTES[1] ||
                data[2] !== MAGIC_BYTES[2] || data[3] !== MAGIC_BYTES[3]) {
                return null;
            }

            const version = data[4];
            const channelMask = data[5];
            const bitsPerChannel = data[6];
            const bitOffset = data[7];
            const flags = data[8];

            const channels = [];
            for (let i = 0; i < 4; i++) {
                if (channelMask & (1 << i)) channels.push(i);
            }

            const payloadLength = (data[16] << 24) | (data[17] << 16) | (data[18] << 8) | data[19];
            const originalLength = (data[20] << 24) | (data[21] << 16) | (data[22] << 8) | data[23];
            const crc = (data[24] << 24) | (data[25] << 16) | (data[26] << 8) | data[27];

            return {
                version,
                channels,
                bitsPerChannel,
                bitOffset,
                compressed: !!(flags & 1),
                payloadLength,
                originalLength,
                crc
            };
        }

        // ============== ENCODE ==============
        async function encode(canvas, data, channelName, bitsPerChannel) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            const channels = CHANNEL_PRESETS[channelName] || [0, 1, 2];
            const originalLength = data.length;
            const crcValue = crc32(data);

            // Compress data
            let payload;
            try {
                payload = await compress(data);
            } catch (e) {
                payload = data;
            }

            // Create header
            const header = createHeader(payload.length, originalLength, crcValue, channels, bitsPerChannel, true);

            // Combine header and payload
            const fullData = new Uint8Array(header.length + payload.length);
            fullData.set(header);
            fullData.set(payload, header.length);

            // Check capacity
            const totalPixels = canvas.width * canvas.height;
            const bitsPerPixel = channels.length * bitsPerChannel;
            const capacity = Math.floor((totalPixels * bitsPerPixel) / 8);

            if (fullData.length > capacity) {
                throw new Error(`Data too large: ${fullData.length} bytes, capacity: ${capacity} bytes`);
            }

            // Convert to bit units
            const bitUnits = bytesToBits(fullData, bitsPerChannel);
            const bitMask = (1 << bitsPerChannel) - 1;
            const clearMask = ~bitMask & 0xFF;

            // Embed data (interleaved)
            let unitIdx = 0;
            for (let pixIdx = 0; pixIdx < totalPixels && unitIdx < bitUnits.length; pixIdx++) {
                const baseIdx = pixIdx * 4;
                for (const ch of channels) {
                    if (unitIdx >= bitUnits.length) break;
                    pixels[baseIdx + ch] = (pixels[baseIdx + ch] & clearMask) | bitUnits[unitIdx];
                    unitIdx++;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            return canvas;
        }

        // ============== DECODE ==============
        function extractRawBits(canvas, channels, bitsPerChannel, maxBytes = 4096) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            const totalPixels = canvas.width * canvas.height;
            const bitsNeeded = maxBytes * 8;
            const unitsNeeded = Math.ceil(bitsNeeded / bitsPerChannel);
            const bitMask = (1 << bitsPerChannel) - 1;

            const result = [];

            for (let pixIdx = 0; pixIdx < totalPixels && result.length < unitsNeeded; pixIdx++) {
                const baseIdx = pixIdx * 4;
                for (const ch of channels) {
                    if (result.length >= unitsNeeded) break;
                    result.push(pixels[baseIdx + ch] & bitMask);
                }
            }

            return bitsToBytes(result, bitsPerChannel).slice(0, maxBytes);
        }

        async function decode(canvas, channelName = null, bitsPerChannel = null) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            let channels, bits, header;

            // If config specified, use it directly
            if (channelName && bitsPerChannel) {
                channels = CHANNEL_PRESETS[channelName] || [0, 1, 2];
                bits = bitsPerChannel;
                const headerBytes = extractRawBits(canvas, channels, bits, HEADER_SIZE);
                header = parseHeader(headerBytes);
            } else {
                // Try multiple common configs to find the header
                const headerConfigs = [
                    { channels: [0, 1, 2], bits: 1 },       // RGB 1-bit (legacy default)
                    { channels: [0, 1, 2, 3], bits: 2 },   // RGBA 2-bit (matryoshka default)
                    { channels: [0, 1, 2, 3], bits: 1 },   // RGBA 1-bit
                    { channels: [0, 1, 2], bits: 2 },       // RGB 2-bit
                ];

                for (const cfg of headerConfigs) {
                    const headerBytes = extractRawBits(canvas, cfg.channels, cfg.bits, HEADER_SIZE);
                    const testHeader = parseHeader(headerBytes);
                    if (testHeader) {
                        header = testHeader;
                        channels = cfg.channels;
                        bits = cfg.bits;
                        break;
                    }
                }
            }

            if (!header) {
                throw new Error('No STEG header found');
            }

            // Use header's stored config for actual data extraction
            channels = header.channels;
            bits = header.bitsPerChannel;

            // Extract full data
            const totalLength = HEADER_SIZE + header.payloadLength;
            const fullData = extractRawBits(canvas, channels, bits, totalLength);

            // Get payload
            let payload = fullData.slice(HEADER_SIZE, HEADER_SIZE + header.payloadLength);

            // Decompress if needed
            if (header.compressed) {
                payload = await decompress(payload);
            }

            // Verify CRC (silent check)
            const actualCrc = crc32(payload);
            if (actualCrc !== header.crc >>> 0) {
                // CRC mismatch - data may be corrupted
            }

            return payload;
        }

        // ============== SMART SCAN ==============
        function detectCoherentText(data) {
            if (!data || data.length === 0) return { isText: false, confidence: 0, preview: '' };

            let printableCount = 0;
            let text = '';

            try {
                text = new TextDecoder('utf-8', { fatal: false }).decode(data);
            } catch (e) {
                return { isText: false, confidence: 0, preview: '' };
            }

            for (const char of text.slice(0, 500)) {
                if (char.charCodeAt(0) >= 32 && char.charCodeAt(0) < 127 || char === '\n' || char === '\t') {
                    printableCount++;
                }
            }

            const ratio = printableCount / Math.min(text.length, 500);
            const commonWords = ['the', 'and', 'is', 'in', 'to', 'of', 'a', 'for', 'flag', 'ctf', 'secret'];
            const textLower = text.toLowerCase();
            const wordMatches = commonWords.filter(w => textLower.includes(w)).length;

            let confidence = ratio * 50 + wordMatches * 5;
            confidence = Math.min(100, Math.max(0, confidence));

            return {
                isText: confidence > 35 && ratio > 0.7,
                confidence,
                preview: text.slice(0, 100).replace(/[^\x20-\x7E\n\t]/g, '¬∑'),
                ratio
            };
        }

        async function smartScan(canvas) {
            const results = [];

            const configs = [
                { name: 'RGB', channels: [0, 1, 2], bits: 1 },
                { name: 'RGB-2bit', channels: [0, 1, 2], bits: 2 },
                { name: 'RGBA', channels: [0, 1, 2, 3], bits: 1 },
                { name: 'RGBA-2bit', channels: [0, 1, 2, 3], bits: 2 },
                { name: 'R', channels: [0], bits: 1 },
                { name: 'G', channels: [1], bits: 1 },
                { name: 'B', channels: [2], bits: 1 },
                { name: 'R-2bit', channels: [0], bits: 2 },
                { name: 'G-2bit', channels: [1], bits: 2 },
                { name: 'B-2bit', channels: [2], bits: 2 },
                { name: 'RG', channels: [0, 1], bits: 1 },
                { name: 'RB', channels: [0, 2], bits: 1 },
                { name: 'GB', channels: [1, 2], bits: 1 },
                { name: 'RG-2bit', channels: [0, 1], bits: 2 },
                { name: 'RB-2bit', channels: [0, 2], bits: 2 },
                { name: 'GB-2bit', channels: [1, 2], bits: 2 },
            ];

            // First check for STEG header with multiple common configs
            const headerConfigs = [
                { channels: [0, 1, 2], bits: 1 },       // RGB 1-bit
                { channels: [0, 1, 2, 3], bits: 2 },   // RGBA 2-bit (matryoshka)
                { channels: [0, 1, 2, 3], bits: 1 },   // RGBA 1-bit
                { channels: [0, 1, 2], bits: 2 },       // RGB 2-bit
            ];

            for (const hdrCfg of headerConfigs) {
                try {
                    const headerBytes = extractRawBits(canvas, hdrCfg.channels, hdrCfg.bits, HEADER_SIZE);
                    const header = parseHeader(headerBytes);
                    if (header) {
                        const channelStr = header.channels.map(c => ['R', 'G', 'B', 'A'][c]).join('');
                        results.push({
                            name: 'STEG-HEADER',
                            channels: channelStr,
                            bits: header.bitsPerChannel,
                            status: 'STEG_DETECTED',
                            confidence: 95,
                            preview: `[STEG v${header.version} - ${formatSize(header.originalLength)} - ${channelStr} ${header.bitsPerChannel}bit]`,
                            hasHeader: true,
                            rawData: null,
                            headerConfig: hdrCfg
                        });
                        break; // Found header, stop searching
                    }
                } catch (e) {}
            }

            // Scan configs
            for (const cfg of configs) {
                try {
                    const rawData = extractRawBits(canvas, cfg.channels, cfg.bits, 2048);

                    // Check for STEG magic
                    const hasMagic = rawData[0] === MAGIC_BYTES[0] && rawData[1] === MAGIC_BYTES[1] &&
                                     rawData[2] === MAGIC_BYTES[2] && rawData[3] === MAGIC_BYTES[3];

                    const analysis = detectCoherentText(rawData);

                    let status;
                    if (hasMagic) status = 'STEG_HEADER';
                    else if (analysis.isText && analysis.confidence >= 50) status = 'TEXT_FOUND';
                    else if (analysis.isText) status = 'POSSIBLE_TEXT';
                    else if (analysis.ratio > 0.5) status = 'MIXED_DATA';
                    else status = 'BINARY/NOISE';

                    results.push({
                        name: cfg.name,
                        channels: cfg.channels.map(c => ['R', 'G', 'B', 'A'][c]).join(','),
                        bits: cfg.bits,
                        status,
                        confidence: analysis.confidence,
                        preview: analysis.preview || rawData.slice(0, 50).toString(),
                        hasHeader: hasMagic,
                        rawData: (hasMagic || analysis.confidence >= 30) ? rawData : null
                    });
                } catch (e) {
                    results.push({
                        name: cfg.name,
                        channels: cfg.channels.map(c => ['R', 'G', 'B', 'A'][c]).join(','),
                        bits: cfg.bits,
                        status: 'ERROR',
                        confidence: 0,
                        preview: e.message
                    });
                }
            }

            // Also try DCT decode
            try {
                const dctData = await dctDecode(canvas);
                if (dctData && dctData.length > 0) {
                    const analysis = detectCoherentText(dctData);
                    results.push({
                        name: 'DCT',
                        channels: 'Luminance',
                        bits: 'DCT',
                        status: 'STEG_DETECTED',
                        confidence: 90,
                        preview: isImageData(dctData) ? '[Nested Image]' : (analysis.preview || `[${dctData.length} bytes]`),
                        hasHeader: true,
                        rawData: dctData,
                        isDCT: true
                    });
                }
            } catch (e) {
                // DCT decode failed - no DCT steg found
            }

            // Also try Chroma decode
            try {
                const chromaData = await chromaDecode(canvas, 'ycbcr', 'both');
                if (chromaData && chromaData.length > 0) {
                    const analysis = detectCoherentText(chromaData);
                    results.push({
                        name: 'Chroma',
                        channels: 'Cb+Cr',
                        bits: 'Chroma',
                        status: 'STEG_DETECTED',
                        confidence: 90,
                        preview: isImageData(chromaData) ? '[Nested Image]' : (analysis.preview || `[${chromaData.length} bytes]`),
                        hasHeader: true,
                        rawData: chromaData,
                        isChroma: true
                    });
                }
            } catch (e) {
                // Chroma decode failed - no chroma steg found
            }

            // Sort by confidence
            results.sort((a, b) => {
                if (a.hasHeader && !b.hasHeader) return -1;
                if (!a.hasHeader && b.hasHeader) return 1;
                return b.confidence - a.confidence;
            });

            return results;
        }

        // ============== MATRYOSHKA MODE ==============
        function isImageData(data) {
            if (!data || data.length < 8) return false;
            // PNG
            if (data[0] === 0x89 && data[1] === 0x50 && data[2] === 0x4E && data[3] === 0x47) return true;
            // JPEG
            if (data[0] === 0xFF && data[1] === 0xD8) return true;
            return false;
        }

        function extractFileFromData(data) {
            // First check if it's raw image data (PNG/JPEG) - don't try to parse as filename
            if (isImageData(data)) {
                return { filename: null, fileData: data };
            }

            // Common file extensions to look for
            const validExtensions = [
                '.txt', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.svg',
                '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
                '.zip', '.rar', '.7z', '.tar', '.gz',
                '.mp3', '.wav', '.ogg', '.mp4', '.avi', '.mkv', '.mov',
                '.html', '.css', '.js', '.json', '.xml', '.csv',
                '.py', '.java', '.c', '.cpp', '.h', '.rs', '.go', '.rb',
                '.md', '.rtf', '.log', '.dat', '.bin', '.exe', '.dll'
            ];

            // Try to extract filename prefix (format: [len byte][filename][data])
            // Be strict: filename must be 1-100 chars, have valid extension, no weird chars
            if (data.length > 2 && data[0] > 0 && data[0] <= 100) {
                const fnameLen = data[0];
                if (fnameLen + 1 < data.length) {
                    try {
                        const filename = new TextDecoder().decode(data.slice(1, 1 + fnameLen));
                        // Must be printable ASCII, no path separators, must have valid extension
                        if (/^[a-zA-Z0-9_\-. ]+$/.test(filename) &&
                            !filename.includes('/') &&
                            !filename.includes('\\') &&
                            !filename.startsWith('.') &&
                            !filename.startsWith(' ')) {
                            // Check for valid extension
                            const lowerName = filename.toLowerCase();
                            const hasValidExt = validExtensions.some(ext => lowerName.endsWith(ext));
                            if (hasValidExt) {
                                return { filename, fileData: data.slice(1 + fnameLen) };
                            }
                        }
                    } catch (e) {}
                }
            }
            return { filename: null, fileData: data };
        }

        async function matryoshkaDecode(canvas, maxDepth = 3, currentDepth = 0) {
            const results = [];

            const layerInfo = {
                depth: currentDepth,
                type: 'unknown',
                filename: null,
                dataSize: 0,
                preview: '',
                hasNested: false,
                nestedResults: [],
                scanResults: [] // Store all scan findings
            };

            if (currentDepth >= maxDepth) {
                layerInfo.type = 'max_depth_reached';
                layerInfo.preview = `Max depth (${maxDepth}) reached`;
                results.push(layerInfo);
                return results;
            }

            try {
                // ALWAYS smart scan first to find all possible hidden data
                const scanResults = await smartScan(canvas);
                layerInfo.scanResults = scanResults.filter(r =>
                    r.status === 'STEG_DETECTED' || r.status === 'STEG_HEADER' ||
                    r.status === 'TEXT_FOUND' || r.status === 'POSSIBLE_TEXT'
                ).slice(0, 5); // Keep top 5 findings

                // Find the best result to decode
                let data = null;
                let bestResult = null;

                // First try STEG header detection (most reliable)
                const stegResult = scanResults.find(r =>
                    r.status === 'STEG_DETECTED' || r.status === 'STEG_HEADER'
                );

                if (stegResult) {
                    try {
                        // Use auto-decode which reads the header
                        data = await decode(canvas);
                        bestResult = stegResult;
                        layerInfo.type = 'steg_header';
                    } catch (e) {
                        // Header parsing failed, try raw data
                        if (stegResult.rawData) {
                            data = stegResult.rawData;
                            bestResult = stegResult;
                            layerInfo.type = `smart_scan_${stegResult.name}`;
                        }
                    }
                }

                // If no STEG header, try best text result
                if (!data) {
                    const textResult = scanResults.find(r =>
                        r.status === 'TEXT_FOUND' && r.rawData
                    );
                    if (textResult) {
                        data = textResult.rawData;
                        bestResult = textResult;
                        layerInfo.type = `smart_scan_${textResult.name}`;
                    }
                }

                // Still nothing? Try any result with raw data
                if (!data) {
                    const anyResult = scanResults.find(r => r.rawData && r.confidence > 20);
                    if (anyResult) {
                        data = anyResult.rawData;
                        bestResult = anyResult;
                        layerInfo.type = `smart_scan_${anyResult.name}`;
                    }
                }

                if (!data) {
                    layerInfo.type = 'no_data_found';
                    layerInfo.preview = 'No hidden data detected in any configuration';
                    results.push(layerInfo);
                    return results;
                }

                layerInfo.dataSize = data.length;
                // Show channel info: e.g., "RGBA 2bit" instead of just "STEG-HEADER"
                if (bestResult && bestResult.channels && bestResult.bits) {
                    layerInfo.configUsed = `${bestResult.channels} ${bestResult.bits}bit`;
                } else {
                    layerInfo.configUsed = bestResult ? bestResult.name : 'auto';
                }

                // Check if it's a file with filename prefix
                const { filename, fileData } = extractFileFromData(data);

                if (filename) {
                    layerInfo.filename = filename;
                    layerInfo.dataSize = fileData.length;

                    if (isImageData(fileData)) {
                        // It's a nested image - recurse!
                        layerInfo.type = 'nested_image';
                        layerInfo.hasNested = true;
                        layerInfo.preview = `Found nested image: ${filename}`;

                        try {
                            const blob = new Blob([fileData], { type: 'image/png' });
                            // Use colorSpaceConversion: 'none' to preserve exact pixel values
                            const img = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                            const nestedCanvas = document.createElement('canvas');
                            nestedCanvas.width = img.width;
                            nestedCanvas.height = img.height;
                            nestedCanvas.getContext('2d', { willReadFrequently: true }).drawImage(img, 0, 0);

                            // Recursively decode the nested image
                            layerInfo.nestedResults = await matryoshkaDecode(nestedCanvas, maxDepth, currentDepth + 1);
                        } catch (e) {
                            layerInfo.preview += ` (failed to parse: ${e.message})`;
                        }
                    } else {
                        // Non-image file - show content
                        layerInfo.type = 'file';
                        try {
                            const text = new TextDecoder().decode(fileData.slice(0, 500));
                            layerInfo.preview = text;
                        } catch (e) {
                            layerInfo.preview = `Binary file: ${filename} (${formatSize(fileData.length)})`;
                        }
                    }
                    layerInfo.rawData = fileData;
                } else {
                    // Raw data without filename prefix
                    if (isImageData(data)) {
                        // Raw image data - recurse!
                        layerInfo.type = 'nested_image_raw';
                        layerInfo.hasNested = true;

                        try {
                            const blob = new Blob([data], { type: 'image/png' });
                            // Use colorSpaceConversion: 'none' to preserve exact pixel values for LSB steganography
                            const img = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                            const nestedCanvas = document.createElement('canvas');
                            nestedCanvas.width = img.width;
                            nestedCanvas.height = img.height;
                            // Use willReadFrequently hint for better performance
                            nestedCanvas.getContext('2d', { willReadFrequently: true }).drawImage(img, 0, 0);

                            layerInfo.imageSize = { width: img.width, height: img.height };
                            layerInfo.preview = `Extracted PNG ${img.width}x${img.height} (${formatSize(data.length)})`;

                            // Recursively decode the nested image
                            layerInfo.nestedResults = await matryoshkaDecode(nestedCanvas, maxDepth, currentDepth + 1);
                        } catch (e) {
                            layerInfo.preview = `PNG extraction failed: ${e.message}`;
                            layerInfo.hasNested = false;
                        }
                    } else {
                        // Plain text or binary
                        try {
                            const text = new TextDecoder().decode(data);
                            // Check if text might contain base64 encoded image
                            if (text.includes('data:image') || text.startsWith('iVBOR') || text.startsWith('/9j/')) {
                                layerInfo.type = 'base64_image_maybe';
                                layerInfo.preview = text.slice(0, 300);
                            } else {
                                layerInfo.type = 'text';
                                layerInfo.preview = text.slice(0, 500);
                            }
                        } catch (e) {
                            layerInfo.type = 'binary';
                            layerInfo.preview = `Binary: ${Array.from(data.slice(0, 30)).map(b => b.toString(16).padStart(2, '0')).join(' ')}...`;
                        }
                    }
                    layerInfo.rawData = data;
                }

            } catch (e) {
                layerInfo.type = 'error';
                layerInfo.preview = `Error: ${e.message}`;
            }

            results.push(layerInfo);
            return results;
        }

        // ============== UI FUNCTIONS ==============
        function setPayloadMode(mode) {
            state.payloadMode = mode;
            document.getElementById('payload-text-mode').classList.toggle('hidden', mode !== 'text');
            document.getElementById('payload-file-mode').classList.toggle('hidden', mode !== 'file');
            document.getElementById('payload-text-btn').classList.toggle('btn-secondary', mode !== 'text');
            document.getElementById('payload-file-btn').classList.toggle('btn-secondary', mode !== 'file');
            updateCapacity();
        }

        function setMatryoshkaPayloadMode(mode) {
            state.matryoshkaPayloadMode = mode;
            document.getElementById('m-payload-text-mode').classList.toggle('hidden', mode !== 'text');
            document.getElementById('m-payload-file-mode').classList.toggle('hidden', mode !== 'file');
            // Toggle button active state
            const textBtn = document.getElementById('m-payload-text-btn');
            const fileBtn = document.getElementById('m-payload-file-btn');
            if (mode === 'text') {
                textBtn.classList.remove('btn-secondary');
                fileBtn.classList.add('btn-secondary');
            } else {
                textBtn.classList.add('btn-secondary');
                fileBtn.classList.remove('btn-secondary');
            }
        }

        // Generate a noise carrier image for inner layers
        function generateNoiseCarrier(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.floor(Math.random() * 256);     // R
                data[i + 1] = Math.floor(Math.random() * 256); // G
                data[i + 2] = Math.floor(Math.random() * 256); // B
                data[i + 3] = 255;                              // A
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Scale a canvas to new dimensions while preserving aspect ratio
        function scaleCanvas(sourceCanvas, maxWidth, maxHeight) {
            const aspectRatio = sourceCanvas.width / sourceCanvas.height;
            let newWidth = maxWidth;
            let newHeight = maxHeight;

            // Preserve aspect ratio
            if (maxWidth / maxHeight > aspectRatio) {
                newWidth = Math.floor(maxHeight * aspectRatio);
            } else {
                newHeight = Math.floor(maxWidth / aspectRatio);
            }

            const canvas = document.createElement('canvas');
            canvas.width = newWidth;
            canvas.height = newHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(sourceCanvas, 0, 0, newWidth, newHeight);
            return canvas;
        }

        // Calculate minimum outer carrier size needed for nested encoding
        // Uses same constants as doMatryoshkaEncode for consistency
        function calculateMinOuterSize(payloadSize, depth, channels = 4, bitsPerChannel = 2, embedMode = 'lsb') {
            const STEG_HEADER = embedMode === 'dct' ? 12 : 32;
            // DCT: 1 bit per 8x8 block = 1/512 bytes per pixel
            const bytesPerPixel = embedMode === 'dct' ? 1/512 : (channels * bitsPerChannel) / 8;
            const PNG_RATIO = 0.7;
            const PNG_OVERHEAD = 500;
            const BUFFER = 1.3;

            const layerSizes = [];

            // Layer 0 (innermost) holds the actual payload
            const innerCapacityNeeded = payloadSize + STEG_HEADER;
            const innerPixels = Math.ceil(innerCapacityNeeded / bytesPerPixel * BUFFER);
            let innerSide = Math.ceil(Math.sqrt(innerPixels));
            if (embedMode === 'dct') innerSide = Math.ceil(innerSide / 8) * 8;
            layerSizes.push({ w: Math.max(64, innerSide), h: Math.max(64, innerSide) });

            // Each subsequent layer holds the PNG of the previous layer
            for (let i = 1; i < depth; i++) {
                const prevSize = layerSizes[i - 1];
                const rawSize = prevSize.w * prevSize.h * 4;
                const estimatedPngSize = Math.ceil(rawSize * PNG_RATIO) + PNG_OVERHEAD;
                const capacityNeeded = estimatedPngSize + STEG_HEADER;
                const pixelsNeeded = Math.ceil(capacityNeeded / bytesPerPixel * BUFFER);
                let side = Math.ceil(Math.sqrt(pixelsNeeded));
                if (embedMode === 'dct') side = Math.ceil(side / 8) * 8;
                layerSizes.push({ w: side, h: side });
            }

            const minOuter = layerSizes[layerSizes.length - 1];
            let safeSide = Math.ceil(Math.max(minOuter.w, minOuter.h) * 1.1);
            if (embedMode === 'dct') safeSide = Math.ceil(safeSide / 8) * 8;
            const minPixels = safeSide * safeSide;

            return { width: safeSide, height: safeSide, minPixels, layerSizes };
        }

        // Update the size info display when inputs change
        function updateMatryoshkaSizeInfo() {
            const infoEl = document.getElementById('matryoshka-size-info');
            if (!infoEl) return;

            const depth = parseInt(document.getElementById('matryoshka-encode-depth').value) || 3;
            const embedMode = document.getElementById('matryoshka-embed-mode')?.value || 'lsb';
            const channelName = document.getElementById('matryoshka-channels')?.value || 'RGB';
            const bitsPerChannel = parseInt(document.getElementById('matryoshka-bits')?.value) || 2;
            const channels = CHANNEL_PRESETS[channelName]?.length || 3;

            let payloadSize = 0;

            if (state.matryoshkaPayloadMode === 'text') {
                const text = document.getElementById('matryoshka-text')?.value || '';
                payloadSize = new TextEncoder().encode(text).length;
            } else if (state.matryoshkaPayloadFile) {
                payloadSize = state.matryoshkaPayloadFile.length;
            }

            const modeLabel = embedMode === 'dct' ? 'DCT' : `${channelName} ${bitsPerChannel}-bit`;

            if (payloadSize === 0) {
                infoEl.textContent = modeLabel;
                return;
            }

            const sizeCalc = calculateMinOuterSize(payloadSize, depth, channels, bitsPerChannel, embedMode);
            const outerCanvas = state.matryoshkaOuterCarrier;

            if (outerCanvas) {
                const autoSize = document.getElementById('matryoshka-autosize')?.checked;
                if (autoSize && (outerCanvas.width > sizeCalc.width || outerCanvas.height > sizeCalc.height)) {
                    infoEl.innerHTML = `${modeLabel} | Min: ${sizeCalc.width}x${sizeCalc.height} ‚Üí Will shrink`;
                } else if (outerCanvas.width * outerCanvas.height < sizeCalc.minPixels) {
                    infoEl.innerHTML = `<span style="color: var(--warning);">‚ö† Need ${sizeCalc.width}x${sizeCalc.height}</span>`;
                } else {
                    infoEl.textContent = `${modeLabel} | Min: ${sizeCalc.width}x${sizeCalc.height} ‚úì`;
                }
            } else {
                infoEl.textContent = `${modeLabel} | Min: ${sizeCalc.width}x${sizeCalc.height}`;
            }
        }

        function generateCarrier(type) {
            const size = parseInt(document.getElementById('carrier-size')?.value || '900');
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            if (type === 'noise') {
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = Math.floor(Math.random() * 256);
                    imageData.data[i + 1] = Math.floor(Math.random() * 256);
                    imageData.data[i + 2] = Math.floor(Math.random() * 256);
                    imageData.data[i + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
            } else if (type === 'black') {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (type === 'white') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            state.carrierCanvas = canvas;

            const preview = document.getElementById('encode-carrier-preview');
            preview.src = canvas.toDataURL('image/png');
            preview.classList.remove('hidden');

            document.getElementById('encode-carrier-info').textContent =
                `Generated ${type} | ${canvas.width}√ó${canvas.height}`;

            updateCapacity();
            notify(`Generated ${type} carrier (${size}√ó${size})`, 'success');
        }

        // ============== METHOD UI TOGGLES ==============
        function updateMethodOptions() {
            const method = document.getElementById('encode-method').value;
            const hint = document.getElementById('method-hint');

            // Hide all options
            document.getElementById('lsb-options').classList.add('hidden');
            document.getElementById('dct-options').classList.add('hidden');
            document.getElementById('f5-options').classList.add('hidden');
            document.getElementById('spread-options').classList.add('hidden');
            document.getElementById('palette-options').classList.add('hidden');
            document.getElementById('chroma-options').classList.add('hidden');
            document.getElementById('pvd-options').classList.add('hidden');
            document.getElementById('pngchunk-options').classList.add('hidden');

            // Show relevant options and update hint
            if (method === 'LSB') {
                document.getElementById('lsb-options').classList.remove('hidden');
                hint.textContent = 'Classic steganography - high capacity, fragile to compression';
            } else if (method === 'PVD') {
                document.getElementById('pvd-options').classList.remove('hidden');
                hint.textContent = 'Pixel Value Differencing - harder to detect than LSB, good capacity';
            } else if (method === 'DCT') {
                document.getElementById('dct-options').classList.remove('hidden');
                hint.textContent = 'Embeds in frequency domain - survives JPEG compression';
            } else if (method === 'F5') {
                document.getElementById('f5-options').classList.remove('hidden');
                hint.textContent = 'JPEG domain steganography - statistical security, JPEG output only';
            } else if (method === 'SPREAD') {
                document.getElementById('spread-options').classList.remove('hidden');
                hint.textContent = 'Password-protected, distributed encoding - very robust';
            } else if (method === 'PALETTE') {
                document.getElementById('palette-options').classList.remove('hidden');
                hint.textContent = 'Encodes in color palette indices - works with indexed images';
            } else if (method === 'CHROMA') {
                document.getElementById('chroma-options').classList.remove('hidden');
                hint.textContent = 'Hides data in chrominance channels - visually undetectable';
            } else if (method === 'PNGCHUNK') {
                document.getElementById('pngchunk-options').classList.remove('hidden');
                hint.textContent = 'Hides data in PNG metadata chunks - survives most platforms';
            }

            updateCapacity();
        }

        function updateDecodeMethodOptions() {
            const method = document.getElementById('decode-method').value;

            // Hide all options
            document.getElementById('lsb-decode-options').classList.add('hidden');
            document.getElementById('dct-decode-options').classList.add('hidden');
            document.getElementById('f5-decode-options').classList.add('hidden');
            document.getElementById('spread-decode-options').classList.add('hidden');
            document.getElementById('palette-decode-options').classList.add('hidden');
            document.getElementById('chroma-decode-options').classList.add('hidden');
            document.getElementById('pvd-decode-options').classList.add('hidden');
            document.getElementById('pngchunk-decode-options').classList.add('hidden');

            // Show relevant options
            if (method === 'LSB') {
                document.getElementById('lsb-decode-options').classList.remove('hidden');
            } else if (method === 'PVD') {
                document.getElementById('pvd-decode-options').classList.remove('hidden');
            } else if (method === 'DCT') {
                document.getElementById('dct-decode-options').classList.remove('hidden');
            } else if (method === 'F5') {
                document.getElementById('f5-decode-options').classList.remove('hidden');
            } else if (method === 'SPREAD') {
                document.getElementById('spread-decode-options').classList.remove('hidden');
            } else if (method === 'PALETTE') {
                document.getElementById('palette-decode-options').classList.remove('hidden');
            } else if (method === 'CHROMA') {
                document.getElementById('chroma-decode-options').classList.remove('hidden');
            } else if (method === 'PNGCHUNK') {
                document.getElementById('pngchunk-decode-options').classList.remove('hidden');
            }
        }

        // ============== PALETTE STEGANOGRAPHY ==============
        // Median cut color quantization
        function quantizeColors(pixels, numColors) {
            // Extract unique colors
            const colorMap = new Map();
            for (let i = 0; i < pixels.length; i += 4) {
                const key = `${pixels[i]},${pixels[i+1]},${pixels[i+2]}`;
                colorMap.set(key, (colorMap.get(key) || 0) + 1);
            }

            // Convert to array of [r, g, b, count]
            let colors = Array.from(colorMap.entries()).map(([key, count]) => {
                const [r, g, b] = key.split(',').map(Number);
                return { r, g, b, count };
            });

            // Simple median cut quantization
            function medianCut(colors, depth) {
                if (depth === 0 || colors.length <= 1) {
                    // Return average color of this bucket
                    let tr = 0, tg = 0, tb = 0, tc = 0;
                    for (const c of colors) {
                        tr += c.r * c.count;
                        tg += c.g * c.count;
                        tb += c.b * c.count;
                        tc += c.count;
                    }
                    return [{ r: Math.round(tr/tc), g: Math.round(tg/tc), b: Math.round(tb/tc) }];
                }

                // Find dimension with greatest range
                let minR = 255, maxR = 0, minG = 255, maxG = 0, minB = 255, maxB = 0;
                for (const c of colors) {
                    minR = Math.min(minR, c.r); maxR = Math.max(maxR, c.r);
                    minG = Math.min(minG, c.g); maxG = Math.max(maxG, c.g);
                    minB = Math.min(minB, c.b); maxB = Math.max(maxB, c.b);
                }

                const rangeR = maxR - minR, rangeG = maxG - minG, rangeB = maxB - minB;
                let channel = 'r';
                if (rangeG >= rangeR && rangeG >= rangeB) channel = 'g';
                else if (rangeB >= rangeR && rangeB >= rangeG) channel = 'b';

                // Sort and split
                colors.sort((a, b) => a[channel] - b[channel]);
                const mid = Math.floor(colors.length / 2);

                return [
                    ...medianCut(colors.slice(0, mid), depth - 1),
                    ...medianCut(colors.slice(mid), depth - 1)
                ];
            }

            const depth = Math.ceil(Math.log2(numColors));
            let palette = medianCut(colors, depth);

            // Ensure we have exactly numColors
            while (palette.length < numColors) {
                palette.push(palette[palette.length - 1]);
            }
            palette = palette.slice(0, numColors);

            return palette;
        }

        // Find closest palette index for a color
        function findClosestPaletteIndex(r, g, b, palette) {
            let minDist = Infinity, bestIdx = 0;
            for (let i = 0; i < palette.length; i++) {
                const p = palette[i];
                const dist = (r - p.r) ** 2 + (g - p.g) ** 2 + (b - p.b) ** 2;
                if (dist < minDist) {
                    minDist = dist;
                    bestIdx = i;
                }
            }
            return bestIdx;
        }

        async function paletteEncode(canvas, data, numColors = 256, mode = 'index') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Create header: PLTE magic + data length
            const header = new Uint8Array(8);
            header[0] = 0x50; header[1] = 0x4C; header[2] = 0x54; header[3] = 0x45; // "PLTE"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(header.length + data.length);
            fullData.set(header);
            fullData.set(data, header.length);

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let j = 7; j >= 0; j--) {
                    bits.push((fullData[i] >> j) & 1);
                }
            }

            // Quantize image to palette
            let palette = quantizeColors(pixels, numColors);

            // Sort palette by luminance then R, G, B for consistent ordering with decoder
            palette.sort((a, b) => {
                const lum1 = 0.299 * a.r + 0.587 * a.g + 0.114 * a.b;
                const lum2 = 0.299 * b.r + 0.587 * b.g + 0.114 * b.b;
                if (lum1 !== lum2) return lum1 - lum2;
                if (a.r !== b.r) return a.r - b.r;
                if (a.g !== b.g) return a.g - b.g;
                return a.b - b.b;
            });

            // Create index map
            const indices = new Uint8Array(totalPixels);
            for (let i = 0; i < totalPixels; i++) {
                const idx = i * 4;
                indices[i] = findClosestPaletteIndex(pixels[idx], pixels[idx+1], pixels[idx+2], palette);
            }

            if (mode === 'index') {
                // Encode in LSB of palette indices
                // Need pairs of similar colors to switch between
                const capacity = totalPixels;
                if (bits.length > capacity) {
                    throw new Error(`Palette capacity exceeded: need ${bits.length} bits, have ${capacity}`);
                }

                // Modify indices to encode bits (using index parity)
                for (let i = 0; i < bits.length; i++) {
                    const currentParity = indices[i] & 1;
                    if (currentParity !== bits[i]) {
                        // Need to flip parity - find nearest index with correct parity
                        const currentIdx = indices[i];

                        // Find closest color with opposite parity
                        let bestIdx = currentIdx ^ 1; // Simple flip
                        if (bestIdx >= palette.length) bestIdx = currentIdx > 0 ? currentIdx - 1 : 1;
                        indices[i] = bestIdx;
                    }
                }
            } else {
                // Order mode - more complex, skip for now
                throw new Error('Palette ordering mode not yet implemented');
            }

            // Apply modified indices back to pixels
            for (let i = 0; i < totalPixels; i++) {
                const idx = i * 4;
                const color = palette[indices[i]];
                pixels[idx] = color.r;
                pixels[idx + 1] = color.g;
                pixels[idx + 2] = color.b;
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        async function paletteDecode(canvas, mode = 'index') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            if (mode === 'index') {
                // Extract unique colors and sort them deterministically
                // This must match the order used by paletteEncode after quantization
                const colorSet = new Set();
                for (let i = 0; i < totalPixels; i++) {
                    const idx = i * 4;
                    const key = `${pixels[idx]},${pixels[idx+1]},${pixels[idx+2]}`;
                    colorSet.add(key);
                }

                // Sort colors by luminance, then R, G, B for consistent ordering
                const sortedColors = Array.from(colorSet).sort((a, b) => {
                    const [r1, g1, b1] = a.split(',').map(Number);
                    const [r2, g2, b2] = b.split(',').map(Number);
                    const lum1 = 0.299 * r1 + 0.587 * g1 + 0.114 * b1;
                    const lum2 = 0.299 * r2 + 0.587 * g2 + 0.114 * b2;
                    if (lum1 !== lum2) return lum1 - lum2;
                    if (r1 !== r2) return r1 - r2;
                    if (g1 !== g2) return g1 - g2;
                    return b1 - b2;
                });

                // Build color to index map
                const colorMap = new Map();
                sortedColors.forEach((key, idx) => colorMap.set(key, idx));

                // Extract bits based on color index parity
                const bits = [];
                for (let i = 0; i < totalPixels; i++) {
                    const idx = i * 4;
                    const key = `${pixels[idx]},${pixels[idx+1]},${pixels[idx+2]}`;
                    const colorIdx = colorMap.get(key);
                    bits.push(colorIdx & 1);
                }

                // Convert bits to bytes
                const bytes = [];
                for (let i = 0; i + 7 < bits.length; i += 8) {
                    let byte = 0;
                    for (let j = 0; j < 8; j++) {
                        byte = (byte << 1) | bits[i + j];
                    }
                    bytes.push(byte);
                }

                // Check for PLTE header
                if (bytes[0] !== 0x50 || bytes[1] !== 0x4C || bytes[2] !== 0x54 || bytes[3] !== 0x45) {
                    throw new Error('No palette steganography header found');
                }

                const dataLength = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

                if (dataLength > bytes.length - 8 || dataLength < 0) {
                    throw new Error('Invalid palette data length');
                }

                return new Uint8Array(bytes.slice(8, 8 + dataLength));
            } else {
                throw new Error('Palette ordering mode not yet implemented');
            }
        }

        // ============== DCT STEGANOGRAPHY ==============
        // DCT basis matrix for 8x8 blocks
        function createDCTMatrix(n) {
            const matrix = [];
            for (let i = 0; i < n; i++) {
                matrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (i === 0) {
                        matrix[i][j] = 1 / Math.sqrt(n);
                    } else {
                        matrix[i][j] = Math.sqrt(2 / n) * Math.cos(((2 * j + 1) * i * Math.PI) / (2 * n));
                    }
                }
            }
            return matrix;
        }

        // Apply 2D DCT to a block
        function dct2D(block, dctMatrix) {
            const n = block.length;
            const temp = Array(n).fill(0).map(() => Array(n).fill(0));
            const result = Array(n).fill(0).map(() => Array(n).fill(0));

            // Apply DCT to rows
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += dctMatrix[j][k] * block[i][k];
                    }
                    temp[i][j] = sum;
                }
            }

            // Apply DCT to columns
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += dctMatrix[i][k] * temp[k][j];
                    }
                    result[i][j] = sum;
                }
            }

            return result;
        }

        // Apply inverse 2D DCT
        function idct2D(block, dctMatrix) {
            const n = block.length;
            const temp = Array(n).fill(0).map(() => Array(n).fill(0));
            const result = Array(n).fill(0).map(() => Array(n).fill(0));

            // Transpose DCT matrix for inverse
            const dctT = Array(n).fill(0).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    dctT[i][j] = dctMatrix[j][i];
                }
            }

            // Apply inverse DCT to columns
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += dctT[i][k] * block[k][j];
                    }
                    temp[i][j] = sum;
                }
            }

            // Apply inverse DCT to rows
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += dctT[j][k] * temp[i][k];
                    }
                    result[i][j] = sum;
                }
            }

            return result;
        }

        // Mid-frequency coefficient positions for embedding (zig-zag order, avoiding DC and high-freq)
        const DCT_EMBED_POSITIONS = [
            [0, 1], [1, 0], [2, 0], [1, 1], [0, 2], [0, 3], [1, 2], [2, 1], [3, 0],
            [3, 1], [2, 2], [1, 3], [2, 3], [3, 2], [3, 3]
        ];

        async function dctEncode(canvas, data, robustness = 'medium', blockSize = 8) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            const dctMatrix = createDCTMatrix(blockSize);

            // Determine embedding strength based on robustness
            const strength = robustness === 'low' ? 10 : robustness === 'medium' ? 25 : 50;

            // Create header: DCTS magic + data length + data
            const header = new Uint8Array(8);
            header[0] = 0x44; header[1] = 0x43; header[2] = 0x54; header[3] = 0x53; // "DCTS"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(header.length + data.length);
            fullData.set(header);
            fullData.set(data, header.length);

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let j = 7; j >= 0; j--) {
                    bits.push((fullData[i] >> j) & 1);
                }
            }

            // Calculate capacity (one bit per block for robustness)
            const blocksX = Math.floor(canvas.width / blockSize);
            const blocksY = Math.floor(canvas.height / blockSize);
            const capacity = blocksX * blocksY;

            if (bits.length > capacity) {
                throw new Error(`DCT capacity exceeded: need ${bits.length} bits, have ${capacity}`);
            }

            let bitIdx = 0;

            // Process each block
            for (let by = 0; by < blocksY && bitIdx < bits.length; by++) {
                for (let bx = 0; bx < blocksX && bitIdx < bits.length; bx++) {
                    // Extract luminance block
                    const block = [];
                    for (let y = 0; y < blockSize; y++) {
                        block[y] = [];
                        for (let x = 0; x < blockSize; x++) {
                            const px = (by * blockSize + y) * canvas.width + (bx * blockSize + x);
                            const idx = px * 4;
                            // Use luminance (Y = 0.299R + 0.587G + 0.114B)
                            block[y][x] = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                        }
                    }

                    // Apply DCT
                    const dctBlock = dct2D(block, dctMatrix);

                    // Embed bit in mid-frequency coefficient
                    const [cy, cx] = DCT_EMBED_POSITIONS[0]; // Use first mid-frequency position
                    const bit = bits[bitIdx++];

                    // Quantize coefficient using floor for consistent encode/decode
                    const coeff = dctBlock[cy][cx];
                    const q = Math.floor(coeff / strength);
                    // Place bit in lower quarter (0.25) for 0, upper quarter (0.75) for 1
                    dctBlock[cy][cx] = (q + (bit ? 0.75 : 0.25)) * strength;

                    // Apply inverse DCT
                    const reconstructed = idct2D(dctBlock, dctMatrix);

                    // Write back to pixels (adjust RGB to match new luminance)
                    for (let y = 0; y < blockSize; y++) {
                        for (let x = 0; x < blockSize; x++) {
                            const px = (by * blockSize + y) * canvas.width + (bx * blockSize + x);
                            const idx = px * 4;

                            const oldLum = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                            const newLum = Math.max(0, Math.min(255, reconstructed[y][x]));
                            const ratio = oldLum > 0 ? newLum / oldLum : 1;

                            pixels[idx] = Math.max(0, Math.min(255, Math.round(pixels[idx] * ratio)));
                            pixels[idx + 1] = Math.max(0, Math.min(255, Math.round(pixels[idx + 1] * ratio)));
                            pixels[idx + 2] = Math.max(0, Math.min(255, Math.round(pixels[idx + 2] * ratio)));
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        async function dctDecode(canvas, blockSize = 8) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            const dctMatrix = createDCTMatrix(blockSize);

            const blocksX = Math.floor(canvas.width / blockSize);
            const blocksY = Math.floor(canvas.height / blockSize);

            const bits = [];

            // Extract bits from each block
            for (let by = 0; by < blocksY; by++) {
                for (let bx = 0; bx < blocksX; bx++) {
                    // Extract luminance block
                    const block = [];
                    for (let y = 0; y < blockSize; y++) {
                        block[y] = [];
                        for (let x = 0; x < blockSize; x++) {
                            const px = (by * blockSize + y) * canvas.width + (bx * blockSize + x);
                            const idx = px * 4;
                            block[y][x] = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                        }
                    }

                    // Apply DCT
                    const dctBlock = dct2D(block, dctMatrix);

                    // Extract bit from mid-frequency coefficient
                    const [cy, cx] = DCT_EMBED_POSITIONS[0];
                    const coeff = dctBlock[cy][cx];

                    // Decode: use floor quantization matching encode
                    // Check if remainder is in upper half (>=0.5) or lower half (<0.5)
                    const strength = 50; // Match encode 'high' robustness
                    const q = Math.floor(coeff / strength);
                    const remainder = coeff - q * strength;
                    bits.push(remainder >= strength / 2 ? 1 : 0);
                }
            }

            // Convert bits to bytes
            const bytes = [];
            for (let i = 0; i + 7 < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }

            // Check for DCTS header
            if (bytes[0] !== 0x44 || bytes[1] !== 0x43 || bytes[2] !== 0x54 || bytes[3] !== 0x53) {
                throw new Error('No DCT steganography header found');
            }

            const dataLength = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

            if (dataLength > bytes.length - 8 || dataLength < 0) {
                throw new Error('Invalid DCT data length');
            }

            return new Uint8Array(bytes.slice(8, 8 + dataLength));
        }

        // ============== SPREAD SPECTRUM STEGANOGRAPHY ==============
        // Simple seeded PRNG (Mulberry32)
        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Hash password to seed
        function hashPassword(password) {
            let hash = 0;
            for (let i = 0; i < password.length; i++) {
                const char = password.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        async function spreadEncode(canvas, data, password, spreadFactor = 16, strength = 2) {
            if (!password) {
                throw new Error('Password required for spread spectrum encoding');
            }

            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Create header: SPRD magic + data length + data
            const header = new Uint8Array(8);
            header[0] = 0x53; header[1] = 0x50; header[2] = 0x52; header[3] = 0x44; // "SPRD"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(header.length + data.length);
            fullData.set(header);
            fullData.set(data, header.length);

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let j = 7; j >= 0; j--) {
                    bits.push((fullData[i] >> j) & 1);
                }
            }

            // Check capacity
            const capacity = Math.floor(totalPixels / spreadFactor);
            if (bits.length > capacity) {
                throw new Error(`Spread spectrum capacity exceeded: need ${bits.length} bits, have ${capacity}`);
            }

            // Initialize PRNG with password
            const rng = mulberry32(hashPassword(password));

            // Track which pixels we've used to avoid overwrites
            const used = new Set();

            // Encode each bit across spread pixels using LSB with polarity
            for (let bitIdx = 0; bitIdx < bits.length; bitIdx++) {
                const bit = bits[bitIdx];

                // Spread this bit across multiple pixels
                for (let s = 0; s < spreadFactor; s++) {
                    let pixelIdx, idx;
                    // Find unused pixel
                    do {
                        pixelIdx = Math.floor(rng() * totalPixels);
                    } while (used.has(pixelIdx) && used.size < totalPixels);
                    used.add(pixelIdx);

                    const channel = Math.floor(rng() * 3); // R, G, or B
                    const polarity = rng() > 0.5 ? 1 : 0;

                    idx = pixelIdx * 4 + channel;

                    // Encode: if bit matches polarity, set LSB to 1; otherwise 0
                    const targetLSB = bit === polarity ? 1 : 0;
                    pixels[idx] = (pixels[idx] & 0xFE) | targetLSB;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        async function spreadDecode(canvas, password, spreadFactor = 16) {
            if (!password) {
                throw new Error('Password required for spread spectrum decoding');
            }

            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Initialize PRNG with same password
            const rng = mulberry32(hashPassword(password));

            // Track which pixels we've used (must match encoder)
            const used = new Set();

            // First read header (8 bytes = 64 bits)
            const capacity = Math.floor(totalPixels / spreadFactor);
            const maxBits = Math.min(capacity, 65536 * 8); // Limit to 64KB

            const decodedBits = [];

            // Decode bits using majority vote across spread pixels
            for (let bitIdx = 0; bitIdx < maxBits; bitIdx++) {
                let votes = 0;

                // Read from spread pixels
                for (let s = 0; s < spreadFactor; s++) {
                    let pixelIdx;
                    // Find same pixels as encoder
                    do {
                        pixelIdx = Math.floor(rng() * totalPixels);
                    } while (used.has(pixelIdx) && used.size < totalPixels);
                    used.add(pixelIdx);

                    const channel = Math.floor(rng() * 3);
                    const polarity = rng() > 0.5 ? 1 : 0;

                    const idx = pixelIdx * 4 + channel;
                    const lsb = pixels[idx] & 1;

                    // Decode: if LSB is 1, bit matched polarity; if 0, bit didn't match
                    const decodedBit = lsb === 1 ? polarity : (1 - polarity);
                    votes += decodedBit;
                }

                // Majority vote
                decodedBits.push(votes > spreadFactor / 2 ? 1 : 0);

                // Check header after 64 bits
                if (bitIdx === 63) {
                    const headerBytes = [];
                    for (let i = 0; i < 8; i++) {
                        let byte = 0;
                        for (let j = 0; j < 8; j++) {
                            byte = (byte << 1) | decodedBits[i * 8 + j];
                        }
                        headerBytes.push(byte);
                    }

                    // Check for SPRD magic
                    if (headerBytes[0] !== 0x53 || headerBytes[1] !== 0x50 ||
                        headerBytes[2] !== 0x52 || headerBytes[3] !== 0x44) {
                        throw new Error('No spread spectrum header found (wrong password?)');
                    }

                    // Get data length and only read what we need
                    const dataLength = (headerBytes[4] << 24) | (headerBytes[5] << 16) |
                                       (headerBytes[6] << 8) | headerBytes[7];
                    if (dataLength < 0 || dataLength > 65536) {
                        throw new Error('Invalid spread spectrum data length');
                    }

                    // Calculate total bits needed (header + data)
                    const totalBitsNeeded = 64 + dataLength * 8;
                    if (totalBitsNeeded > maxBits) {
                        throw new Error('Data length exceeds capacity');
                    }
                }
            }

            // Convert bits to bytes
            const bytes = [];
            for (let i = 0; i + 7 < decodedBits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | decodedBits[i + j];
                }
                bytes.push(byte);
            }

            const dataLength = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

            return new Uint8Array(bytes.slice(8, 8 + dataLength));
        }

        // ============== CHROMA STEGANOGRAPHY ==============
        // RGB to YCbCr conversion
        function rgbToYCbCr(r, g, b) {
            const y  = 0.299 * r + 0.587 * g + 0.114 * b;
            const cb = 128 - 0.168736 * r - 0.331264 * g + 0.5 * b;
            const cr = 128 + 0.5 * r - 0.418688 * g - 0.081312 * b;
            return { y, cb, cr };
        }

        // YCbCr to RGB conversion
        function ycbcrToRgb(y, cb, cr) {
            const r = y + 1.402 * (cr - 128);
            const g = y - 0.344136 * (cb - 128) - 0.714136 * (cr - 128);
            const b = y + 1.772 * (cb - 128);
            return {
                r: Math.max(0, Math.min(255, Math.round(r))),
                g: Math.max(0, Math.min(255, Math.round(g))),
                b: Math.max(0, Math.min(255, Math.round(b)))
            };
        }

        async function chromaEncode(canvas, data, colorSpace = 'ycbcr', channel = 'both', intensity = 2, pattern = 'sequential') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Create header: CHRM magic + data length
            const header = new Uint8Array(8);
            header[0] = 0x43; header[1] = 0x48; header[2] = 0x52; header[3] = 0x4D; // "CHRM"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(header.length + data.length);
            fullData.set(header);
            fullData.set(data, header.length);

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let j = 7; j >= 0; j--) {
                    bits.push((fullData[i] >> j) & 1);
                }
            }

            // Calculate capacity based on channel selection
            const bitsPerPixel = channel === 'both' ? 2 : 1;
            const capacity = totalPixels * bitsPerPixel;

            if (bits.length > capacity) {
                throw new Error(`Chroma capacity exceeded: need ${bits.length} bits, have ${capacity}`);
            }

            // Generate pixel order based on pattern
            let pixelOrder = [];
            if (pattern === 'checkerboard') {
                // Checkerboard pattern - alternating pixels
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if ((x + y) % 2 === 0) pixelOrder.push(y * canvas.width + x);
                    }
                }
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if ((x + y) % 2 === 1) pixelOrder.push(y * canvas.width + x);
                    }
                }
            } else if (pattern === 'edges') {
                // Prefer edges/high variance areas (simplified: use every other scanline first)
                for (let y = 0; y < canvas.height; y += 2) {
                    for (let x = 0; x < canvas.width; x++) {
                        pixelOrder.push(y * canvas.width + x);
                    }
                }
                for (let y = 1; y < canvas.height; y += 2) {
                    for (let x = 0; x < canvas.width; x++) {
                        pixelOrder.push(y * canvas.width + x);
                    }
                }
            } else {
                // Sequential
                for (let i = 0; i < totalPixels; i++) pixelOrder.push(i);
            }

            // Encode bits using LSB of color channels that affect chrominance
            // Blue channel primarily affects Cb (chrominance blue)
            // Red channel primarily affects Cr (chrominance red)
            // We use multiple LSBs based on intensity for stronger embedding
            const bitsToUse = Math.min(intensity, 4); // Use 1-4 LSBs based on intensity

            let bitIdx = 0;
            for (const pixelIdx of pixelOrder) {
                if (bitIdx >= bits.length) break;

                const idx = pixelIdx * 4;

                // Cb channel - modify Blue (index 2)
                if (channel === 'both' || channel === 'cb') {
                    if (bitIdx < bits.length) {
                        const bit = bits[bitIdx++];
                        // Use LSB encoding on blue channel
                        pixels[idx + 2] = (pixels[idx + 2] & 0xFE) | bit;
                    }
                }

                // Cr channel - modify Red (index 0)
                if (channel === 'both' || channel === 'cr') {
                    if (bitIdx < bits.length) {
                        const bit = bits[bitIdx++];
                        // Use LSB encoding on red channel
                        pixels[idx] = (pixels[idx] & 0xFE) | bit;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // ============== ZERO-WIDTH UNICODE STEGANOGRAPHY ==============
        const ZWSP = '\u200B';  // Zero-width space = 0
        const ZWNJ = '\u200C';  // Zero-width non-joiner = 1
        const ZWJ = '\u200D';   // Zero-width joiner = delimiter

        function toggleZeroWidth() {
            const toggle = document.getElementById('zerowidth-toggle');
            const coverInput = document.getElementById('zerowidth-cover-input');
            const secretInput = document.getElementById('encode-text');
            const hint = document.getElementById('zerowidth-hint');

            if (toggle.checked) {
                coverInput.classList.remove('hidden');
                hint.style.display = 'inline';
                secretInput.style.opacity = '0.15';
                secretInput.style.transition = 'opacity 0.3s';
            } else {
                coverInput.classList.add('hidden');
                hint.style.display = 'none';
                secretInput.style.opacity = '1';
                document.getElementById('zerowidth-result').classList.add('hidden');
            }
        }

        function encodeZeroWidth() {
            const secret = document.getElementById('encode-text').value;
            const cover = document.getElementById('zerowidth-cover').value;

            if (!secret) {
                notify('Enter a secret message first!', 'error');
                return;
            }
            if (!cover) {
                notify('Enter cover text to hide the message in!', 'error');
                return;
            }

            // Convert secret to binary
            const secretBytes = new TextEncoder().encode(secret);
            let binaryStr = '';
            for (const byte of secretBytes) {
                binaryStr += byte.toString(2).padStart(8, '0');
            }

            // Convert binary to zero-width characters
            let zwString = ZWJ; // Start delimiter
            for (const bit of binaryStr) {
                zwString += bit === '0' ? ZWSP : ZWNJ;
            }
            zwString += ZWJ; // End delimiter

            // Insert zero-width string into cover text
            // Strategy: insert after first character, or at start if cover is short
            let stegoText;
            if (cover.length > 1) {
                stegoText = cover[0] + zwString + cover.slice(1);
            } else {
                stegoText = zwString + cover;
            }

            document.getElementById('zerowidth-output').value = stegoText;
            document.getElementById('zerowidth-result').classList.remove('hidden');
            notify(`Encoded ${secret.length} chars into ${cover.length} visible chars!`, 'success');
        }

        function decodeZeroWidth(text) {
            // Find content between ZWJ delimiters
            const startIdx = text.indexOf(ZWJ);
            if (startIdx === -1) return null;

            const endIdx = text.indexOf(ZWJ, startIdx + 1);
            if (endIdx === -1) return null;

            const zwContent = text.slice(startIdx + 1, endIdx);

            // Convert zero-width chars back to binary
            let binaryStr = '';
            for (const char of zwContent) {
                if (char === ZWSP) binaryStr += '0';
                else if (char === ZWNJ) binaryStr += '1';
            }

            // Convert binary to bytes
            const bytes = [];
            for (let i = 0; i < binaryStr.length; i += 8) {
                const byteStr = binaryStr.slice(i, i + 8);
                if (byteStr.length === 8) {
                    bytes.push(parseInt(byteStr, 2));
                }
            }

            return new TextDecoder().decode(new Uint8Array(bytes));
        }

        function copyZeroWidthOutput() {
            const output = document.getElementById('zerowidth-output');
            output.select();
            document.execCommand('copy');
            notify('Copied to clipboard!', 'success');
        }

        // ============== TEXT LAB (Easter Egg) ==============
        let textLabClickCount = 0;
        let textLabClickTimer = null;
        let textLabUnlocked = false;

        function initTextLabEasterEgg() {
            const eggAnimation = document.getElementById('hatch-animation');
            if (eggAnimation) {
                eggAnimation.style.cursor = 'default'; // No hover indicator
                eggAnimation.addEventListener('click', handleEggClick);
            }
        }

        function handleEggClick(e) {
            e.stopPropagation();
            textLabClickCount++;

            if (textLabClickTimer) {
                clearTimeout(textLabClickTimer);
            }

            if (textLabClickCount >= 3) {
                if (!textLabUnlocked) {
                    activateTextLab();
                    textLabUnlocked = true;
                } else {
                    // Already unlocked, just switch to the tab
                    document.querySelector('.tab[data-tab="textlab"]').click();
                }
                textLabClickCount = 0;
            } else {
                textLabClickTimer = setTimeout(() => {
                    textLabClickCount = 0;
                }, 800); // Reset after 800ms (increased from 500ms)
            }
        }

        function activateTextLab() {
            const tabBtn = document.getElementById('textlab-tab-btn');
            if (tabBtn) {
                tabBtn.style.display = 'inline-block';
                // Small delay to ensure tab is visible before clicking
                setTimeout(() => {
                    tabBtn.click();
                }, 50);
            }
            notify('üî§ Text Lab unlocked! Hide messages in plain text.', 'success');
        }

        function updateTextLabMethod() {
            const method = document.getElementById('textlab-method').value;

            // Hide all descriptions
            document.querySelectorAll('.textlab-desc').forEach(el => el.classList.add('hidden'));

            // Show selected description
            document.getElementById(`textlab-desc-${method}`).classList.remove('hidden');
        }

        // Homoglyph mapping (Latin to similar-looking Unicode)
        const HOMOGLYPHS = {
            'a': '–∞', 'c': '—Å', 'e': '–µ', 'o': '–æ', 'p': '—Ä', 'x': '—Ö', 'y': '—É',
            'A': '–ê', 'B': '–í', 'C': '–°', 'E': '–ï', 'H': '–ù', 'K': '–ö', 'M': '–ú',
            'O': '–û', 'P': '–†', 'T': '–¢', 'X': '–•'
        };
        const HOMOGLYPHS_REVERSE = Object.fromEntries(
            Object.entries(HOMOGLYPHS).map(([k, v]) => [v, k])
        );

        function encodeHomoglyph(secret, cover) {
            // Convert secret to binary
            const secretBytes = new TextEncoder().encode(secret);
            let bits = '';
            for (const byte of secretBytes) {
                bits += byte.toString(2).padStart(8, '0');
            }

            // Add length prefix (16 bits)
            const lengthBits = secretBytes.length.toString(2).padStart(16, '0');
            bits = lengthBits + bits;

            let bitIndex = 0;
            let result = '';

            for (const char of cover) {
                if (bitIndex < bits.length && HOMOGLYPHS[char]) {
                    // Use homoglyph (1) or original (0)
                    result += bits[bitIndex] === '1' ? HOMOGLYPHS[char] : char;
                    bitIndex++;
                } else {
                    result += char;
                }
            }

            return { encoded: result, bitsUsed: bitIndex, bitsNeeded: bits.length };
        }

        function decodeHomoglyph(text) {
            let bits = '';

            for (const char of text) {
                if (HOMOGLYPHS_REVERSE[char]) {
                    bits += '1';
                } else if (HOMOGLYPHS[char]) {
                    bits += '0';
                }
                // Skip non-homoglyph chars
            }

            if (bits.length < 16) return null;

            // Extract length
            const length = parseInt(bits.slice(0, 16), 2);
            if (length <= 0 || length > 10000) return null;

            // Extract data
            const dataBits = bits.slice(16);
            const bytes = [];
            for (let i = 0; i < length * 8 && i < dataBits.length; i += 8) {
                const byteStr = dataBits.slice(i, i + 8);
                if (byteStr.length === 8) {
                    bytes.push(parseInt(byteStr, 2));
                }
            }

            return new TextDecoder().decode(new Uint8Array(bytes));
        }

        function encodeWhitespace(secret, cover) {
            // Convert secret to binary
            const secretBytes = new TextEncoder().encode(secret);
            let bits = '';
            for (const byte of secretBytes) {
                bits += byte.toString(2).padStart(8, '0');
            }

            // Add length prefix
            const lengthBits = secretBytes.length.toString(2).padStart(16, '0');
            bits = lengthBits + bits;

            // Split cover into lines
            const lines = cover.split('\n');
            let bitIndex = 0;
            const resultLines = [];

            for (const line of lines) {
                let trailing = '';
                // Add 8 bits per line as trailing whitespace
                for (let i = 0; i < 8 && bitIndex < bits.length; i++) {
                    trailing += bits[bitIndex] === '0' ? ' ' : '\t';
                    bitIndex++;
                }
                resultLines.push(line + trailing);
            }

            return { encoded: resultLines.join('\n'), bitsUsed: bitIndex, bitsNeeded: bits.length };
        }

        function decodeWhitespace(text) {
            const lines = text.split('\n');
            let bits = '';

            for (const line of lines) {
                // Extract trailing whitespace (spaces and tabs only)
                const match = line.match(/[ \t]+$/);
                if (match) {
                    for (const char of match[0]) {
                        bits += char === ' ' ? '0' : '1';
                    }
                }
            }

            if (bits.length < 16) return null;

            const length = parseInt(bits.slice(0, 16), 2);
            if (length <= 0 || length > 10000) return null;

            const dataBits = bits.slice(16);
            const bytes = [];
            for (let i = 0; i < length * 8 && i < dataBits.length; i += 8) {
                const byteStr = dataBits.slice(i, i + 8);
                if (byteStr.length === 8) {
                    bytes.push(parseInt(byteStr, 2));
                }
            }

            return new TextDecoder().decode(new Uint8Array(bytes));
        }

        // Unicode Tag Characters (U+E0000-U+E007F) - invisible tag chars
        const TAG_BASE = 0xE0000;

        function encodeInvisibleInk(secret, cover) {
            // Convert each char of secret to tag character
            let tagString = String.fromCodePoint(TAG_BASE); // Start tag

            for (const char of secret) {
                const code = char.charCodeAt(0);
                if (code < 128) {
                    // ASCII - direct mapping to tag range
                    tagString += String.fromCodePoint(TAG_BASE + code);
                }
            }

            tagString += String.fromCodePoint(TAG_BASE + 0x7F); // End tag (DELETE)

            // Insert after first char of cover
            if (cover.length > 1) {
                return cover[0] + tagString + cover.slice(1);
            }
            return tagString + cover;
        }

        function decodeInvisibleInk(text) {
            let result = '';
            let inTag = false;

            for (const char of text) {
                const code = char.codePointAt(0);

                if (code === TAG_BASE) {
                    inTag = true;
                    continue;
                }

                if (code === TAG_BASE + 0x7F) {
                    break;
                }

                if (inTag && code >= TAG_BASE && code < TAG_BASE + 128) {
                    result += String.fromCharCode(code - TAG_BASE);
                }
            }

            return result || null;
        }

        function textLabEncode() {
            const method = document.getElementById('textlab-method').value;
            const secret = document.getElementById('textlab-secret').value;
            const cover = document.getElementById('textlab-cover').value;

            console.log('TextLab encode - method:', method, 'secret length:', secret?.length, 'cover length:', cover?.length);

            if (!secret) {
                notify('Enter a secret message!', 'error');
                return;
            }
            if (!cover) {
                notify('Enter cover text!', 'error');
                return;
            }

            let result = '';
            let stats = '';

            try {
                if (method === 'zerowidth') {
                    console.log('Encoding zero-width...');
                    // Use existing zero-width encode
                    const secretBytes = new TextEncoder().encode(secret);
                    let binaryStr = '';
                    for (const byte of secretBytes) {
                        binaryStr += byte.toString(2).padStart(8, '0');
                    }

                    let zwString = ZWJ;
                    for (const bit of binaryStr) {
                        zwString += bit === '0' ? ZWSP : ZWNJ;
                    }
                    zwString += ZWJ;

                    result = cover.length > 1 ? cover[0] + zwString + cover.slice(1) : zwString + cover;
                    stats = `${secret.length} chars hidden in ${cover.length} visible chars`;

                } else if (method === 'homoglyph') {
                    console.log('Encoding homoglyph...');
                    const encoded = encodeHomoglyph(secret, cover);
                    console.log('Homoglyph encoded:', encoded);
                    result = encoded.encoded;
                    if (encoded.bitsUsed < encoded.bitsNeeded) {
                        notify(`Warning: Cover text too short! Only ${Math.floor(encoded.bitsUsed/8)} of ${Math.ceil(encoded.bitsNeeded/8)} bytes encoded.`, 'warning');
                    }
                    stats = `${encoded.bitsUsed}/${encoded.bitsNeeded} bits encoded via homoglyphs`;

                } else if (method === 'whitespace') {
                    console.log('Encoding whitespace...');
                    const encoded = encodeWhitespace(secret, cover);
                    console.log('Whitespace encoded:', encoded);
                    result = encoded.encoded;
                    if (encoded.bitsUsed < encoded.bitsNeeded) {
                        notify(`Warning: Need more lines! Only ${Math.floor(encoded.bitsUsed/8)} of ${Math.ceil(encoded.bitsNeeded/8)} bytes encoded.`, 'warning');
                    }
                    stats = `${encoded.bitsUsed}/${encoded.bitsNeeded} bits in trailing whitespace`;

                } else if (method === 'invisible') {
                    console.log('Encoding invisible ink...');
                    result = encodeInvisibleInk(secret, cover);
                    stats = `${secret.length} chars hidden as Unicode tags`;
                }

                console.log('Encode result length:', result?.length, 'stats:', stats);

                if (result) {
                    document.getElementById('textlab-output').value = result;
                    document.getElementById('textlab-stats').textContent = stats;
                    notify('Encoded successfully!', 'success');
                } else {
                    notify('Encoding produced no result. Try different inputs.', 'error');
                }

            } catch (e) {
                console.error('TextLab encode error:', e);
                notify('Encoding failed: ' + e.message, 'error');
            }
        }

        function textLabDecode() {
            const method = document.getElementById('textlab-method').value;
            const input = document.getElementById('textlab-decode-input').value;

            console.log('TextLab decode - method:', method, 'input length:', input?.length);

            if (!input) {
                notify('Paste stego text in the decode input!', 'error');
                return;
            }

            let result = null;

            try {
                if (method === 'zerowidth') {
                    console.log('Decoding zero-width...');
                    result = decodeZeroWidth(input);
                } else if (method === 'homoglyph') {
                    console.log('Decoding homoglyph...');
                    result = decodeHomoglyph(input);
                } else if (method === 'whitespace') {
                    console.log('Decoding whitespace...');
                    result = decodeWhitespace(input);
                } else if (method === 'invisible') {
                    console.log('Decoding invisible ink...');
                    result = decodeInvisibleInk(input);
                }

                console.log('Decode result:', result);

                if (result) {
                    document.getElementById('textlab-decode-output').value = result;
                    document.getElementById('textlab-decode-stats').textContent = `Decoded ${result.length} chars`;
                    notify('Decoded successfully!', 'success');
                } else {
                    document.getElementById('textlab-decode-output').value = '';
                    document.getElementById('textlab-decode-stats').textContent = '';
                    notify('No hidden data found with this method.', 'warning');
                }

            } catch (e) {
                console.error('TextLab decode error:', e);
                notify('Decoding failed: ' + e.message, 'error');
            }
        }

        function copyTextLabOutput() {
            const output = document.getElementById('textlab-output');
            output.select();
            document.execCommand('copy');
            notify('Copied to clipboard!', 'success');
        }

        function copyTextLabDecodeOutput() {
            const output = document.getElementById('textlab-decode-output');
            output.select();
            document.execCommand('copy');
            notify('Copied to clipboard!', 'success');
        }

        function clearTextLab() {
            document.getElementById('textlab-secret').value = '';
            document.getElementById('textlab-cover').value = '';
            document.getElementById('textlab-output').value = '';
            document.getElementById('textlab-decode-input').value = '';
            document.getElementById('textlab-decode-output').value = '';
            document.getElementById('textlab-stats').textContent = '';
            document.getElementById('textlab-decode-stats').textContent = '';
        }

        // ============== PVD (PIXEL VALUE DIFFERENCING) ==============
        // Range tables for PVD
        const PVD_RANGES = {
            'wu-tsai': [
                { lower: 0, upper: 7, bits: 3 },
                { lower: 8, upper: 15, bits: 3 },
                { lower: 16, upper: 31, bits: 4 },
                { lower: 32, upper: 63, bits: 5 },
                { lower: 64, upper: 127, bits: 6 },
                { lower: 128, upper: 255, bits: 7 }
            ],
            'wide': [
                { lower: 0, upper: 15, bits: 4 },
                { lower: 16, upper: 47, bits: 5 },
                { lower: 48, upper: 111, bits: 6 },
                { lower: 112, upper: 255, bits: 7 }
            ],
            'narrow': [
                { lower: 0, upper: 3, bits: 2 },
                { lower: 4, upper: 7, bits: 2 },
                { lower: 8, upper: 15, bits: 3 },
                { lower: 16, upper: 31, bits: 4 },
                { lower: 32, upper: 63, bits: 5 },
                { lower: 64, upper: 127, bits: 6 },
                { lower: 128, upper: 255, bits: 7 }
            ]
        };

        function findPvdRange(diff, ranges) {
            const absDiff = Math.abs(diff);
            for (const range of ranges) {
                if (absDiff >= range.lower && absDiff <= range.upper) {
                    return range;
                }
            }
            return ranges[ranges.length - 1];
        }

        async function pvdEncode(canvas, data, direction = 'horizontal', rangeType = 'wu-tsai') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const ranges = PVD_RANGES[rangeType];

            // Prepare data with length header
            const dataWithHeader = new Uint8Array(4 + data.length);
            const view = new DataView(dataWithHeader.buffer);
            view.setUint32(0, data.length);
            dataWithHeader.set(data, 4);

            // Convert to bits
            let bits = [];
            for (const byte of dataWithHeader) {
                for (let i = 7; i >= 0; i--) {
                    bits.push((byte >> i) & 1);
                }
            }

            let bitIndex = 0;

            // Process pixel pairs
            const processDirection = (getPixelPair, setPixelPair, pairCount) => {
                for (let i = 0; i < pairCount && bitIndex < bits.length; i++) {
                    const [idx1, idx2] = getPixelPair(i);
                    if (idx1 === null || idx2 === null) continue;

                    // Process each color channel (R, G, B)
                    for (let c = 0; c < 3 && bitIndex < bits.length; c++) {
                        const p1 = pixels[idx1 * 4 + c];
                        const p2 = pixels[idx2 * 4 + c];
                        const diff = p1 - p2;
                        const range = findPvdRange(diff, ranges);

                        // Extract bits to embed
                        const bitsToEmbed = Math.min(range.bits, bits.length - bitIndex);
                        if (bitsToEmbed <= 0) continue;

                        let embedValue = 0;
                        for (let b = 0; b < bitsToEmbed; b++) {
                            embedValue = (embedValue << 1) | bits[bitIndex++];
                        }
                        // Pad with zeros if we couldn't get enough bits
                        embedValue <<= (range.bits - bitsToEmbed);

                        // Calculate new difference
                        const newDiff = range.lower + embedValue;
                        const signedNewDiff = diff >= 0 ? newDiff : -newDiff;

                        // Calculate new pixel values
                        const diffChange = signedNewDiff - diff;
                        let newP1 = p1 + Math.ceil(diffChange / 2);
                        let newP2 = p2 - Math.floor(diffChange / 2);

                        // Clamp to valid range
                        newP1 = Math.max(0, Math.min(255, newP1));
                        newP2 = Math.max(0, Math.min(255, newP2));

                        pixels[idx1 * 4 + c] = newP1;
                        pixels[idx2 * 4 + c] = newP2;
                    }
                }
            };

            if (direction === 'horizontal' || direction === 'both') {
                const pairCount = Math.floor(width / 2) * height;
                processDirection(
                    (i) => {
                        const row = Math.floor(i / Math.floor(width / 2));
                        const col = (i % Math.floor(width / 2)) * 2;
                        return [row * width + col, row * width + col + 1];
                    },
                    null,
                    pairCount
                );
            }

            if (direction === 'vertical' || direction === 'both') {
                const pairCount = width * Math.floor(height / 2);
                processDirection(
                    (i) => {
                        const col = i % width;
                        const row = Math.floor(i / width) * 2;
                        if (row + 1 >= height) return [null, null];
                        return [row * width + col, (row + 1) * width + col];
                    },
                    null,
                    pairCount
                );
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        async function pvdDecode(canvas, direction = 'horizontal', rangeType = 'wu-tsai') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            const ranges = PVD_RANGES[rangeType];

            let bits = [];

            const processDirection = (getPixelPair, pairCount, maxBits) => {
                for (let i = 0; i < pairCount && bits.length < maxBits; i++) {
                    const [idx1, idx2] = getPixelPair(i);
                    if (idx1 === null || idx2 === null) continue;

                    for (let c = 0; c < 3 && bits.length < maxBits; c++) {
                        const p1 = pixels[idx1 * 4 + c];
                        const p2 = pixels[idx2 * 4 + c];
                        const diff = Math.abs(p1 - p2);
                        const range = findPvdRange(diff, ranges);

                        const embedValue = diff - range.lower;
                        for (let b = range.bits - 1; b >= 0; b--) {
                            bits.push((embedValue >> b) & 1);
                        }
                    }
                }
            };

            // First pass - get enough bits for header (32 bits)
            if (direction === 'horizontal' || direction === 'both') {
                const pairCount = Math.floor(width / 2) * height;
                processDirection(
                    (i) => {
                        const row = Math.floor(i / Math.floor(width / 2));
                        const col = (i % Math.floor(width / 2)) * 2;
                        return [row * width + col, row * width + col + 1];
                    },
                    pairCount,
                    32 + 8 * 65536 // Header + max reasonable data
                );
            }

            if ((direction === 'vertical' || direction === 'both') && bits.length < 32) {
                const pairCount = width * Math.floor(height / 2);
                processDirection(
                    (i) => {
                        const col = i % width;
                        const row = Math.floor(i / width) * 2;
                        if (row + 1 >= height) return [null, null];
                        return [row * width + col, (row + 1) * width + col];
                    },
                    pairCount,
                    32 + 8 * 65536
                );
            }

            // Extract length from header
            if (bits.length < 32) return null;

            let length = 0;
            for (let i = 0; i < 32; i++) {
                length = (length << 1) | bits[i];
            }

            if (length <= 0 || length > 1000000) return null;

            // Extract data bytes
            const dataBytes = new Uint8Array(length);
            for (let i = 0; i < length; i++) {
                let byte = 0;
                for (let b = 0; b < 8; b++) {
                    const bitIdx = 32 + i * 8 + b;
                    if (bitIdx < bits.length) {
                        byte = (byte << 1) | bits[bitIdx];
                    }
                }
                dataBytes[i] = byte;
            }

            return dataBytes;
        }

        // ============== PNG CHUNK STEGANOGRAPHY ==============
        function crc32(data) {
            let crc = -1;
            const table = new Int32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c;
            }
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ -1) >>> 0;
        }

        async function pngChunkEncode(canvas, data, chunkType = 'tEXt', keyword = 'Comment') {
            // Get PNG data from canvas
            const pngDataUrl = canvas.toDataURL('image/png');
            const pngBase64 = pngDataUrl.split(',')[1];
            const pngBytes = Uint8Array.from(atob(pngBase64), c => c.charCodeAt(0));

            // Verify PNG signature
            const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
            for (let i = 0; i < 8; i++) {
                if (pngBytes[i] !== pngSignature[i]) {
                    throw new Error('Invalid PNG file');
                }
            }

            // Prepare chunk data based on type
            let chunkData;
            const keywordBytes = new TextEncoder().encode(keyword);

            if (chunkType === 'tEXt') {
                // tEXt: keyword + null + text
                // Encode our binary data as base64 for text chunk
                const dataBase64 = btoa(String.fromCharCode(...data));
                const dataBytes = new TextEncoder().encode(dataBase64);
                chunkData = new Uint8Array(keywordBytes.length + 1 + dataBytes.length);
                chunkData.set(keywordBytes, 0);
                chunkData[keywordBytes.length] = 0; // null separator
                chunkData.set(dataBytes, keywordBytes.length + 1);
            } else if (chunkType === 'zTXt') {
                // zTXt: keyword + null + compression method (0) + compressed text
                // For simplicity, we use uncompressed (method 0 means deflate, but we'll use tEXt format)
                const dataBase64 = btoa(String.fromCharCode(...data));
                const dataBytes = new TextEncoder().encode(dataBase64);
                chunkData = new Uint8Array(keywordBytes.length + 2 + dataBytes.length);
                chunkData.set(keywordBytes, 0);
                chunkData[keywordBytes.length] = 0; // null separator
                chunkData[keywordBytes.length + 1] = 0; // compression method
                chunkData.set(dataBytes, keywordBytes.length + 2);
            } else { // iTXt
                // iTXt: keyword + null + compression flag + compression method + language + null + translated keyword + null + text
                const dataBase64 = btoa(String.fromCharCode(...data));
                const dataBytes = new TextEncoder().encode(dataBase64);
                chunkData = new Uint8Array(keywordBytes.length + 5 + dataBytes.length);
                chunkData.set(keywordBytes, 0);
                chunkData[keywordBytes.length] = 0; // null
                chunkData[keywordBytes.length + 1] = 0; // no compression
                chunkData[keywordBytes.length + 2] = 0; // compression method
                chunkData[keywordBytes.length + 3] = 0; // empty language tag (null)
                chunkData[keywordBytes.length + 4] = 0; // empty translated keyword (null)
                chunkData.set(dataBytes, keywordBytes.length + 5);
            }

            // Build the chunk: length (4) + type (4) + data + crc (4)
            const chunkTypeBytes = new TextEncoder().encode(chunkType);
            const chunk = new Uint8Array(4 + 4 + chunkData.length + 4);
            const chunkView = new DataView(chunk.buffer);

            // Length (big-endian)
            chunkView.setUint32(0, chunkData.length);

            // Type
            chunk.set(chunkTypeBytes, 4);

            // Data
            chunk.set(chunkData, 8);

            // CRC (of type + data)
            const crcData = new Uint8Array(4 + chunkData.length);
            crcData.set(chunkTypeBytes, 0);
            crcData.set(chunkData, 4);
            const crcValue = crc32(crcData);
            chunkView.setUint32(8 + chunkData.length, crcValue);

            // Find IEND chunk and insert before it
            let iendPos = -1;
            let pos = 8; // Skip signature
            while (pos < pngBytes.length) {
                const chunkLen = (pngBytes[pos] << 24) | (pngBytes[pos+1] << 16) | (pngBytes[pos+2] << 8) | pngBytes[pos+3];
                const chunkTypeStr = String.fromCharCode(pngBytes[pos+4], pngBytes[pos+5], pngBytes[pos+6], pngBytes[pos+7]);

                if (chunkTypeStr === 'IEND') {
                    iendPos = pos;
                    break;
                }
                pos += 4 + 4 + chunkLen + 4; // length + type + data + crc
            }

            if (iendPos === -1) {
                throw new Error('Invalid PNG: no IEND chunk found');
            }

            // Create new PNG with inserted chunk
            const newPng = new Uint8Array(pngBytes.length + chunk.length);
            newPng.set(pngBytes.slice(0, iendPos), 0);
            newPng.set(chunk, iendPos);
            newPng.set(pngBytes.slice(iendPos), iendPos + chunk.length);

            return newPng;
        }

        async function pngChunkDecode(pngData, chunkType = 'tEXt', keyword = 'Comment') {
            let data;
            if (pngData instanceof Uint8Array) {
                data = pngData;
            } else if (pngData instanceof ArrayBuffer) {
                data = new Uint8Array(pngData);
            } else {
                throw new Error('Invalid PNG data');
            }

            // Verify PNG signature
            const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
            for (let i = 0; i < 8; i++) {
                if (data[i] !== pngSignature[i]) {
                    throw new Error('Invalid PNG file');
                }
            }

            // Search for our chunk
            let pos = 8;
            while (pos < data.length) {
                const chunkLen = (data[pos] << 24) | (data[pos+1] << 16) | (data[pos+2] << 8) | data[pos+3];
                const chunkTypeStr = String.fromCharCode(data[pos+4], data[pos+5], data[pos+6], data[pos+7]);

                if (chunkTypeStr === chunkType) {
                    const chunkData = data.slice(pos + 8, pos + 8 + chunkLen);

                    // Parse based on chunk type
                    let textStart = 0;

                    // Find keyword null terminator
                    while (textStart < chunkData.length && chunkData[textStart] !== 0) {
                        textStart++;
                    }

                    const foundKeyword = new TextDecoder().decode(chunkData.slice(0, textStart));
                    if (foundKeyword === keyword) {
                        let dataStart = textStart + 1;

                        if (chunkType === 'zTXt') {
                            dataStart++; // Skip compression method
                        } else if (chunkType === 'iTXt') {
                            dataStart += 4; // Skip compression flag, method, and two empty strings
                        }

                        const base64Text = new TextDecoder().decode(chunkData.slice(dataStart));
                        const binaryStr = atob(base64Text);
                        const result = new Uint8Array(binaryStr.length);
                        for (let i = 0; i < binaryStr.length; i++) {
                            result[i] = binaryStr.charCodeAt(i);
                        }
                        return result;
                    }
                }

                if (chunkTypeStr === 'IEND') break;
                pos += 4 + 4 + chunkLen + 4;
            }

            return null;
        }

        async function chromaDecode(canvas, colorSpace = 'ycbcr', channel = 'both', intensity = 2, pattern = 'sequential') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Generate same pixel order as encoder
            let pixelOrder = [];
            if (pattern === 'checkerboard') {
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if ((x + y) % 2 === 0) pixelOrder.push(y * canvas.width + x);
                    }
                }
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if ((x + y) % 2 === 1) pixelOrder.push(y * canvas.width + x);
                    }
                }
            } else if (pattern === 'edges') {
                for (let y = 0; y < canvas.height; y += 2) {
                    for (let x = 0; x < canvas.width; x++) {
                        pixelOrder.push(y * canvas.width + x);
                    }
                }
                for (let y = 1; y < canvas.height; y += 2) {
                    for (let x = 0; x < canvas.width; x++) {
                        pixelOrder.push(y * canvas.width + x);
                    }
                }
            } else {
                for (let i = 0; i < totalPixels; i++) pixelOrder.push(i);
            }

            // Extract bits from LSB of Red/Blue channels
            const bits = [];
            const maxBits = Math.min(65536 * 8, totalPixels * (channel === 'both' ? 2 : 1));

            for (const pixelIdx of pixelOrder) {
                if (bits.length >= maxBits) break;

                const idx = pixelIdx * 4;

                // Cb channel - extract from Blue (index 2)
                if (channel === 'both' || channel === 'cb') {
                    bits.push(pixels[idx + 2] & 1);
                }

                // Cr channel - extract from Red (index 0)
                if (channel === 'both' || channel === 'cr') {
                    bits.push(pixels[idx] & 1);
                }

                // Check header after 64 bits
                if (bits.length === 64) {
                    const headerBytes = [];
                    for (let i = 0; i < 8; i++) {
                        let byte = 0;
                        for (let j = 0; j < 8; j++) {
                            byte = (byte << 1) | bits[i * 8 + j];
                        }
                        headerBytes.push(byte);
                    }

                    // Check for CHRM magic
                    if (headerBytes[0] !== 0x43 || headerBytes[1] !== 0x48 ||
                        headerBytes[2] !== 0x52 || headerBytes[3] !== 0x4D) {
                        throw new Error('No chroma steganography header found');
                    }
                }
            }

            // Convert bits to bytes
            const bytes = [];
            for (let i = 0; i + 7 < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }

            const dataLength = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

            if (dataLength > bytes.length - 8 || dataLength < 0 || dataLength > 65536) {
                throw new Error('Invalid chroma data length');
            }

            return new Uint8Array(bytes.slice(8, 8 + dataLength));
        }

        function updateCapacity() {
            if (!state.carrierCanvas) {
                document.getElementById('capacity-bytes').textContent = '-- bytes';
                document.getElementById('capacity-fill').style.width = '0%';
                document.getElementById('capacity-status').textContent = 'Load an image';
                document.getElementById('capacity-percent').textContent = '0%';
                return;
            }

            const method = document.getElementById('encode-method')?.value || 'LSB';
            const totalPixels = state.carrierCanvas.width * state.carrierCanvas.height;
            let capacity = 0;

            if (method === 'LSB') {
                const channels = document.getElementById('encode-channels').value;
                const bits = parseInt(document.getElementById('encode-bits').value);
                const channelCount = CHANNEL_PRESETS[channels].length;
                capacity = Math.floor((totalPixels * channelCount * bits) / 8) - HEADER_SIZE - 64;
            } else if (method === 'DCT') {
                const blockSize = parseInt(document.getElementById('dct-blocksize')?.value || '8');
                const blocksX = Math.floor(state.carrierCanvas.width / blockSize);
                const blocksY = Math.floor(state.carrierCanvas.height / blockSize);
                capacity = Math.floor((blocksX * blocksY) / 8) - 8; // 1 bit per block, minus header
            } else if (method === 'SPREAD') {
                const spreadFactor = parseInt(document.getElementById('spread-factor')?.value || '16');
                capacity = Math.floor(totalPixels / spreadFactor / 8) - 8; // bits / 8 = bytes, minus header
            } else if (method === 'PALETTE') {
                // 1 bit per pixel (index parity)
                capacity = Math.floor(totalPixels / 8) - 8;
            } else if (method === 'F5') {
                // F5 capacity is ~10-15% of total 8x8 blocks (varies by JPEG content)
                // Each 8x8 block has ~63 AC coefficients, ~30% non-zero on average
                // F5 can embed ~1 bit per non-zero AC coefficient
                const blocks = Math.floor(totalPixels / 64); // 8x8 blocks
                const estimatedNonZero = blocks * 63 * 0.3; // ~30% non-zero
                capacity = Math.floor(estimatedNonZero / 8) - 8; // bytes, minus header
                // Note: actual capacity depends on JPEG quality and image content
            } else if (method === 'CHROMA') {
                // Chroma capacity estimate
                capacity = Math.floor(totalPixels / 8) - 8;
            } else if (method === 'PVD') {
                // PVD capacity: ~3-5 bits per pixel pair on average
                const direction = document.getElementById('pvd-direction')?.value || 'horizontal';
                const pixelPairs = direction === 'both'
                    ? Math.floor(state.carrierCanvas.width / 2) * state.carrierCanvas.height + state.carrierCanvas.width * Math.floor(state.carrierCanvas.height / 2)
                    : Math.floor(totalPixels / 2);
                // Average ~4 bits per channel, 3 channels
                capacity = Math.floor(pixelPairs * 4 * 3 / 8) - 4;
            } else if (method === 'PNGCHUNK') {
                // PNG chunks can hold arbitrary data - effectively unlimited
                // But we'll set a reasonable limit for UI purposes
                capacity = 1024 * 1024; // 1MB limit
            }

            let dataSize = 0;
            if (state.payloadMode === 'text') {
                const text = document.getElementById('encode-text').value;
                dataSize = new TextEncoder().encode(text).length;
            } else if (state.payloadFile) {
                dataSize = state.payloadFile.length + (state.payloadFileName?.length || 0) + 1;
            }

            const percent = capacity > 0 ? (dataSize / capacity) * 100 : 0;

            document.getElementById('capacity-bytes').textContent = formatSize(capacity);
            document.getElementById('capacity-fill').style.width = Math.min(100, percent) + '%';
            document.getElementById('capacity-percent').textContent = percent.toFixed(1) + '%';

            const fill = document.getElementById('capacity-fill');
            fill.classList.remove('warning', 'error');

            if (percent > 100) {
                fill.classList.add('error');
                document.getElementById('capacity-status').textContent = 'OVER CAPACITY';
            } else if (percent > 80) {
                fill.classList.add('warning');
                document.getElementById('capacity-status').textContent = 'NEARLY FULL';
            } else if (dataSize > 0) {
                document.getElementById('capacity-status').textContent = 'READY';
            } else {
                document.getElementById('capacity-status').textContent = 'NO DATA';
            }
        }

        async function doEncode() {
            // Check if we're in audio mode
            if (state.mediaType === 'audio') {
                return doAudioEncode();
            }

            // Check for GODMODE activation trigger
            if (state.payloadMode === 'text') {
                const text = document.getElementById('encode-text').value;
                if (text.includes('{GODMODE:ENABLED}')) {
                    activateGodmode();
                    document.getElementById('encode-text').value = '';
                    return;
                }
            }

            if (!state.carrierCanvas) {
                notify('Please load or generate a carrier image', 'error');
                return;
            }

            let data;
            if (state.payloadMode === 'text') {
                const text = document.getElementById('encode-text').value;
                if (!text) {
                    notify('Please enter some text to hide', 'error');
                    return;
                }
                data = new TextEncoder().encode(text);
            } else {
                if (!state.payloadFile) {
                    notify('Please select a file to hide', 'error');
                    return;
                }
                // Prepend filename
                const fnameBytes = new TextEncoder().encode(state.payloadFileName);
                data = new Uint8Array(1 + fnameBytes.length + state.payloadFile.length);
                data[0] = fnameBytes.length;
                data.set(fnameBytes, 1);
                data.set(state.payloadFile, 1 + fnameBytes.length);
            }

            const method = document.getElementById('encode-method').value;

            try {
                // Clone canvas
                let resultCanvas = document.createElement('canvas');
                resultCanvas.width = state.carrierCanvas.width;
                resultCanvas.height = state.carrierCanvas.height;
                resultCanvas.getContext('2d').drawImage(state.carrierCanvas, 0, 0);

                let methodInfo = '';

                if (method === 'LSB') {
                    const channels = document.getElementById('encode-channels').value;
                    const bits = parseInt(document.getElementById('encode-bits').value);
                    await encode(resultCanvas, data, channels, bits);
                    methodInfo = `LSB ${channels} @ ${bits} bits`;
                } else if (method === 'DCT') {
                    const robustness = document.getElementById('dct-robustness').value;
                    const blockSize = parseInt(document.getElementById('dct-blocksize').value);
                    await dctEncode(resultCanvas, data, robustness, blockSize);
                    methodInfo = `DCT ${blockSize}x${blockSize} (${robustness})`;
                } else if (method === 'SPREAD') {
                    const password = document.getElementById('spread-password').value;
                    const spreadFactor = parseInt(document.getElementById('spread-factor').value);
                    const strength = parseInt(document.getElementById('spread-strength').value);
                    await spreadEncode(resultCanvas, data, password, spreadFactor, strength);
                    methodInfo = `Spread Spectrum ${spreadFactor}x`;
                } else if (method === 'PALETTE') {
                    const numColors = parseInt(document.getElementById('palette-colors').value);
                    const mode = document.getElementById('palette-mode').value;
                    await paletteEncode(resultCanvas, data, numColors, mode);
                    methodInfo = `Palette ${numColors} colors (${mode})`;
                } else if (method === 'CHROMA') {
                    const colorSpace = document.getElementById('chroma-space').value;
                    const channel = document.getElementById('chroma-channel').value;
                    const intensity = parseInt(document.getElementById('chroma-intensity').value);
                    const pattern = document.getElementById('chroma-pattern').value;
                    await chromaEncode(resultCanvas, data, colorSpace, channel, intensity, pattern);
                    methodInfo = `Chroma (${channel} ¬±${intensity})`;
                } else if (method === 'PVD') {
                    const direction = document.getElementById('pvd-direction').value;
                    const rangeType = document.getElementById('pvd-range').value;
                    await pvdEncode(resultCanvas, data, direction, rangeType);
                    methodInfo = `PVD (${direction}, ${rangeType})`;
                } else if (method === 'PNGCHUNK') {
                    // PNG Chunk is special - it embeds in PNG metadata
                    const chunkType = document.getElementById('pngchunk-type').value;
                    const keyword = document.getElementById('pngchunk-keyword').value || 'Comment';

                    const pngData = await pngChunkEncode(resultCanvas, data, chunkType, keyword);

                    // Store PNG result
                    state.encodedResult = null;
                    state.encodedJpegResult = null;
                    state.encodedPngChunkResult = pngData;

                    // Display result
                    const blob = new Blob([pngData], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);

                    document.getElementById('encode-result').classList.remove('hidden');
                    document.getElementById('encode-result-preview').src = url;
                    document.getElementById('encode-result-info').textContent =
                        `Encoded ${formatSize(data.length)} | PNG Chunk (${chunkType}:${keyword}) | ${formatSize(pngData.length)}`;
                    document.getElementById('quick-download-btn').classList.remove('hidden');
                    document.getElementById('download-extension').textContent = '.png';

                    notify('PNG Chunk encoding successful!', 'success');
                    return; // Exit early - PNG Chunk handles its own output
                } else if (method === 'F5') {
                    // F5 is special - it works with JPEG data directly
                    const password = document.getElementById('f5-password').value;
                    const quality = parseFloat(document.getElementById('f5-quality').value);

                    if (!password) {
                        throw new Error('F5 requires a password');
                    }

                    if (typeof f5stego === 'undefined') {
                        throw new Error('F5 library not loaded. Please refresh the page.');
                    }

                    // Convert canvas to JPEG first
                    const jpegBlob = await new Promise(resolve => {
                        resultCanvas.toBlob(resolve, 'image/jpeg', quality);
                    });
                    const jpegData = new Uint8Array(await jpegBlob.arrayBuffer());

                    // Create F5 instance with password
                    const key = new TextEncoder().encode(password);
                    const stego = new f5stego(key);

                    // Embed data using F5 (library handles capacity checking internally)
                    let stegoJpeg;
                    try {
                        stegoJpeg = stego.embed(jpegData, data);
                    } catch (e) {
                        if (e.toString().includes('capacity')) {
                            throw new Error('Data too large for this image. Try a larger image or less data.');
                        }
                        throw e;
                    }

                    // Store JPEG result instead of canvas
                    state.encodedResult = null; // Clear canvas result
                    state.encodedJpegResult = stegoJpeg;

                    // Display result
                    const blob = new Blob([stegoJpeg], { type: 'image/jpeg' });
                    const url = URL.createObjectURL(blob);

                    document.getElementById('encode-result').classList.remove('hidden');
                    document.getElementById('encode-result-preview').src = url;
                    document.getElementById('encode-result-info').textContent =
                        `Encoded ${formatSize(data.length)} | F5 JPEG Q=${Math.round(quality * 100)}% | ${formatSize(stegoJpeg.length)}`;
                    document.getElementById('quick-download-btn').classList.remove('hidden');
                    document.getElementById('download-extension').textContent = '.jpg';

                    notify('F5 encoding successful! Output: JPEG', 'success');
                    return; // Exit early - F5 handles its own output
                }

                state.encodedResult = resultCanvas;
                state.encodedJpegResult = null; // Clear F5 result when using other methods

                document.getElementById('encode-result').classList.remove('hidden');
                document.getElementById('encode-result-preview').src = resultCanvas.toDataURL('image/png');
                document.getElementById('encode-result-info').textContent =
                    `Encoded ${formatSize(data.length)} | ${methodInfo} | PNG`;
                document.getElementById('quick-download-btn').classList.remove('hidden');
                document.getElementById('download-extension').textContent = '.png';

                notify('Encoding successful! Output: PNG (lossless)', 'success');
            } catch (e) {
                notify(e.message, 'error');
            }
        }

        function downloadResult() {
            const customName = document.getElementById('download-filename')?.value || 'stego_output';

            // Handle F5 JPEG output
            if (state.encodedJpegResult) {
                const blob = new Blob([state.encodedJpegResult], { type: 'image/jpeg' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `${customName}.jpg`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                return;
            }

            // Handle PNG Chunk output
            if (state.encodedPngChunkResult) {
                const blob = new Blob([state.encodedPngChunkResult], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `${customName}.png`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                return;
            }

            if (!state.encodedResult) return;

            const link = document.createElement('a');
            link.download = `${customName}.png`;
            link.href = state.encodedResult.toDataURL('image/png');
            link.click();
        }

        async function doSmartScan() {
            // Check if we have audio loaded - use audio decode instead
            if (state.decodeAudioBuffer) {
                notify('üéµ Scanning audio for hidden data...', 'info');
                return doAudioDecode(); // Audio decode in AUTO mode handles scanning
            }

            if (!state.decodeCanvas) {
                notify('Please load an image or audio file first', 'error');
                return;
            }

            notify('Scanning all configurations...', 'info');

            try {
                const results = await smartScan(state.decodeCanvas);

                let html = '<table class="results-table"><thead><tr>';
                html += '<th>Config</th><th>Channels</th><th>Bits</th><th>Status</th><th>Conf</th><th>Preview</th>';
                html += '</tr></thead><tbody>';

                for (const r of results) {
                    let statusClass = 'status-none';
                    if (r.status === 'STEG_DETECTED' || r.status === 'STEG_HEADER') statusClass = 'status-found';
                    else if (r.status === 'TEXT_FOUND') statusClass = 'status-text';
                    else if (r.status === 'POSSIBLE_TEXT') statusClass = 'status-possible';

                    const preview = (r.preview || '').slice(0, 50).replace(/</g, '&lt;');

                    html += `<tr>
                        <td>${r.name}</td>
                        <td>${r.channels}</td>
                        <td>${r.bits}</td>
                        <td class="${statusClass}">${r.status}</td>
                        <td>${r.confidence.toFixed(0)}%</td>
                        <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${preview}</td>
                    </tr>`;
                }

                html += '</tbody></table>';

                const found = results.filter(r => r.status === 'TEXT_FOUND' || r.status === 'STEG_DETECTED' || r.status === 'STEG_HEADER').length;
                html += `<p class="mt-2">Found ${found} likely matches in ${results.length} configs</p>`;

                document.getElementById('scan-results-content').innerHTML = html;
                document.getElementById('scan-results').classList.remove('hidden');

                if (found > 0) {
                    notify(`Found ${found} potential hidden data!`, 'success');
                } else {
                    notify('Scan complete - no obvious text found', 'info');
                }
            } catch (e) {
                notify(e.message, 'error');
            }
        }

        async function doDecode() {
            // Check if we have audio loaded for decode (check buffer directly, not global mediaType)
            if (state.decodeAudioBuffer) {
                return doAudioDecode();
            }

            if (!state.decodeCanvas) {
                notify('Please load an image or audio file first', 'error');
                return;
            }

            const method = document.getElementById('decode-method').value;

            try {
                let data;

                if (method === 'AUTO') {
                    // Run smart scan to find best method
                    notify('Scanning for hidden data...', 'info');
                    const results = await smartScan(state.decodeCanvas);

                    // Find best result with actual data
                    const best = results.find(r =>
                        r.hasHeader || r.status === 'STEG_DETECTED' || r.status === 'STEG_HEADER' ||
                        r.status === 'TEXT_FOUND' || (r.confidence >= 50 && r.rawData)
                    );

                    if (!best) {
                        throw new Error('No hidden data detected');
                    }

                    // Decode using the best method found
                    if (best.isDCT) {
                        data = await dctDecode(state.decodeCanvas);
                        notify('Auto-decode successful (DCT)!', 'success');
                    } else if (best.isChroma) {
                        data = await chromaDecode(state.decodeCanvas, 'ycbcr', 'both');
                        notify('Auto-decode successful (Chroma)!', 'success');
                    } else if (best.hasHeader && best.headerConfig) {
                        // Use full decode with header
                        data = await decode(state.decodeCanvas);
                        notify('Auto-decode successful (STEG header)!', 'success');
                    } else if (best.rawData) {
                        // Use the raw data from scan
                        data = best.rawData;
                        notify(`Auto-decode successful (${best.name})!`, 'success');
                    } else {
                        // Fallback to standard decode
                        data = await decode(state.decodeCanvas);
                        notify('Auto-decode successful!', 'success');
                    }
                } else if (method === 'LSB') {
                    const channels = document.getElementById('decode-channels').value;
                    const bits = parseInt(document.getElementById('decode-bits').value);
                    data = extractRawBits(state.decodeCanvas, CHANNEL_PRESETS[channels], bits, 8192);
                    notify('Decode complete (LSB)', 'success');
                } else if (method === 'DCT') {
                    const blockSize = parseInt(document.getElementById('dct-decode-blocksize').value);
                    data = await dctDecode(state.decodeCanvas, blockSize);
                    notify('Decode complete (DCT)', 'success');
                } else if (method === 'SPREAD') {
                    const password = document.getElementById('spread-decode-password').value;
                    const spreadFactor = parseInt(document.getElementById('spread-decode-factor').value);
                    data = await spreadDecode(state.decodeCanvas, password, spreadFactor);
                    notify('Decode complete (Spread Spectrum)', 'success');
                } else if (method === 'PALETTE') {
                    const mode = document.getElementById('palette-decode-mode').value;
                    data = await paletteDecode(state.decodeCanvas, mode);
                    notify('Decode complete (Palette)', 'success');
                } else if (method === 'CHROMA') {
                    const colorSpace = document.getElementById('chroma-decode-space').value;
                    const channel = document.getElementById('chroma-decode-channel').value;
                    data = await chromaDecode(state.decodeCanvas, colorSpace, channel);
                    notify('Decode complete (Chroma)', 'success');
                } else if (method === 'PVD') {
                    const direction = document.getElementById('pvd-decode-direction').value;
                    const rangeType = document.getElementById('pvd-decode-range').value;
                    data = await pvdDecode(state.decodeCanvas, direction, rangeType);
                    notify('Decode complete (PVD)', 'success');
                } else if (method === 'PNGCHUNK') {
                    const chunkType = document.getElementById('pngchunk-decode-type').value;
                    const keyword = document.getElementById('pngchunk-decode-keyword').value || 'Comment';
                    // PNG Chunk needs raw file data, not canvas
                    if (!state.decodePngData) {
                        throw new Error('PNG Chunk decode requires original PNG file. Please load a PNG image.');
                    }
                    data = await pngChunkDecode(state.decodePngData, chunkType, keyword);
                    if (!data) {
                        throw new Error(`No data found in ${chunkType} chunk with keyword "${keyword}"`);
                    }
                    notify('Decode complete (PNG Chunk)', 'success');
                } else if (method === 'F5') {
                    const password = document.getElementById('f5-decode-password').value;

                    if (!password) {
                        throw new Error('F5 requires a password');
                    }

                    if (typeof f5stego === 'undefined') {
                        throw new Error('F5 library not loaded. Please refresh the page.');
                    }

                    // F5 needs original JPEG data, not canvas
                    if (!state.decodeJpegData) {
                        throw new Error('F5 requires original JPEG file. Please load a JPEG image.');
                    }

                    const key = new TextEncoder().encode(password);
                    const stego = new f5stego(key);
                    data = stego.extract(state.decodeJpegData);

                    if (!data || data.length === 0) {
                        throw new Error('No F5 data found (wrong password?)');
                    }

                    notify('Decode complete (F5)', 'success');
                }

                displayExtractedData(data);
            } catch (e) {
                notify(e.message + (method === 'AUTO' ? ' - Try Smart Scan for details' : ''), 'error');
            }
        }

        async function doMatryoshkaDecode() {
            // Use matryoshkaDecodeCanvas if available, otherwise fall back to decodeCanvas
            const canvas = state.matryoshkaDecodeCanvas || state.decodeCanvas;

            if (!canvas) {
                notify('Please load an image first (use the drop zone in Nested Stegg tab)', 'error');
                return;
            }

            notify(`Starting Nested Stegg decode (depth: ${state.matryoshkaDepth})...`, 'info');

            try {
                const results = await matryoshkaDecode(canvas, state.matryoshkaDepth);

                function buildResultsHtml(resList, indent = 0) {
                    let html = '';
                    for (const r of resList) {
                        const dolls = 'ü™Ü'.repeat(r.depth + 1);

                        // Determine status and icon
                        let statusIcon, statusColor, statusText;
                        if (r.type === 'no_data_found') {
                            statusIcon = '‚ùå';
                            statusColor = 'var(--warning)';
                            statusText = 'No data found';
                        } else if (r.type === 'max_depth_reached') {
                            statusIcon = '‚ö†Ô∏è';
                            statusColor = 'var(--warning)';
                            statusText = 'Max depth';
                        } else if (r.hasNested) {
                            statusIcon = '‚úÖ';
                            statusColor = 'var(--primary)';
                            statusText = 'Image extracted';
                        } else if (r.type === 'text' || r.type === 'file') {
                            statusIcon = '‚úÖ';
                            statusColor = 'var(--primary)';
                            statusText = r.type === 'text' ? 'Text extracted' : 'File extracted';
                        } else {
                            statusIcon = 'üîç';
                            statusColor = 'var(--secondary)';
                            statusText = 'Data found';
                        }

                        const typeIcon = r.hasNested ? 'üñºÔ∏è' : r.type === 'text' ? 'üìù' : r.type === 'file' ? 'üìÅ' : 'ü™Ü';

                        // Config info with clear channel/bits display
                        const configInfo = r.configUsed
                            ? `<span style="color: var(--accent); font-weight: bold;">[${r.configUsed}]</span>`
                            : '';

                        // Image dimensions if available
                        const imageDims = r.imageSize ? `${r.imageSize.width}√ó${r.imageSize.height}` : '';
                        const sizeInfo = [
                            r.filename || r.type,
                            imageDims,
                            formatSize(r.dataSize || 0)
                        ].filter(Boolean).join(' ‚Ä¢ ');

                        html += `<div class="matryoshka-layer" style="margin-left: ${r.depth * 16}px; border-left: 3px solid hsl(${300 - r.depth * 30}, 100%, 50%); padding-left: 12px; margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; flex-wrap: wrap;">
                                <span style="font-size: 16px;">${dolls}</span>
                                <span style="font-weight: bold; color: var(--text);">Layer ${r.depth}</span>
                                <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>
                                ${configInfo}
                            </div>
                            <div style="font-size: 11px; color: var(--text-dim); margin-bottom: 4px;">
                                ${typeIcon} ${sizeInfo}
                            </div>
                            <div style="font-size: 11px; color: #888; background: rgba(0,0,0,0.3); padding: 6px 8px; border-radius: 4px; max-height: 60px; overflow: auto; word-break: break-all;">
                                ${(r.preview || 'No preview').slice(0, 200).replace(/</g, '&lt;')}
                            </div>
                        </div>`;

                        if (r.nestedResults && r.nestedResults.length > 0) {
                            html += buildResultsHtml(r.nestedResults, indent + 1);
                        }
                    }
                    return html;
                }

                const html = buildResultsHtml(results);

                // Update BOTH result areas (decode panel and matryoshka panel)
                const panelContent = document.getElementById('matryoshka-panel-results-content');
                const panelResults = document.getElementById('matryoshka-panel-results');
                if (panelContent) panelContent.innerHTML = html;
                if (panelResults) panelResults.classList.remove('hidden');

                // Also update the decode panel version if it exists
                const decodeContent = document.getElementById('matryoshka-results-content');
                const decodeResults = document.getElementById('matryoshka-results');
                if (decodeContent) decodeContent.innerHTML = html;
                if (decodeResults) decodeResults.classList.remove('hidden');

                // Get deepest data
                function getDeepest(resList) {
                    for (const r of [...resList].reverse()) {
                        if (r.nestedResults && r.nestedResults.length > 0) {
                            const deep = getDeepest(r.nestedResults);
                            if (deep) return deep;
                        }
                        if (r.rawData) return r;
                    }
                    return null;
                }

                const deepest = getDeepest(results);
                if (deepest && deepest.rawData) {
                    // Store for download
                    const { filename: extractedName, fileData } = extractFileFromData(deepest.rawData);
                    state.matryoshkaExtractedData = extractedName ? fileData : deepest.rawData;
                    state.matryoshkaExtractedFilename = deepest.filename || extractedName || 'extracted.bin';

                    // Display in matryoshka panel
                    const extractedDiv = document.getElementById('matryoshka-extracted');
                    const infoDiv = document.getElementById('matryoshka-extracted-info');
                    const previewPre = document.getElementById('matryoshka-extracted-preview');

                    if (extractedDiv && infoDiv && previewPre) {
                        extractedDiv.classList.remove('hidden');
                        infoDiv.textContent = `${state.matryoshkaExtractedFilename} (${formatSize(state.matryoshkaExtractedData.length)})`;

                        // Show preview
                        const data = state.matryoshkaExtractedData;
                        const isText = data.every(b => b < 128 && (b >= 32 || b === 10 || b === 13 || b === 9));
                        if (isText) {
                            previewPre.textContent = new TextDecoder().decode(data).slice(0, 1000);
                        } else {
                            const hexPreview = Array.from(data.slice(0, 256)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                            previewPre.textContent = `[Binary] ${hexPreview}${data.length > 256 ? '...' : ''}`;
                        }
                    }

                    // Also update the main decode panel
                    displayExtractedData(deepest.rawData, deepest.filename);
                }

                const totalLayers = results.reduce((acc, r) => {
                    let count = 1;
                    if (r.nestedResults) count += r.nestedResults.length;
                    return acc + count;
                }, 0);

                notify(`ü™Ü Nested Stegg decode complete! Found ${totalLayers} layer(s).`, 'success');
            } catch (e) {
                notify('Decode error: ' + e.message, 'error');
            }
        }

        function downloadMatryoshkaExtracted() {
            if (!state.matryoshkaExtractedData) {
                notify('No extracted data to download', 'error');
                return;
            }

            const blob = new Blob([state.matryoshkaExtractedData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = state.matryoshkaExtractedFilename || 'extracted.bin';
            a.click();
            URL.revokeObjectURL(url);
        }

        function displayExtractedData(data, filename = null) {
            const { filename: extractedName, fileData } = extractFileFromData(data);
            const name = filename || extractedName;

            state.extractedData = name ? fileData : data;
            state.extractedFileName = name || 'extracted.txt';

            const content = document.getElementById('decode-result-content');
            const quickContent = document.getElementById('quick-decode-content');
            const quickResult = document.getElementById('quick-decode-result');

            let displayText;
            if (name) {
                displayText = `File: ${name}\nSize: ${formatSize(fileData.length)}\n\n(Click Download to save)`;
            } else {
                try {
                    displayText = new TextDecoder().decode(data);
                } catch (e) {
                    displayText = `Binary data (${formatSize(data.length)}):\n\n` +
                        Array.from(data.slice(0, 256)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                }
            }

            // Show in both places
            content.textContent = displayText;
            quickContent.textContent = displayText;

            document.getElementById('decode-result').classList.remove('hidden');
            quickResult.classList.remove('hidden');
        }

        function downloadExtracted() {
            if (!state.extractedData) return;

            const blob = new Blob([state.extractedData]);
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = state.extractedFileName;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        async function doAnalyze() {
            // Check if we have audio loaded for analyze (check buffer directly, not global mediaType)
            if (state.analyzeAudioBuffer) {
                return doAudioAnalyze();
            }

            if (!state.analyzeCanvas) {
                notify('Please load an image or audio file first', 'error');
                return;
            }

            const canvas = state.analyzeCanvas;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            let output = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       STEGANALYSIS REPORT            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Dimensions: ${canvas.width}x${canvas.height}
‚ïë Total Pixels: ${(canvas.width * canvas.height).toLocaleString()}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;

            // Check for STEG header
            const headerBytes = extractRawBits(canvas, [0, 1, 2], 1, HEADER_SIZE);
            const header = parseHeader(headerBytes);

            if (header) {
                output += `‚ïë ‚úì STEG HEADER DETECTED
‚ïë   Channels: ${header.channels.map(c => ['R','G','B','A'][c]).join('')}
‚ïë   Bits: ${header.bitsPerChannel}
‚ïë   Payload: ${formatSize(header.originalLength)}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;
            } else {
                output += `‚ïë No STEG header detected
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;
            }

            // Channel statistics
            const channels = ['R', 'G', 'B', 'A'];
            output += '‚ïë CHANNEL ANALYSIS:\n';

            for (let ch = 0; ch < 4; ch++) {
                let sum = 0, sumSq = 0, lsb0 = 0, lsb1 = 0;
                const count = canvas.width * canvas.height;

                for (let i = 0; i < pixels.length; i += 4) {
                    const val = pixels[i + ch];
                    sum += val;
                    sumSq += val * val;
                    if (val & 1) lsb1++; else lsb0++;
                }

                const mean = sum / count;
                const std = Math.sqrt(sumSq / count - mean * mean);
                const lsbRatio = lsb1 / count;
                const chiSquare = Math.pow(lsb0 - count/2, 2) / (count/2) + Math.pow(lsb1 - count/2, 2) / (count/2);

                output += `‚ïë ${channels[ch]}: Œº=${mean.toFixed(1)} œÉ=${std.toFixed(1)} LSB=${lsbRatio.toFixed(3)} œá¬≤=${chiSquare.toFixed(2)}\n`;
            }

            output += `‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CAPACITY BY CONFIG:
‚ïë   RGB 1-bit: ${formatSize(Math.floor(canvas.width * canvas.height * 3 / 8))}
‚ïë   RGB 2-bit: ${formatSize(Math.floor(canvas.width * canvas.height * 6 / 8))}
‚ïë   RGBA 1-bit: ${formatSize(Math.floor(canvas.width * canvas.height * 4 / 8))}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;

            // File structure analysis
            if (state.analyzeFile) {
                const fileOutput = await analyzeFileStructureAsync(state.analyzeFile);
                output += fileOutput;
            }

            output += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;

            document.getElementById('analyze-result').textContent = output;

            // Auto-show visual layers
            showChannelLayers();

            notify('Analysis complete', 'success');
        }

        // Async version of file structure analysis for doAnalyze
        function analyzeFileStructureAsync(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const bytes = new Uint8Array(e.target.result);
                    let output = '‚ïë FILE STRUCTURE:\n';

                    // Detect file type
                    let fileType = 'Unknown';
                    let endMarker = -1;

                    if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                        fileType = 'PNG';
                        for (let i = bytes.length - 12; i >= 0; i--) {
                            if (bytes[i] === 0x49 && bytes[i+1] === 0x45 && bytes[i+2] === 0x4E && bytes[i+3] === 0x44) {
                                endMarker = i + 8;
                                break;
                            }
                        }
                    } else if (bytes[0] === 0xFF && bytes[1] === 0xD8) {
                        fileType = 'JPEG';
                        for (let i = bytes.length - 2; i >= 0; i--) {
                            if (bytes[i] === 0xFF && bytes[i+1] === 0xD9) {
                                endMarker = i + 2;
                                break;
                            }
                        }
                    } else if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46) {
                        fileType = 'GIF';
                        for (let i = bytes.length - 1; i >= 0; i--) {
                            if (bytes[i] === 0x3B) {
                                endMarker = i + 1;
                                break;
                            }
                        }
                    }

                    output += `‚ïë   Type: ${fileType} | Size: ${bytes.length.toLocaleString()} bytes\n`;

                    if (endMarker > 0 && endMarker < bytes.length) {
                        const extraBytes = bytes.length - endMarker;
                        output += `‚ïë   ‚ö†Ô∏è APPENDED DATA: ${extraBytes} bytes after end marker\n`;
                    } else if (endMarker === bytes.length) {
                        output += `‚ïë   ‚úì No appended data\n`;
                    }

                    // Check for steg signatures
                    const signatures = [
                        { name: 'STEG header', pattern: [0x53, 0x54, 0x45, 0x47] },
                        { name: 'PK/ZIP', pattern: [0x50, 0x4B, 0x03, 0x04] },
                        { name: 'RAR', pattern: [0x52, 0x61, 0x72, 0x21] },
                    ];

                    for (const sig of signatures) {
                        for (let i = 0; i < bytes.length - sig.pattern.length; i++) {
                            let match = true;
                            for (let j = 0; j < sig.pattern.length; j++) {
                                if (bytes[i + j] !== sig.pattern[j]) { match = false; break; }
                            }
                            if (match) {
                                output += `‚ïë   Found "${sig.name}" @ offset ${i}\n`;
                                break;
                            }
                        }
                    }

                    resolve(output);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // ============== CHANNEL LAYER VISUALIZATION ==============
        let channelViewMode = 'normal';
        let currentBitPlane = 0;

        function showChannelLayers() {
            if (!state.analyzeCanvas) {
                notify('Please load an image first', 'error');
                return;
            }

            const section = document.getElementById('channel-layers-section');
            section.classList.remove('hidden');
            renderChannelLayers();
            renderTransforms();
            renderHistogram();
            renderYCbCr();
            renderChiSquare();
            renderDctBlocks();
            setupZoom();
            notify('Visual analysis rendered', 'success');
        }

        function setChannelView(mode) {
            channelViewMode = mode;

            // Update button styles
            document.getElementById('cv-normal').className = mode === 'normal' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
            document.getElementById('cv-enhanced').className = mode === 'enhanced' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
            document.getElementById('cv-bitplane').className = mode === 'bitplane' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';

            // Show/hide bitplane controls
            document.getElementById('bitplane-controls').classList.toggle('hidden', mode !== 'bitplane');

            renderChannelLayers();
        }

        function renderChannelLayers() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const imageData = srcCtx.getImageData(0, 0, src.width, src.height);
            const pixels = imageData.data;

            const channelIds = ['channel-r', 'channel-g', 'channel-b', 'channel-a'];
            const channelColors = [
                [1, 0, 0],  // R -> show in red
                [0, 1, 0],  // G -> show in green
                [0, 0, 1],  // B -> show in blue
                [1, 1, 1]   // A -> show in grayscale
            ];

            for (let ch = 0; ch < 4; ch++) {
                const canvas = document.getElementById(channelIds[ch]);
                canvas.width = src.width;
                canvas.height = src.height;
                const ctx = canvas.getContext('2d');
                const outData = ctx.createImageData(src.width, src.height);
                const out = outData.data;

                for (let i = 0; i < pixels.length; i += 4) {
                    let val = pixels[i + ch];

                    if (channelViewMode === 'enhanced') {
                        // Enhance contrast - stretch to full range
                        val = Math.min(255, val * 2);
                    } else if (channelViewMode === 'bitplane') {
                        // Show specific bit plane
                        val = ((val >> currentBitPlane) & 1) * 255;
                    }

                    // Apply channel color
                    out[i] = val * channelColors[ch][0];
                    out[i + 1] = val * channelColors[ch][1];
                    out[i + 2] = val * channelColors[ch][2];
                    out[i + 3] = 255;
                }

                ctx.putImageData(outData, 0, 0);
            }
        }

        function renderTransforms() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const imageData = srcCtx.getImageData(0, 0, src.width, src.height);
            const pixels = imageData.data;
            const w = src.width, h = src.height;

            // Helper to create output canvas
            function setupCanvas(id) {
                const canvas = document.getElementById(id);
                canvas.width = w;
                canvas.height = h;
                return canvas.getContext('2d');
            }

            // 1. Luminance (Y channel)
            const lumaCtx = setupCanvas('transform-luma');
            const lumaData = lumaCtx.createImageData(w, h);
            for (let i = 0; i < pixels.length; i += 4) {
                const y = Math.round(0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2]);
                lumaData.data[i] = lumaData.data[i+1] = lumaData.data[i+2] = y;
                lumaData.data[i+3] = 255;
            }
            lumaCtx.putImageData(lumaData, 0, 0);

            // 2. Inverted
            const invCtx = setupCanvas('transform-invert');
            const invData = invCtx.createImageData(w, h);
            for (let i = 0; i < pixels.length; i += 4) {
                invData.data[i] = 255 - pixels[i];
                invData.data[i+1] = 255 - pixels[i+1];
                invData.data[i+2] = 255 - pixels[i+2];
                invData.data[i+3] = 255;
            }
            invCtx.putImageData(invData, 0, 0);

            // 3. Edge Detection (Sobel)
            const edgeCtx = setupCanvas('transform-edge');
            const edgeData = edgeCtx.createImageData(w, h);
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let gx = 0, gy = 0;
                    // Sobel kernels
                    const idx = (y * w + x) * 4;
                    const getL = (ox, oy) => {
                        const i = ((y + oy) * w + (x + ox)) * 4;
                        return 0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2];
                    };
                    gx = -getL(-1,-1) + getL(1,-1) - 2*getL(-1,0) + 2*getL(1,0) - getL(-1,1) + getL(1,1);
                    gy = -getL(-1,-1) - 2*getL(0,-1) - getL(1,-1) + getL(-1,1) + 2*getL(0,1) + getL(1,1);
                    const mag = Math.min(255, Math.sqrt(gx*gx + gy*gy));
                    edgeData.data[idx] = edgeData.data[idx+1] = edgeData.data[idx+2] = mag;
                    edgeData.data[idx+3] = 255;
                }
            }
            edgeCtx.putImageData(edgeData, 0, 0);

            // 4. Noise Residual (high-pass filter - difference from blurred)
            const noiseCtx = setupCanvas('transform-noise');
            const noiseData = noiseCtx.createImageData(w, h);
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    const idx = (y * w + x) * 4;
                    for (let c = 0; c < 3; c++) {
                        // 3x3 average
                        let sum = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                sum += pixels[((y+dy) * w + (x+dx)) * 4 + c];
                            }
                        }
                        const avg = sum / 9;
                        // Noise = original - blurred, centered at 128
                        const noise = 128 + (pixels[idx + c] - avg) * 4;
                        noiseData.data[idx + c] = Math.max(0, Math.min(255, noise));
                    }
                    noiseData.data[idx + 3] = 255;
                }
            }
            noiseCtx.putImageData(noiseData, 0, 0);

            // 5. XOR Checkerboard
            const xorCtx = setupCanvas('transform-xor');
            const xorData = xorCtx.createImageData(w, h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    const pattern = ((x + y) % 2) * 255;
                    xorData.data[idx] = pixels[idx] ^ pattern;
                    xorData.data[idx+1] = pixels[idx+1] ^ pattern;
                    xorData.data[idx+2] = pixels[idx+2] ^ pattern;
                    xorData.data[idx+3] = 255;
                }
            }
            xorCtx.putImageData(xorData, 0, 0);

            // 6. LSB Randomness Visualization (block-based entropy)
            const randCtx = setupCanvas('transform-random');
            const randData = randCtx.createImageData(w, h);
            const blockSize = 8;
            for (let by = 0; by < h; by += blockSize) {
                for (let bx = 0; bx < w; bx += blockSize) {
                    // Count LSB transitions in block
                    let transitions = 0, count = 0;
                    let prevBit = -1;
                    for (let y = by; y < Math.min(by + blockSize, h); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, w); x++) {
                            const idx = (y * w + x) * 4;
                            for (let c = 0; c < 3; c++) {
                                const bit = pixels[idx + c] & 1;
                                if (prevBit !== -1 && bit !== prevBit) transitions++;
                                prevBit = bit;
                                count++;
                            }
                        }
                    }
                    // High transitions = random (steg), low = natural
                    const randomness = count > 0 ? transitions / count : 0;
                    const color = randomness > 0.45 ? [255, 100, 100] : randomness > 0.35 ? [255, 200, 100] : [100, 255, 100];

                    for (let y = by; y < Math.min(by + blockSize, h); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, w); x++) {
                            const idx = (y * w + x) * 4;
                            randData.data[idx] = color[0];
                            randData.data[idx+1] = color[1];
                            randData.data[idx+2] = color[2];
                            randData.data[idx+3] = 255;
                        }
                    }
                }
            }
            randCtx.putImageData(randData, 0, 0);
        }

        function renderHistogram() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const pixels = srcCtx.getImageData(0, 0, src.width, src.height).data;

            // Count values for each channel
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);
            const histL = new Array(256).fill(0);

            for (let i = 0; i < pixels.length; i += 4) {
                histR[pixels[i]]++;
                histG[pixels[i+1]]++;
                histB[pixels[i+2]]++;
                const lum = Math.round(0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2]);
                histL[lum]++;
            }

            // Find max for scaling
            const maxVal = Math.max(...histR, ...histG, ...histB, ...histL);

            // Draw histogram
            const canvas = document.getElementById('histogram-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.offsetWidth * 2;
            const h = canvas.height = 300;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            const barWidth = w / 256;
            const scale = (h - 20) / maxVal;

            // Draw each histogram
            const drawHist = (hist, color, offset) => {
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 256; i++) {
                    const barH = hist[i] * scale;
                    ctx.fillRect(i * barWidth + offset, h - barH, barWidth - 1, barH);
                }
                ctx.globalAlpha = 1;
            };

            drawHist(histL, '#868e96', 0);
            drawHist(histR, '#ff6b6b', 0);
            drawHist(histG, '#51cf66', 0);
            drawHist(histB, '#339af0', 0);

            // Draw axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px monospace';
            ctx.fillText('0', 5, h - 5);
            ctx.fillText('255', w - 25, h - 5);
        }

        // ============== YCbCr CHROMINANCE ==============
        function renderYCbCr() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const pixels = srcCtx.getImageData(0, 0, src.width, src.height).data;
            const w = src.width, h = src.height;

            const yCanvas = document.getElementById('ycbcr-y');
            const cbCanvas = document.getElementById('ycbcr-cb');
            const crCanvas = document.getElementById('ycbcr-cr');

            [yCanvas, cbCanvas, crCanvas].forEach(c => { c.width = w; c.height = h; });

            const yCtx = yCanvas.getContext('2d');
            const cbCtx = cbCanvas.getContext('2d');
            const crCtx = crCanvas.getContext('2d');

            const yData = yCtx.createImageData(w, h);
            const cbData = cbCtx.createImageData(w, h);
            const crData = crCtx.createImageData(w, h);

            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i], g = pixels[i+1], b = pixels[i+2];

                // RGB to YCbCr conversion
                const y = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                const cb = Math.round(128 - 0.168736 * r - 0.331264 * g + 0.5 * b);
                const cr = Math.round(128 + 0.5 * r - 0.418688 * g - 0.081312 * b);

                // Y as grayscale
                yData.data[i] = yData.data[i+1] = yData.data[i+2] = y;
                yData.data[i+3] = 255;

                // Cb as blue-yellow
                cbData.data[i] = 255 - cb;
                cbData.data[i+1] = 255 - cb;
                cbData.data[i+2] = cb;
                cbData.data[i+3] = 255;

                // Cr as red-cyan
                crData.data[i] = cr;
                crData.data[i+1] = 255 - cr;
                crData.data[i+2] = 255 - cr;
                crData.data[i+3] = 255;
            }

            yCtx.putImageData(yData, 0, 0);
            cbCtx.putImageData(cbData, 0, 0);
            crCtx.putImageData(crData, 0, 0);
        }

        // ============== CHI-SQUARE HEATMAP ==============
        function renderChiSquare() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const pixels = srcCtx.getImageData(0, 0, src.width, src.height).data;
            const w = src.width, h = src.height;

            const canvas = document.getElementById('chisquare-canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const outData = ctx.createImageData(w, h);

            const blockSize = 16; // Analyze 16x16 blocks

            for (let by = 0; by < h; by += blockSize) {
                for (let bx = 0; bx < w; bx += blockSize) {
                    // Count pairs of values (2k, 2k+1) in the block
                    const pairs = new Array(128).fill(0).map(() => [0, 0]);

                    for (let y = by; y < Math.min(by + blockSize, h); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, w); x++) {
                            const idx = (y * w + x) * 4;
                            for (let c = 0; c < 3; c++) {
                                const val = pixels[idx + c];
                                const pairIdx = Math.floor(val / 2);
                                pairs[pairIdx][val % 2]++;
                            }
                        }
                    }

                    // Calculate chi-square statistic
                    let chiSquare = 0;
                    for (const [even, odd] of pairs) {
                        const expected = (even + odd) / 2;
                        if (expected > 0) {
                            chiSquare += Math.pow(even - expected, 2) / expected;
                            chiSquare += Math.pow(odd - expected, 2) / expected;
                        }
                    }

                    // Color based on chi-square value
                    let color;
                    if (chiSquare < 10) color = [100, 255, 100];      // Normal
                    else if (chiSquare < 50) color = [255, 212, 59];  // Suspicious
                    else color = [255, 100, 100];                      // Likely steg

                    // Fill block
                    for (let y = by; y < Math.min(by + blockSize, h); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, w); x++) {
                            const idx = (y * w + x) * 4;
                            outData.data[idx] = color[0];
                            outData.data[idx+1] = color[1];
                            outData.data[idx+2] = color[2];
                            outData.data[idx+3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(outData, 0, 0);
        }

        // ============== DCT BLOCK VISUALIZATION ==============
        let dctViewMode = 'dc';

        function setDctView(mode) {
            dctViewMode = mode;
            document.getElementById('dct-dc').className = mode === 'dc' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
            document.getElementById('dct-ac').className = mode === 'ac' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
            document.getElementById('dct-coeff').className = mode === 'coeff' ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
            renderDctBlocks();
        }

        function renderDctBlocks() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const srcCtx = src.getContext('2d');
            const pixels = srcCtx.getImageData(0, 0, src.width, src.height).data;
            const w = src.width, h = src.height;

            const canvas = document.getElementById('dct-canvas');
            const blocksX = Math.floor(w / 8);
            const blocksY = Math.floor(h / 8);

            // Draw at full image size (8 pixels per block)
            canvas.width = blocksX * 8;
            canvas.height = blocksY * 8;
            const ctx = canvas.getContext('2d');
            const outData = ctx.createImageData(canvas.width, canvas.height);

            for (let by = 0; by < blocksY; by++) {
                for (let bx = 0; bx < blocksX; bx++) {
                    // Extract 8x8 block luminance
                    const block = [];
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            const px = (by * 8 + y) * w + (bx * 8 + x);
                            const idx = px * 4;
                            block.push(0.299 * pixels[idx] + 0.587 * pixels[idx+1] + 0.114 * pixels[idx+2]);
                        }
                    }

                    // Simple DCT calculation for visualization
                    let value = 0;

                    if (dctViewMode === 'dc') {
                        // DC component (average)
                        value = block.reduce((a, b) => a + b, 0) / 64;
                    } else if (dctViewMode === 'ac') {
                        // AC energy (variance from mean)
                        const mean = block.reduce((a, b) => a + b, 0) / 64;
                        const variance = block.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / 64;
                        value = Math.min(255, Math.sqrt(variance) * 4);
                    } else if (dctViewMode === 'coeff') {
                        // Mid-frequency coefficient approximation
                        let sum = 0;
                        for (let i = 0; i < 64; i++) {
                            const x = i % 8, y = Math.floor(i / 8);
                            if ((x + y) >= 2 && (x + y) <= 4) {
                                sum += Math.abs(block[i] - block[0]);
                            }
                        }
                        value = Math.min(255, sum / 10);
                    }

                    // Fill 8x8 pixel block with the computed value
                    for (let py = 0; py < 8; py++) {
                        for (let px = 0; px < 8; px++) {
                            const outIdx = ((by * 8 + py) * canvas.width + (bx * 8 + px)) * 4;
                            outData.data[outIdx] = value;
                            outData.data[outIdx+1] = value * 0.7;
                            outData.data[outIdx+2] = Math.min(255, value * 1.2);
                            outData.data[outIdx+3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(outData, 0, 0);
        }

        // ============== FILE STRUCTURE ANALYSIS ==============
        function analyzeFileStructure(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const bytes = new Uint8Array(e.target.result);
                let output = '';

                // Detect file type
                let fileType = 'Unknown';
                let endMarker = -1;

                if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                    fileType = 'PNG';
                    // Find IEND chunk
                    for (let i = bytes.length - 12; i >= 0; i--) {
                        if (bytes[i] === 0x49 && bytes[i+1] === 0x45 && bytes[i+2] === 0x4E && bytes[i+3] === 0x44) {
                            endMarker = i + 8; // IEND + CRC
                            break;
                        }
                    }
                } else if (bytes[0] === 0xFF && bytes[1] === 0xD8) {
                    fileType = 'JPEG';
                    // Find EOI marker
                    for (let i = bytes.length - 2; i >= 0; i--) {
                        if (bytes[i] === 0xFF && bytes[i+1] === 0xD9) {
                            endMarker = i + 2;
                            break;
                        }
                    }
                } else if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46) {
                    fileType = 'GIF';
                    // Find trailer
                    for (let i = bytes.length - 1; i >= 0; i--) {
                        if (bytes[i] === 0x3B) {
                            endMarker = i + 1;
                            break;
                        }
                    }
                }

                output += `File Type: ${fileType}\n`;
                output += `File Size: ${bytes.length.toLocaleString()} bytes\n`;
                output += `Header: ${Array.from(bytes.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ')}\n\n`;

                if (endMarker > 0 && endMarker < bytes.length) {
                    const extraBytes = bytes.length - endMarker;
                    output += `‚ö†Ô∏è APPENDED DATA DETECTED!\n`;
                    output += `Image ends at byte ${endMarker}\n`;
                    output += `Extra bytes: ${extraBytes}\n\n`;
                    output += `Appended data preview:\n`;
                    const preview = bytes.slice(endMarker, Math.min(endMarker + 100, bytes.length));
                    output += Array.from(preview).map(b => b.toString(16).padStart(2, '0')).join(' ') + '\n\n';

                    // Try to decode as text
                    try {
                        const text = new TextDecoder('utf-8', {fatal: false}).decode(preview);
                        const printable = text.replace(/[^\x20-\x7E]/g, '¬∑');
                        output += `As text: ${printable}\n`;
                    } catch (e) {}
                } else if (endMarker === bytes.length) {
                    output += `‚úì No appended data detected\n`;
                } else {
                    output += `‚ö†Ô∏è Could not find end marker\n`;
                }

                // Check for common steg signatures
                output += `\n--- Signature Scan ---\n`;
                const signatures = [
                    { name: 'STEG header', pattern: [0x53, 0x54, 0x45, 0x47] },
                    { name: 'PK (ZIP)', pattern: [0x50, 0x4B, 0x03, 0x04] },
                    { name: 'RAR', pattern: [0x52, 0x61, 0x72, 0x21] },
                    { name: 'OpenStego', pattern: [0x6F, 0x70, 0x73, 0x74] },
                ];

                for (const sig of signatures) {
                    for (let i = 0; i < bytes.length - sig.pattern.length; i++) {
                        let match = true;
                        for (let j = 0; j < sig.pattern.length; j++) {
                            if (bytes[i + j] !== sig.pattern[j]) {
                                match = false;
                                break;
                            }
                        }
                        if (match) {
                            output += `Found "${sig.name}" at offset ${i}\n`;
                            break;
                        }
                    }
                }

                document.getElementById('file-structure-result').textContent = output;
            };
            reader.readAsArrayBuffer(file);
        }

        // ============== ZOOM/MAGNIFY ==============
        function setupZoom() {
            if (!state.analyzeCanvas) return;

            const src = state.analyzeCanvas;
            const zoomSrc = document.getElementById('zoom-source');
            zoomSrc.width = src.width;
            zoomSrc.height = src.height;
            zoomSrc.getContext('2d').drawImage(src, 0, 0);

            zoomSrc.addEventListener('mousemove', handleZoom);
            zoomSrc.addEventListener('click', handleZoom);
        }

        function handleZoom(e) {
            const zoomSrc = document.getElementById('zoom-source');
            const zoomView = document.getElementById('zoom-view');
            const zoomInfo = document.getElementById('zoom-info');

            const rect = zoomSrc.getBoundingClientRect();
            const scaleX = zoomSrc.width / rect.width;
            const scaleY = zoomSrc.height / rect.height;

            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            const ctx = zoomView.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Draw 10x10 pixel area zoomed to 160x160
            const zoomSize = 10;
            const startX = Math.max(0, x - 5);
            const startY = Math.max(0, y - 5);

            ctx.clearRect(0, 0, 160, 160);
            ctx.drawImage(
                zoomSrc,
                startX, startY, zoomSize, zoomSize,
                0, 0, 160, 160
            );

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * 16, 0);
                ctx.lineTo(i * 16, 160);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * 16);
                ctx.lineTo(160, i * 16);
                ctx.stroke();
            }

            // Get pixel info
            const srcCtx = zoomSrc.getContext('2d');
            const pixel = srcCtx.getImageData(x, y, 1, 1).data;

            zoomInfo.innerHTML = `
                Position: (${x}, ${y})<br>
                R: ${pixel[0]} (0x${pixel[0].toString(16).padStart(2,'0')}) LSB: ${pixel[0] & 1}<br>
                G: ${pixel[1]} (0x${pixel[1].toString(16).padStart(2,'0')}) LSB: ${pixel[1] & 1}<br>
                B: ${pixel[2]} (0x${pixel[2].toString(16).padStart(2,'0')}) LSB: ${pixel[2] & 1}<br>
                A: ${pixel[3]}
            `;
        }

        // ============== MATRYOSHKA EASTER EGG ==============
        function activateMatryoshka() {
            state.matryoshkaMode = true;

            // Show the hidden tab
            const tabBtn = document.getElementById('matryoshka-tab-btn');
            if (tabBtn) {
                tabBtn.style.display = '';
                // Click the tab to switch to it
                setTimeout(() => tabBtn.click(), 100);
            }

            // Show the indicator
            document.getElementById('matryoshka-indicator').classList.remove('hidden');
            document.getElementById('matryoshka-decode-btn').classList.remove('hidden');

            notify('ü™Ü MATRYOSHKA MODE ACTIVATED', 'success');
        }

        function deactivateMatryoshka() {
            state.matryoshkaMode = false;

            // Hide the tab
            const tabBtn = document.getElementById('matryoshka-tab-btn');
            if (tabBtn) tabBtn.style.display = 'none';

            // Hide the indicator
            document.getElementById('matryoshka-indicator').classList.add('hidden');
            document.getElementById('matryoshka-decode-btn').classList.add('hidden');

            // Switch back to encode tab
            document.querySelector('.tab[data-tab="encode"]').click();

            notify('ü™Ü Nested Stegg mode deactivated', 'info');
        }

        function toggleMatryoshka() {
            if (state.matryoshkaMode) {
                deactivateMatryoshka();
            } else {
                activateMatryoshka();
            }
        }

        function updateMatryoshkaDepth(value) {
            state.matryoshkaDepth = parseInt(value);
            document.getElementById('matryoshka-depth-value').textContent = value;
        }

        function addMatryoshkaCarrier(file) {
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                state.matryoshkaCarriers.push({
                    canvas: canvas,
                    name: file.name,
                    width: img.width,
                    height: img.height
                });

                refreshMatryoshkaCarrierList();
                notify(`Added carrier: ${file.name}`, 'success');
            };
            img.src = URL.createObjectURL(file);
        }

        function clearMatryoshkaCarriers() {
            state.matryoshkaCarriers = [];
            refreshMatryoshkaCarrierList();
            notify('Carriers cleared', 'info');
        }

        function refreshMatryoshkaCarrierList() {
            const list = document.getElementById('matryoshka-carrier-list');
            if (state.matryoshkaCarriers.length === 0) {
                list.innerHTML = '<div class="matryoshka-no-carriers">No carriers added</div>';
            } else {
                list.innerHTML = state.matryoshkaCarriers.map((c, i) => {
                    const layerNum = state.matryoshkaCarriers.length - i;
                    const capacity = Math.floor((c.width * c.height * 4 * 2) / 8 / 1024); // RGBA 2-bit
                    return `<div class="matryoshka-carrier-item">L${layerNum}: ${c.name.substring(0, 20)} (${c.width}x${c.height}) - ${capacity}KB</div>`;
                }).join('');
            }
        }

        async function matryoshkaEncode(payload, carriers, channelName = 'RGBA', bitsPerChannel = 2, embedMode = 'lsb') {
            // Encode from innermost to outermost
            // carriers[0] is innermost (first added is outermost, so reverse)
            let currentData = payload;
            const layerInfo = [];

            const channels = CHANNEL_PRESETS[channelName] || [0, 1, 2];

            for (let i = 0; i < carriers.length; i++) {
                const carrier = carriers[i];
                const layerNum = i + 1;

                // Calculate capacity based on embed mode
                let capacity;
                if (embedMode === 'dct') {
                    // DCT: 1 bit per 8x8 block
                    const blocksX = Math.floor(carrier.width / 8);
                    const blocksY = Math.floor(carrier.height / 8);
                    capacity = Math.floor((blocksX * blocksY) / 8) - 12; // 12 bytes header
                } else {
                    // LSB: bits per pixel per channel
                    capacity = Math.floor((carrier.width * carrier.height * channels.length * bitsPerChannel) / 8) - 64;
                }

                layerInfo.push({
                    layer: layerNum,
                    carrier: carrier.name,
                    capacity: capacity,
                    payloadSize: currentData.length,
                    fits: currentData.length <= capacity,
                    mode: embedMode
                });

                if (currentData.length > capacity) {
                    throw new Error(`Layer ${layerNum} (${carrier.name}): payload ${currentData.length} bytes exceeds capacity ${capacity} bytes (${embedMode.toUpperCase()} mode)`);
                }

                // Use the appropriate encode function
                if (embedMode === 'dct') {
                    await dctEncode(carrier.canvas, currentData, 'high');
                } else {
                    await encode(carrier.canvas, currentData, channelName, bitsPerChannel);
                }

                // If there are more carriers, convert to PNG bytes for next layer
                if (i < carriers.length - 1) {
                    const blob = await new Promise(resolve => carrier.canvas.toBlob(resolve, 'image/png'));
                    currentData = new Uint8Array(await blob.arrayBuffer());
                    layerInfo[layerInfo.length - 1].outputSize = currentData.length;
                } else {
                    layerInfo[layerInfo.length - 1].outputSize = 'final';
                }
            }

            // Return the final carrier canvas (last one in the array)
            return { canvas: carriers[carriers.length - 1].canvas, layerInfo };
        }

        async function doMatryoshkaEncode() {
            // Get depth from slider
            const depth = parseInt(document.getElementById('matryoshka-encode-depth').value);

            // Validate outer carrier
            if (!state.matryoshkaOuterCarrier) {
                notify('Upload an outer carrier image first!', 'warning');
                return;
            }

            // Get encoding options
            const embedMode = document.getElementById('matryoshka-embed-mode')?.value || 'lsb';
            const channelName = document.getElementById('matryoshka-channels').value;
            const bitsPerChannel = parseInt(document.getElementById('matryoshka-bits').value);
            const channels = CHANNEL_PRESETS[channelName] || [0, 1, 2];

            // Get payload from Matryoshka tab (not Encode tab)
            let payload;
            if (state.matryoshkaPayloadMode === 'text') {
                const text = document.getElementById('matryoshka-text').value;
                if (!text) {
                    notify('Enter a secret message first!', 'warning');
                    return;
                }
                payload = new TextEncoder().encode(text);
            } else if (state.matryoshkaPayloadFile) {
                payload = new Uint8Array(state.matryoshkaPayloadFile);
            } else {
                notify('Upload a secret file first!', 'warning');
                return;
            }

            // Check auto-size option
            const autoSize = document.getElementById('matryoshka-autosize')?.checked;

            const modeLabel = embedMode === 'dct' ? 'DCT' : `${channelName} ${bitsPerChannel}-bit LSB`;
            notify(`ü™Ü Encoding ${depth} layers with ${modeLabel}...`, 'info');

            try {
                // Calculate layer sizes from INNERMOST to OUTERMOST
                // Innermost holds payload, each outer layer holds PNG of previous
                const STEG_HEADER = embedMode === 'dct' ? 12 : 32; // DCT header is smaller
                const PNG_RATIO = 0.7;   // PNG compression estimate
                const PNG_OVERHEAD = 500; // PNG header overhead
                const BUFFER = 1.3;      // Safety buffer

                // Calculate capacity differently for DCT vs LSB
                // DCT: 1 bit per 8x8 block = 1 byte per 64*8 = 512 pixels
                // LSB: channels * bitsPerChannel / 8 bytes per pixel
                const bytesPerPixel = embedMode === 'dct'
                    ? 1 / 512  // DCT: 1 byte per 512 pixels
                    : (channels.length * bitsPerChannel) / 8;

                // Calculate minimum size for each layer
                const layerSizes = [];

                // Layer 0 (innermost) holds the actual payload
                const innerCapacityNeeded = payload.length + STEG_HEADER;
                const innerPixels = Math.ceil(innerCapacityNeeded / bytesPerPixel * BUFFER);
                const innerSide = Math.ceil(Math.sqrt(innerPixels));
                // DCT needs dimensions divisible by 8
                const innerSize = embedMode === 'dct'
                    ? Math.ceil(innerSide / 8) * 8
                    : innerSide;
                layerSizes.push({ w: Math.max(64, innerSize), h: Math.max(64, innerSize) });

                // Each subsequent layer holds the PNG of the previous layer
                for (let i = 1; i < depth; i++) {
                    const prevSize = layerSizes[i - 1];
                    // Estimate PNG size of previous layer (RGBA raw * compression + overhead)
                    const rawSize = prevSize.w * prevSize.h * 4;
                    const estimatedPngSize = Math.ceil(rawSize * PNG_RATIO) + PNG_OVERHEAD;
                    const capacityNeeded = estimatedPngSize + STEG_HEADER;
                    const pixelsNeeded = Math.ceil(capacityNeeded / bytesPerPixel * BUFFER);
                    let side = Math.ceil(Math.sqrt(pixelsNeeded));
                    if (embedMode === 'dct') side = Math.ceil(side / 8) * 8;
                    layerSizes.push({ w: side, h: side });
                }

                // The last entry is the minimum outer carrier size needed
                const minOuterSize = layerSizes[layerSizes.length - 1];
                let outerCanvas = state.matryoshkaOuterCarrier;

                // Auto-size: scale down if carrier is larger than needed
                if (autoSize) {
                    const originalWidth = outerCanvas.width;
                    const originalHeight = outerCanvas.height;

                    if (originalWidth > minOuterSize.w * 1.5 || originalHeight > minOuterSize.h * 1.5) {
                        // Scale down to just above minimum
                        const targetSize = Math.ceil(Math.max(minOuterSize.w, minOuterSize.h) * 1.1);
                        outerCanvas = scaleCanvas(outerCanvas, targetSize, targetSize);
                        notify(`üìê Auto-sized: ${originalWidth}x${originalHeight} ‚Üí ${outerCanvas.width}x${outerCanvas.height}`, 'info');
                    }
                }

                // Verify outer carrier is large enough
                const outerCapacity = outerCanvas.width * outerCanvas.height * bytesPerPixel;
                const outerNeeded = (layerSizes.length > 1)
                    ? Math.ceil(layerSizes[depth - 2].w * layerSizes[depth - 2].h * 4 * PNG_RATIO) + PNG_OVERHEAD + STEG_HEADER
                    : payload.length + STEG_HEADER;

                if (outerCapacity < outerNeeded) {
                    throw new Error(`Outer carrier too small. Need ~${Math.ceil(Math.sqrt(outerNeeded))}x${Math.ceil(Math.sqrt(outerNeeded))}, have ${outerCanvas.width}x${outerCanvas.height}`);
                }

                // Generate carriers array using calculated sizes
                const carriers = [];
                for (let i = 0; i < depth; i++) {
                    if (i === depth - 1) {
                        // Outermost layer uses the user's carrier
                        carriers.push({
                            canvas: outerCanvas,
                            name: 'outer_carrier.png',
                            width: outerCanvas.width,
                            height: outerCanvas.height
                        });
                    } else {
                        // Inner layers use auto-generated noise with calculated sizes
                        const size = layerSizes[i];
                        const noiseCanvas = generateNoiseCarrier(size.w, size.h);
                        carriers.push({
                            canvas: noiseCanvas,
                            name: `layer_${i + 1}_noise.png`,
                            width: size.w,
                            height: size.h
                        });
                    }
                }

                // Encode from innermost to outermost
                const result = await matryoshkaEncode(payload, carriers, channelName, bitsPerChannel, embedMode);

                // Download result
                result.canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `matryoshka_encoded.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');

                notify(`ü™Ü Encoded! ${depth} layers, ${modeLabel}, ${outerCanvas.width}x${outerCanvas.height}`, 'success');

            } catch (err) {
                notify('Encode error: ' + err.message, 'error');
            }
        }

        // ============== GODMODE FUNCTIONS ==============
        function activateGodmode() {
            state.godmodeActive = true;

            // Show the tab
            const tabBtn = document.getElementById('godmode-tab-btn');
            if (tabBtn) {
                tabBtn.style.display = '';
                setTimeout(() => tabBtn.click(), 100);
            }

            // Show the indicator
            document.getElementById('godmode-indicator').classList.remove('hidden');

            notify('üëÅ GODMODE ENABLED üëÅ', 'success');
        }

        function deactivateGodmode() {
            state.godmodeActive = false;

            // Hide the tab
            const tabBtn = document.getElementById('godmode-tab-btn');
            if (tabBtn) tabBtn.style.display = 'none';

            // Hide the indicator
            document.getElementById('godmode-indicator').classList.add('hidden');

            // Switch back to encode tab
            document.querySelector('.tab[data-tab="encode"]').click();

            notify('üëÅ GODMODE deactivated', 'info');
        }

        function setCipherMode(mode) {
            state.godmodeCipherMode = mode;
            document.getElementById('cipher-manual-mode').classList.toggle('hidden', mode !== 'manual');
            document.getElementById('cipher-password-mode').classList.toggle('hidden', mode !== 'password');
            document.getElementById('cipher-manual-btn').classList.toggle('btn-secondary', mode === 'password');
            document.getElementById('cipher-password-btn').classList.toggle('btn-secondary', mode === 'manual');
            updateCipherPreview();
        }

        function setGodmodePayloadMode(mode) {
            state.godmodePayloadMode = mode;
            document.getElementById('godmode-text-mode').classList.toggle('hidden', mode !== 'text');
            document.getElementById('godmode-file-mode').classList.toggle('hidden', mode !== 'file');
            document.getElementById('godmode-text-btn').classList.toggle('btn-secondary', mode === 'file');
            document.getElementById('godmode-file-btn').classList.toggle('btn-secondary', mode === 'text');
        }

        function generateRandomPattern() {
            const channelOptions = ['R', 'G', 'B', 'RG', 'RB', 'GB', 'RGB'];
            const bitOptions = [1, 1, 1, 2, 2]; // Weighted towards 1-bit for stealth
            const numSteps = 6 + Math.floor(Math.random() * 7); // 6-12 steps

            const steps = [];
            for (let i = 0; i < numSteps; i++) {
                const channel = channelOptions[Math.floor(Math.random() * channelOptions.length)];
                const bits = bitOptions[Math.floor(Math.random() * bitOptions.length)];
                steps.push(channel + bits);
            }

            const pattern = steps.join('-');
            document.getElementById('cipher-pattern').value = pattern;
            updateCipherPreview();
            notify('üé≤ Random pattern generated!', 'success');
        }

        function setGodmodeEmbedMode(mode) {
            state.godmodeEmbedMode = mode;
            document.getElementById('godmode-lsb-btn').classList.toggle('btn-secondary', mode === 'dct');
            document.getElementById('godmode-dct-btn').classList.toggle('btn-secondary', mode === 'lsb');
            const info = document.getElementById('godmode-embed-info');
            if (mode === 'lsb') {
                info.textContent = 'LSB: Higher capacity, fragile to compression';
            } else {
                info.textContent = 'DCT: Survives JPEG/Twitter compression, lower capacity';
            }
        }

        // Parse cipher pattern like "R1-G2-B1-RGB2"
        function parseCipherPattern(pattern) {
            if (!pattern || pattern.trim() === '') return null;

            const steps = [];
            const parts = pattern.toUpperCase().split('-');

            for (const part of parts) {
                const match = part.match(/^(R|G|B|RG|RB|GB|RGB|RGBA?)(\d)$/);
                if (!match) return null;

                const channelStr = match[1];
                const bits = parseInt(match[2]);

                if (bits < 1 || bits > 4) return null;

                const channels = [];
                if (channelStr.includes('R')) channels.push(0);
                if (channelStr.includes('G')) channels.push(1);
                if (channelStr.includes('B')) channels.push(2);
                if (channelStr.includes('A')) channels.push(3);

                steps.push({ channels, bits, name: part });
            }

            return steps.length > 0 ? steps : null;
        }

        // Generate cipher pattern from password
        function generatePatternFromPassword(password) {
            if (!password) return null;

            // Hash password to seed
            let seed = 0;
            for (let i = 0; i < password.length; i++) {
                seed = ((seed << 5) - seed) + password.charCodeAt(i);
                seed = seed & seed;
            }
            seed = Math.abs(seed);

            // Mulberry32 PRNG
            const random = () => {
                seed += 0x6D2B79F5;
                let t = seed;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };

            // Generate 8-16 steps
            const numSteps = 8 + Math.floor(random() * 9);
            const steps = [];
            const channelOptions = [[0], [1], [2], [0, 1], [0, 2], [1, 2], [0, 1, 2]];
            const bitOptions = [1, 1, 1, 2, 2]; // Weighted towards 1-bit for stealth

            for (let i = 0; i < numSteps; i++) {
                const channels = channelOptions[Math.floor(random() * channelOptions.length)];
                const bits = bitOptions[Math.floor(random() * bitOptions.length)];
                const name = channels.map(c => ['R', 'G', 'B', 'A'][c]).join('') + bits;
                steps.push({ channels, bits, name });
            }

            return steps;
        }

        function updateCipherPreview() {
            if (state.godmodeCipherMode === 'manual') {
                const pattern = document.getElementById('cipher-pattern').value;
                const steps = parseCipherPattern(pattern);
                const preview = document.getElementById('cipher-preview');

                if (steps) {
                    const desc = steps.map((s, i) => `${i + 1}. ${s.name}`).join(' ‚Üí ');
                    preview.innerHTML = `<span style="color: #0f0;">‚úì Valid pattern (${steps.length} steps)</span><br>${desc}`;
                } else if (pattern.trim() === '') {
                    preview.innerHTML = 'Enter a pattern like: R1-G2-B1-RGB2';
                } else {
                    preview.innerHTML = '<span style="color: #f33;">‚úó Invalid pattern</span>';
                }
            } else {
                const password = document.getElementById('cipher-password').value;
                const preview = document.getElementById('cipher-password-preview');

                if (password.length >= 4) {
                    const steps = generatePatternFromPassword(password);
                    const desc = steps.map(s => s.name).join('-');
                    preview.innerHTML = `<span style="color: #0f0;">‚úì Generated ${steps.length}-step pattern</span><br><span style="font-size: 10px;">${desc}</span>`;
                } else if (password.length > 0) {
                    preview.innerHTML = '<span style="color: #ff6;">Password too short (min 4 chars)</span>';
                } else {
                    preview.innerHTML = 'Enter a password to generate pattern';
                }
            }
        }

        // Simple XOR encryption (for demonstration - real impl would use SubtleCrypto)
        async function godmodeEncrypt(data, key) {
            const keyBytes = new TextEncoder().encode(key);
            const encrypted = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                encrypted[i] = data[i] ^ keyBytes[i % keyBytes.length];
            }
            return encrypted;
        }

        async function godmodeDecrypt(data, key) {
            return godmodeEncrypt(data, key); // XOR is symmetric
        }

        // ============== GHOST MODE FUNCTIONS ==============
        // AES-256-GCM encryption using Web Crypto API
        async function paranoidEncrypt(data, password) {
            // Derive key from password using PBKDF2
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            // Generate random salt and IV
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));

            // Derive AES key
            const aesKey = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt']
            );

            // Encrypt
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                aesKey,
                data
            );

            // Combine: salt (16) + iv (12) + ciphertext
            const result = new Uint8Array(16 + 12 + encrypted.byteLength);
            result.set(salt, 0);
            result.set(iv, 16);
            result.set(new Uint8Array(encrypted), 28);

            return result;
        }

        async function paranoidDecrypt(data, password) {
            // Extract salt, iv, and ciphertext
            const salt = data.slice(0, 16);
            const iv = data.slice(16, 28);
            const ciphertext = data.slice(28);

            // Derive key from password
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );

            const aesKey = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['decrypt']
            );

            // Decrypt
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                aesKey,
                ciphertext
            );

            return new Uint8Array(decrypted);
        }

        // Bit scrambling using Fisher-Yates shuffle with seeded PRNG
        function scrambleBits(bits, seed, reverse = false) {
            // Create seeded PRNG
            let s = seed;
            const random = () => {
                s += 0x6D2B79F5;
                let t = s;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };

            // Generate shuffle indices
            const indices = Array.from({ length: bits.length }, (_, i) => i);
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // Apply shuffle or reverse
            const result = new Array(bits.length);
            if (reverse) {
                // Unscramble: put bits back in original positions
                for (let i = 0; i < bits.length; i++) {
                    result[indices[i]] = bits[i];
                }
            } else {
                // Scramble: rearrange bits according to shuffle
                for (let i = 0; i < bits.length; i++) {
                    result[i] = bits[indices[i]];
                }
            }

            return result;
        }

        // Interleave real bits with noise decoys (50/50)
        function interleaveWithNoise(bits, seed) {
            let s = seed;
            const random = () => {
                s += 0x6D2B79F5;
                let t = s;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };

            const result = [];
            for (let i = 0; i < bits.length; i++) {
                // Add a random noise bit first
                result.push(random() > 0.5 ? 1 : 0);
                // Then add the real bit
                result.push(bits[i]);
            }
            return result;
        }

        // Remove interleaved noise (extract every other bit starting from index 1)
        function removeNoise(bits) {
            const result = [];
            for (let i = 1; i < bits.length; i += 2) {
                result.push(bits[i]);
            }
            return result;
        }

        // Hash password to numeric seed
        function passwordToSeed(password) {
            let seed = 0;
            for (let i = 0; i < password.length; i++) {
                seed = ((seed << 5) - seed) + password.charCodeAt(i);
                seed = seed & seed;
            }
            return Math.abs(seed);
        }

        // Convert data to bit stream
        function dataToBits(data) {
            const bits = [];
            for (let i = 0; i < data.length; i++) {
                for (let b = 7; b >= 0; b--) {
                    bits.push((data[i] >> b) & 1);
                }
            }
            return bits;
        }

        // Convert bit stream to data
        function bitsToData(bits) {
            const bytes = new Uint8Array(Math.ceil(bits.length / 8));
            for (let i = 0; i < bytes.length; i++) {
                let byte = 0;
                for (let b = 0; b < 8; b++) {
                    const bitIdx = i * 8 + b;
                    if (bitIdx < bits.length) {
                        byte = (byte << 1) | bits[bitIdx];
                    } else {
                        byte = byte << 1;
                    }
                }
                bytes[i] = byte;
            }
            return bytes;
        }

        // Channel cipher encode
        async function channelCipherEncode(canvas, data, steps, options = {}) {
            const { encrypt = false, key = '', density = 100, balance = true, ghost = false } = options;

            let payload = data;
            let headerMagic;

            if (ghost && key) {
                // GHOST MODE: AES-256-GCM encryption
                headerMagic = [0x47, 0x4F, 0x44, 0x50]; // "GODP" for Ghost
                payload = await paranoidEncrypt(data, key);
            } else if (encrypt && key) {
                // Basic XOR encryption
                headerMagic = [0x47, 0x4F, 0x44, 0x4D]; // "GODM"
                payload = await godmodeEncrypt(data, key);
            } else {
                headerMagic = [0x47, 0x4F, 0x44, 0x4D]; // "GODM"
            }

            // Add GODMODE header
            const header = new Uint8Array(12);
            header.set(headerMagic);
            header[4] = (payload.length >> 24) & 0xFF;
            header[5] = (payload.length >> 16) & 0xFF;
            header[6] = (payload.length >> 8) & 0xFF;
            header[7] = payload.length & 0xFF;
            header[8] = steps.length;
            header[9] = ghost ? 2 : (encrypt ? 1 : 0); // 2 = ghost
            header[10] = density;
            header[11] = balance ? 1 : 0;

            // Combine header and payload
            const fullData = new Uint8Array(header.length + payload.length);
            fullData.set(header);
            fullData.set(payload, header.length);

            // Convert to bit stream
            let bits = dataToBits(fullData);

            // GHOST MODE: Scramble PAYLOAD bits only (not header) and interleave with noise
            if (ghost && key) {
                const seed = passwordToSeed(key);
                const headerBits = bits.slice(0, 96); // 12 bytes = 96 bits
                let payloadBits = bits.slice(96);

                // Scramble only the payload
                payloadBits = scrambleBits(payloadBits, seed, false);

                // Recombine: header (unscrambled) + payload (scrambled)
                bits = [...headerBits, ...payloadBits];

                // Now interleave ALL bits with noise
                bits = interleaveWithNoise(bits, seed + 12345);
            }

            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Calculate skip factor based on density (density 100 = skip 1, density 50 = skip 2, etc)
            const skipFactor = Math.max(1, Math.floor(100 / density));

            let bitIndex = 0;
            let stepIndex = 0;
            let pixelIndex = 0;

            while (bitIndex < bits.length && pixelIndex < totalPixels) {
                const step = steps[stepIndex % steps.length];
                const baseIdx = pixelIndex * 4;

                // Embed bits in each channel of this step
                for (const ch of step.channels) {
                    if (bitIndex >= bits.length) break;

                    // Gather the bits to embed (step.bits number of bits)
                    let value = 0;
                    for (let b = 0; b < step.bits && bitIndex < bits.length; b++) {
                        value = (value << 1) | bits[bitIndex];
                        bitIndex++;
                    }

                    // Embed in the channel
                    const bitMask = (1 << step.bits) - 1;
                    const clearMask = ~bitMask & 0xFF;
                    pixels[baseIdx + ch] = (pixels[baseIdx + ch] & clearMask) | value;
                }

                // Statistical balancing on alpha channel (won't affect our data)
                if (balance && Math.random() > 0.7) {
                    if (pixels[baseIdx + 3] > 1 && pixels[baseIdx + 3] < 254) {
                        pixels[baseIdx + 3] += (Math.random() > 0.5 ? 1 : -1);
                    }
                }

                stepIndex++;
                pixelIndex += skipFactor;
            }

            if (bitIndex < bits.length) {
                throw new Error(`Image too small: need ${Math.ceil(bits.length / 8)} bytes capacity`);
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Channel cipher decode
        async function channelCipherDecode(canvas, steps, key = '') {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const totalPixels = canvas.width * canvas.height;

            // Extract all bits using the cipher pattern
            function extractAllBits(skipFactor = 1) {
                const bits = [];
                let stepIndex = 0;
                let pixelIndex = 0;

                while (pixelIndex < totalPixels) {
                    const step = steps[stepIndex % steps.length];
                    const baseIdx = pixelIndex * 4;

                    for (const ch of step.channels) {
                        const bitMask = (1 << step.bits) - 1;
                        const value = pixels[baseIdx + ch] & bitMask;

                        // Extract individual bits from the value (MSB first)
                        for (let b = step.bits - 1; b >= 0; b--) {
                            bits.push((value >> b) & 1);
                        }
                    }

                    stepIndex++;
                    pixelIndex += skipFactor;
                }

                return bits;
            }

            // Helper to check magic header
            function checkMagic(header, magic) {
                return header[0] === magic[0] && header[1] === magic[1] &&
                       header[2] === magic[2] && header[3] === magic[3];
            }

            const GODM_MAGIC = [0x47, 0x4F, 0x44, 0x4D]; // "GODM"
            const GODP_MAGIC = [0x47, 0x4F, 0x44, 0x50]; // "GODP" (Ghost)

            // Try with density 100 first (most common case, skipFactor=1)
            let skipFactor = 1;
            let bits = extractAllBits(skipFactor);

            // If password provided, try Ghost Mode first
            let isGhostMode = false;
            let header;

            if (key) {
                // Try Ghost Mode: remove noise first, then check header
                // Header is NOT scrambled, only payload is scrambled
                const seed = passwordToSeed(key);
                let ghostBits = removeNoise(bits);
                header = bitsToData(ghostBits.slice(0, 96));

                if (checkMagic(header, GODP_MAGIC)) {
                    isGhostMode = true;
                    bits = ghostBits; // Use the de-noised bits
                }
            }

            // If not Ghost Mode, check for regular GODM
            if (!isGhostMode) {
                header = bitsToData(bits.slice(0, 96));

                if (!checkMagic(header, GODM_MAGIC)) {
                    throw new Error('GODMODE header not found - wrong pattern or password?');
                }
            }

            const dataLength = (header[4] << 24) | (header[5] << 16) | (header[6] << 8) | header[7];
            const encrypted = header[9] === 1;
            const storedDensity = header[10] || 100;

            // Sanity check
            if (dataLength <= 0 || dataLength > 100 * 1024 * 1024) {
                throw new Error('Invalid data length in header');
            }

            // If density was different, re-extract with correct skip factor
            const actualSkipFactor = Math.max(1, Math.floor(100 / storedDensity));
            if (actualSkipFactor !== skipFactor) {
                bits = extractAllBits(actualSkipFactor);
                if (isGhostMode) {
                    bits = removeNoise(bits);
                }
            }

            // For Ghost Mode: unscramble payload bits only
            let result;
            if (isGhostMode) {
                const seed = passwordToSeed(key);
                const headerBits = bits.slice(0, 96);
                const payloadBitCount = dataLength * 8;
                let payloadBits = bits.slice(96, 96 + payloadBitCount);

                // Unscramble the payload
                payloadBits = scrambleBits(payloadBits, seed, true);

                // Combine header + unscrambled payload
                const totalBits = [...headerBits, ...payloadBits];
                result = bitsToData(totalBits);
            } else {
                // Regular mode: just extract the bits
                const totalBits = (12 + dataLength) * 8;
                result = bitsToData(bits.slice(0, totalBits));
            }

            // Extract payload (skip header)
            let payload = result.slice(12, 12 + dataLength);

            // Decrypt based on mode
            if (isGhostMode && key) {
                // Ghost Mode: AES-256-GCM decrypt
                payload = await paranoidDecrypt(payload, key);
            } else if (encrypted && key) {
                // Normal mode: XOR decrypt
                payload = await godmodeDecrypt(payload, key);
            }

            return payload;
        }

        // ============== DCT GODMODE FUNCTIONS ==============
        // DCT basis functions for 8x8 block
        function dctCoeff(u, v, x, y) {
            const cu = u === 0 ? 1 / Math.sqrt(2) : 1;
            const cv = v === 0 ? 1 / Math.sqrt(2) : 1;
            return 0.25 * cu * cv *
                   Math.cos((2 * x + 1) * u * Math.PI / 16) *
                   Math.cos((2 * y + 1) * v * Math.PI / 16);
        }

        // Forward DCT on 8x8 block
        function forwardDCT(block) {
            const dct = new Array(64).fill(0);
            for (let v = 0; v < 8; v++) {
                for (let u = 0; u < 8; u++) {
                    let sum = 0;
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            sum += block[y * 8 + x] * dctCoeff(u, v, x, y);
                        }
                    }
                    dct[v * 8 + u] = sum;
                }
            }
            return dct;
        }

        // Inverse DCT on 8x8 block
        function inverseDCT(dct) {
            const block = new Array(64).fill(0);
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    let sum = 0;
                    for (let v = 0; v < 8; v++) {
                        for (let u = 0; u < 8; u++) {
                            sum += dct[v * 8 + u] * dctCoeff(u, v, x, y);
                        }
                    }
                    block[y * 8 + x] = Math.round(sum);
                }
            }
            return block;
        }

        // GODMODE DCT - Uses same proven DCT method as regular DCT, but with redundancy
        // for surviving social media compression

        // Robust DCT configuration - designed to survive X/Twitter QF 85 compression
        const ROBUST_DCT_CONFIG = {
            // Embedding strength (must match decode) - same as regular DCT 'high'
            STRENGTH: 50,
            // Number of blocks per bit for redundancy (odd number for majority voting)
            REDUNDANCY: 5,
            // Use same position as regular DCT
            EMBED_POSITION: [0, 1],
            // Magic header for robust DCT
            MAGIC: [0x52, 0x44, 0x43, 0x54], // "RDCT" = Robust DCT
        };

        // Pre-condition image by simulating JPEG compression (stabilizes coefficients)
        async function preconditionImage(canvas, quality = 85) {
            return new Promise((resolve) => {
                const dataUrl = canvas.toDataURL('image/jpeg', quality / 100);
                const img = new Image();
                img.onload = () => {
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = canvas.width;
                    newCanvas.height = canvas.height;
                    newCanvas.getContext('2d').drawImage(img, 0, 0);
                    resolve(newCanvas);
                };
                img.src = dataUrl;
            });
        }

        // DCT-based channel cipher encode - Uses SAME method as working regular DCT + redundancy
        async function dctChannelCipherEncode(canvas, data, steps, options = {}) {
            const { encrypt = false, key = '', precondition = true } = options;
            const CFG = ROBUST_DCT_CONFIG;

            // Pre-condition image to stabilize DCT coefficients
            if (precondition) {
                let workCanvas = await preconditionImage(canvas, 85);
                canvas.getContext('2d').drawImage(workCanvas, 0, 0);
            }

            // Build header: RDCT magic + length + flags
            const header = new Uint8Array(16);
            header.set(CFG.MAGIC);
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;
            header[8] = steps.length;
            header[9] = encrypt ? 1 : 0;
            header[10] = CFG.REDUNDANCY;
            header[11] = CFG.STRENGTH;
            header[12] = precondition ? 1 : 0;
            // 13-15 reserved

            // Optionally encrypt payload
            let payload = data;
            if (encrypt && key) {
                payload = await godmodeEncrypt(data, key);
            }

            // Combine header and payload
            const fullData = new Uint8Array(header.length + payload.length);
            fullData.set(header);
            fullData.set(payload, header.length);

            // Convert to bit stream
            const bits = dataToBits(fullData);

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            // Use same DCT matrix as regular DCT
            const dctMatrix = createDCTMatrix(8);

            // Calculate blocks available
            const blocksX = Math.floor(width / 8);
            const blocksY = Math.floor(height / 8);
            const totalBlocks = blocksX * blocksY;

            // Each bit needs REDUNDANCY blocks
            const bitsCapacity = Math.floor(totalBlocks / CFG.REDUNDANCY);

            if (bits.length > bitsCapacity) {
                throw new Error(`Image too small: need ${bits.length * CFG.REDUNDANCY} blocks, have ${totalBlocks}`);
            }

            const [embedRow, embedCol] = CFG.EMBED_POSITION;

            // Embed each bit in REDUNDANCY consecutive blocks
            let blockIndex = 0;

            for (let bitIdx = 0; bitIdx < bits.length; bitIdx++) {
                const bit = bits[bitIdx];

                // Embed this bit in REDUNDANCY blocks
                for (let r = 0; r < CFG.REDUNDANCY && blockIndex < totalBlocks; r++) {
                    const bx = blockIndex % blocksX;
                    const by = Math.floor(blockIndex / blocksX);
                    blockIndex++;

                    // Extract luminance block - USE 2D ARRAY like regular DCT
                    const block = [];
                    for (let y = 0; y < 8; y++) {
                        block[y] = [];
                        for (let x = 0; x < 8; x++) {
                            const px = bx * 8 + x;
                            const py = by * 8 + y;
                            const idx = (py * width + px) * 4;
                            block[y][x] = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                        }
                    }

                    // Forward DCT - USE SAME FUNCTION as regular DCT
                    const dctBlock = dct2D(block, dctMatrix);

                    // QUANTIZATION-BASED EMBEDDING - SAME as regular DCT (this works!)
                    const coeff = dctBlock[embedRow][embedCol];
                    const q = Math.floor(coeff / CFG.STRENGTH);
                    dctBlock[embedRow][embedCol] = (q + (bit ? 0.75 : 0.25)) * CFG.STRENGTH;

                    // Inverse DCT - USE SAME FUNCTION as regular DCT
                    const reconstructed = idct2D(dctBlock, dctMatrix);

                    // Write back - adjust RGB proportionally to match new luminance
                    for (let y = 0; y < 8; y++) {
                        for (let x = 0; x < 8; x++) {
                            const px = bx * 8 + x;
                            const py = by * 8 + y;
                            const idx = (py * width + px) * 4;

                            const oldLum = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                            const newLum = Math.max(0, Math.min(255, reconstructed[y][x]));
                            const ratio = oldLum > 1 ? newLum / oldLum : 1;

                            pixels[idx] = Math.max(0, Math.min(255, Math.round(pixels[idx] * ratio)));
                            pixels[idx + 1] = Math.max(0, Math.min(255, Math.round(pixels[idx + 1] * ratio)));
                            pixels[idx + 2] = Math.max(0, Math.min(255, Math.round(pixels[idx + 2] * ratio)));
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // DCT-based channel cipher decode - Uses SAME method as working regular DCT + majority voting
        async function dctChannelCipherDecode(canvas, steps, key = '') {
            const CFG = ROBUST_DCT_CONFIG;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            // Use same DCT matrix as regular DCT
            const dctMatrix = createDCTMatrix(8);

            const blocksX = Math.floor(width / 8);
            const blocksY = Math.floor(height / 8);
            const totalBlocks = blocksX * blocksY;

            const [embedRow, embedCol] = CFG.EMBED_POSITION;

            // Extract raw bits from all blocks using SAME method as regular DCT
            const rawBits = [];

            for (let blockIndex = 0; blockIndex < totalBlocks; blockIndex++) {
                const bx = blockIndex % blocksX;
                const by = Math.floor(blockIndex / blocksX);

                // Extract luminance block - 2D array
                const block = [];
                for (let y = 0; y < 8; y++) {
                    block[y] = [];
                    for (let x = 0; x < 8; x++) {
                        const px = bx * 8 + x;
                        const py = by * 8 + y;
                        const idx = (py * width + px) * 4;
                        block[y][x] = 0.299 * pixels[idx] + 0.587 * pixels[idx + 1] + 0.114 * pixels[idx + 2];
                    }
                }

                // Forward DCT
                const dctBlock = dct2D(block, dctMatrix);

                // QUANTIZATION-BASED DECODING - SAME as regular DCT
                const coeff = dctBlock[embedRow][embedCol];
                const q = Math.floor(coeff / CFG.STRENGTH);
                const remainder = coeff - q * CFG.STRENGTH;
                rawBits.push(remainder >= CFG.STRENGTH / 2 ? 1 : 0);
            }

            // Apply majority voting: each bit was embedded in REDUNDANCY blocks
            const decodedBits = [];
            const redundancy = CFG.REDUNDANCY;

            for (let i = 0; i + redundancy <= rawBits.length; i += redundancy) {
                let ones = 0;
                for (let r = 0; r < redundancy; r++) {
                    ones += rawBits[i + r];
                }
                // Majority vote
                decodedBits.push(ones > redundancy / 2 ? 1 : 0);
            }

            // Convert first 128 bits (16 bytes) to header
            if (decodedBits.length < 128) {
                throw new Error('Not enough data for header');
            }

            const header = bitsToData(decodedBits.slice(0, 128));

            // Check for RDCT magic (new robust format)
            const isRobust = header[0] === 0x52 && header[1] === 0x44 &&
                            header[2] === 0x43 && header[3] === 0x54;

            // Also check for legacy GDCT magic for backwards compatibility
            const isLegacy = header[0] === 0x47 && header[1] === 0x44 &&
                            header[2] === 0x43 && header[3] === 0x54;

            if (!isRobust && !isLegacy) {
                throw new Error('GODMODE DCT header not found - image may be corrupted or not encoded. Got: ' +
                    Array.from(header.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(' '));
            }

            const headerSize = isRobust ? 16 : 12;
            const dataLength = (header[4] << 24) | (header[5] << 16) | (header[6] << 8) | header[7];
            const encrypted = header[9] === 1;

            if (dataLength <= 0 || dataLength > 100 * 1024 * 1024) {
                throw new Error('Invalid data length in header: ' + dataLength);
            }

            // Extract payload
            const totalBits = (headerSize + dataLength) * 8;
            if (decodedBits.length < totalBits) {
                throw new Error('Not enough data for payload');
            }

            const result = bitsToData(decodedBits.slice(0, totalBits));
            let payload = result.slice(headerSize, headerSize + dataLength);

            // Decrypt if needed
            if (encrypted && key) {
                payload = await godmodeDecrypt(payload, key);
            }

            return payload;
        }

        async function doGodmodeEncode() {
            if (!state.godmodeCarrierCanvas) {
                notify('Load a carrier image first!', 'error');
                return;
            }

            // Get cipher steps
            let steps;
            let key = '';
            if (state.godmodeCipherMode === 'manual') {
                const pattern = document.getElementById('cipher-pattern').value;
                steps = parseCipherPattern(pattern);
                if (!steps) {
                    notify('Invalid cipher pattern!', 'error');
                    return;
                }
            } else {
                const password = document.getElementById('cipher-password').value;
                if (password.length < 4) {
                    notify('Password must be at least 4 characters!', 'error');
                    return;
                }
                steps = generatePatternFromPassword(password);
                key = password;
            }

            // Get payload
            let data;
            if (state.godmodePayloadMode === 'text') {
                const text = document.getElementById('godmode-text').value;
                if (!text) {
                    notify('Enter a secret message!', 'error');
                    return;
                }
                data = new TextEncoder().encode(text);
            } else {
                if (!state.godmodePayloadFile) {
                    notify('Select a file to hide!', 'error');
                    return;
                }
                const fnameBytes = new TextEncoder().encode(state.godmodePayloadFileName);
                data = new Uint8Array(1 + fnameBytes.length + state.godmodePayloadFile.length);
                data[0] = fnameBytes.length;
                data.set(fnameBytes, 1);
                data.set(state.godmodePayloadFile, 1 + fnameBytes.length);
            }

            // Get options
            const encrypt = document.getElementById('godmode-encrypt').checked;
            const balance = document.getElementById('godmode-balance').checked;
            const density = parseInt(document.getElementById('godmode-density').value);
            const ghost = document.getElementById('godmode-ghost').checked;
            const embedMode = state.godmodeEmbedMode;

            // Ghost mode requires password
            if (ghost && state.godmodeCipherMode !== 'password') {
                notify('üëª Ghost Mode requires password mode!', 'error');
                return;
            }

            notify(`üëÅ Encoding with ${embedMode.toUpperCase()} channel cipher${ghost ? ' + üëª Ghost Mode' : ''}...`, 'info');

            try {
                // Clone canvas
                const resultCanvas = document.createElement('canvas');
                resultCanvas.width = state.godmodeCarrierCanvas.width;
                resultCanvas.height = state.godmodeCarrierCanvas.height;
                resultCanvas.getContext('2d').drawImage(state.godmodeCarrierCanvas, 0, 0);

                if (embedMode === 'dct') {
                    await dctChannelCipherEncode(resultCanvas, data, steps, {
                        encrypt,
                        key
                    });
                } else {
                    await channelCipherEncode(resultCanvas, data, steps, {
                        encrypt,
                        key,
                        density,
                        balance,
                        ghost
                    });
                }

                // Download
                const ghostSuffix = ghost ? '_ghost' : '';
                resultCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `godmode_${embedMode}${ghostSuffix}_encoded.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');

                const modeInfo = embedMode === 'dct' ? 'DCT (compression-resistant)' : `LSB ${density}% density`;
                const ghostInfo = ghost ? ' + üëª Ghost Mode' : '';
                notify(`üëÅ GODMODE encoded! ${steps.length}-step cipher, ${modeInfo}${ghostInfo}`, 'success');

            } catch (err) {
                notify('Encode error: ' + err.message, 'error');
            }
        }

        async function doGodmodeDecode() {
            if (!state.godmodeDecodeCanvas) {
                notify('Load an image to decode!', 'error');
                return;
            }

            const cipherKey = document.getElementById('cipher-decode-key').value;
            if (!cipherKey) {
                notify('Enter the cipher pattern or password!', 'error');
                return;
            }

            // Determine if it's a pattern or password
            let steps;
            let key = '';

            // Try parsing as pattern first
            steps = parseCipherPattern(cipherKey);
            if (!steps) {
                // Treat as password
                if (cipherKey.length < 4) {
                    notify('Invalid pattern and password too short!', 'error');
                    return;
                }
                steps = generatePatternFromPassword(cipherKey);
                key = cipherKey;
            }

            notify('üëÅ Decoding channel cipher...', 'info');

            try {
                let data;
                let usedMode = 'LSB';

                // Try LSB first, then DCT
                try {
                    data = await channelCipherDecode(state.godmodeDecodeCanvas, steps, key);
                    usedMode = 'LSB';
                } catch (lsbErr) {
                    // Try DCT if LSB fails
                    try {
                        data = await dctChannelCipherDecode(state.godmodeDecodeCanvas, steps, key);
                        usedMode = 'DCT';
                    } catch (dctErr) {
                        throw new Error('Neither LSB nor DCT header found - wrong pattern?');
                    }
                }

                state.godmodeDecodedData = data;

                // Check if it's a file (has filename prefix) using shared function
                const { filename, fileData } = extractFileFromData(data);

                // Display result
                const resultDiv = document.getElementById('godmode-decode-result');
                const outputPre = document.getElementById('godmode-decode-output');

                resultDiv.classList.remove('hidden');

                if (filename) {
                    outputPre.textContent = `File: ${filename} (${formatSize(fileData.length)})\n\nPreview:\n${new TextDecoder('utf-8', { fatal: false }).decode(fileData.slice(0, 500))}`;
                    state.godmodeDecodedData = fileData;
                    state.godmodeDecodedFilename = filename;
                } else {
                    const text = new TextDecoder('utf-8', { fatal: false }).decode(data);
                    outputPre.textContent = text;
                    state.godmodeDecodedFilename = 'decoded.txt';
                }

                notify(`üëÅ GODMODE decoded (${usedMode} mode)!`, 'success');

            } catch (err) {
                notify('Decode error: ' + err.message, 'error');
            }
        }

        function downloadGodmodeDecoded() {
            if (!state.godmodeDecodedData) {
                notify('No decoded data!', 'error');
                return;
            }

            const blob = new Blob([state.godmodeDecodedData]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = state.godmodeDecodedFilename || 'decoded.bin';
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============== AUDIO STEGANOGRAPHY ==============

        // Switch to audio mode for a panel
        function switchToAudioMode(panel = 'encode') {
            state.mediaType = 'audio';

            if (panel === 'encode') {
                // Update card styling
                const card = document.getElementById('encode-carrier-card');
                card.style.borderColor = '#00d4ff55';

                // Update title
                document.getElementById('encode-carrier-title').textContent = 'üéµ Audio Carrier';
                document.getElementById('encode-carrier-title').style.color = '#00d4ff';

                // Hide image preview, show audio preview
                document.getElementById('encode-carrier-preview').classList.add('hidden');
                document.getElementById('encode-audio-preview').classList.remove('hidden');

                // Hide generate carrier (image only)
                document.getElementById('encode-generate-carrier').classList.add('hidden');

                // Switch method groups
                document.getElementById('image-method-group').classList.add('hidden');
                document.getElementById('audio-method-group').classList.remove('hidden');

                // Hide image options, show audio LSB options by default
                document.getElementById('lsb-options').classList.add('hidden');
                document.getElementById('dct-options').classList.add('hidden');
                document.getElementById('spread-options').classList.add('hidden');
                document.getElementById('palette-options').classList.add('hidden');
                document.getElementById('chroma-options').classList.add('hidden');

                document.getElementById('audio-lsb-options').classList.remove('hidden');
                document.getElementById('audio-fft-options').classList.add('hidden');
                document.getElementById('audio-echo-options').classList.add('hidden');
                document.getElementById('audio-specart-options').classList.add('hidden');

                // Update settings title
                document.getElementById('encode-settings-title').style.color = '#00d4ff';
            } else if (panel === 'decode') {
                // Update card styling
                const card = document.getElementById('decode-media-card');
                card.style.borderColor = '#00d4ff55';

                // Update title
                document.getElementById('decode-media-title').textContent = 'üéµ Stego Audio';
                document.getElementById('decode-media-title').style.color = '#00d4ff';

                // Hide image preview, show audio preview
                document.getElementById('decode-image-preview').classList.add('hidden');
                document.getElementById('decode-audio-preview').classList.remove('hidden');

                // Switch method groups
                document.getElementById('image-decode-method-group').classList.add('hidden');
                document.getElementById('audio-decode-method-group').classList.remove('hidden');

                // Hide image decode options
                document.getElementById('lsb-decode-options').classList.add('hidden');
                document.getElementById('dct-decode-options').classList.add('hidden');
                document.getElementById('spread-decode-options').classList.add('hidden');
                document.getElementById('palette-decode-options').classList.add('hidden');
                document.getElementById('chroma-decode-options').classList.add('hidden');

                // Show audio decode LSB options by default
                document.getElementById('audio-decode-lsb-options').classList.remove('hidden');

                // Update options card title
                document.getElementById('decode-options-title').style.color = '#00d4ff';
            } else if (panel === 'analyze') {
                // Update card styling
                const card = document.getElementById('analyze-media-card');
                card.style.borderColor = '#00d4ff55';

                // Update title
                document.getElementById('analyze-media-title').textContent = 'üéµ Audio to Analyze';
                document.getElementById('analyze-media-title').style.color = '#00d4ff';

                // Hide image preview, show audio preview
                document.getElementById('analyze-image-preview').classList.add('hidden');
                document.getElementById('analyze-audio-preview').classList.remove('hidden');

                // Show audio analysis section, hide image analysis sections
                document.getElementById('audio-analysis-section').classList.remove('hidden');
                document.getElementById('channel-layers-section').classList.add('hidden');

                // Update results card title
                document.getElementById('analyze-results-title').style.color = '#00d4ff';
            }

            notify('üéµ Audio mode activated', 'info');
        }

        // Switch to image mode for a panel
        function switchToImageMode(panel = 'encode') {
            state.mediaType = 'image';

            if (panel === 'encode') {
                // Reset card styling
                const card = document.getElementById('encode-carrier-card');
                card.style.borderColor = '';

                // Update title
                document.getElementById('encode-carrier-title').textContent = 'Carrier Media';
                document.getElementById('encode-carrier-title').style.color = '';

                // Show image preview, hide audio preview
                document.getElementById('encode-carrier-preview').classList.remove('hidden');
                document.getElementById('encode-audio-preview').classList.add('hidden');

                // Show generate carrier
                document.getElementById('encode-generate-carrier').classList.remove('hidden');

                // Switch method groups
                document.getElementById('image-method-group').classList.remove('hidden');
                document.getElementById('audio-method-group').classList.add('hidden');

                // Show image options, hide audio options
                document.getElementById('lsb-options').classList.remove('hidden');
                document.getElementById('dct-options').classList.add('hidden');
                document.getElementById('spread-options').classList.add('hidden');
                document.getElementById('palette-options').classList.add('hidden');
                document.getElementById('chroma-options').classList.add('hidden');

                document.getElementById('audio-lsb-options').classList.add('hidden');
                document.getElementById('audio-fft-options').classList.add('hidden');
                document.getElementById('audio-echo-options').classList.add('hidden');
                document.getElementById('audio-specart-options').classList.add('hidden');

                // Reset settings title
                document.getElementById('encode-settings-title').style.color = '';
            } else if (panel === 'decode') {
                // Reset card styling
                const card = document.getElementById('decode-media-card');
                card.style.borderColor = '';

                // Update title
                document.getElementById('decode-media-title').textContent = 'Stego Media';
                document.getElementById('decode-media-title').style.color = '';

                // Show image preview, hide audio preview
                document.getElementById('decode-image-preview').classList.remove('hidden');
                document.getElementById('decode-audio-preview').classList.add('hidden');

                // Switch method groups
                document.getElementById('image-decode-method-group').classList.remove('hidden');
                document.getElementById('audio-decode-method-group').classList.add('hidden');

                // Hide audio decode options
                document.getElementById('audio-decode-lsb-options').classList.add('hidden');
                document.getElementById('audio-decode-fft-options').classList.add('hidden');
                document.getElementById('audio-decode-echo-options').classList.add('hidden');

                // Reset options card title
                document.getElementById('decode-options-title').style.color = '';
            } else if (panel === 'analyze') {
                // Reset card styling
                const card = document.getElementById('analyze-media-card');
                card.style.borderColor = '';

                // Update title
                document.getElementById('analyze-media-title').textContent = 'Media to Analyze';
                document.getElementById('analyze-media-title').style.color = '';

                // Show image preview, hide audio preview
                document.getElementById('analyze-image-preview').classList.remove('hidden');
                document.getElementById('analyze-audio-preview').classList.add('hidden');

                // Hide audio analysis section, show image analysis sections
                document.getElementById('audio-analysis-section').classList.add('hidden');
                document.getElementById('channel-layers-section').classList.remove('hidden');

                // Reset results card title
                document.getElementById('analyze-results-title').style.color = '';
            }
        }

        // Load audio file for encode panel
        async function loadAudioCarrier(file) {
            try {
                notify('Loading audio...', 'info');
                const audioCtx = getAudioContext();
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

                state.audioBuffer = audioBuffer;

                // Display metadata
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const channels = audioBuffer.numberOfChannels;

                document.getElementById('encode-audio-duration').textContent = formatAudioTime(duration);
                document.getElementById('encode-audio-metadata').innerHTML =
                    `${file.name}<br>${sampleRate}Hz | ${channels === 1 ? 'Mono' : 'Stereo'} | ${formatAudioTime(duration)}`;

                // Draw waveform
                drawWaveformOn(audioBuffer, 'encode-audio-waveform');

                // Draw spectrogram
                drawSpectrogramOn(audioBuffer, 'encode-audio-spectrogram');

                // Update capacity
                updateAudioCapacity();

                notify('üéµ Audio loaded successfully!', 'success');
            } catch (e) {
                notify('Error loading audio: ' + e.message, 'error');
            }
        }

        // Load audio file for decode panel
        async function loadAudioForDecode(file) {
            try {
                notify('Loading audio...', 'info');
                const arrayBuffer = await file.arrayBuffer();

                // Try to parse WAV directly for accurate LSB decoding
                let rawWavData = null;
                const isWav = file.name.toLowerCase().endsWith('.wav') || file.type === 'audio/wav';

                if (isWav) {
                    try {
                        rawWavData = decodeWAVFile(arrayBuffer.slice(0)); // Clone buffer
                        state.decodeRawSamples = rawWavData.samples;
                        console.log('WAV parsed directly:', rawWavData.sampleRate + 'Hz,', rawWavData.samples.length, 'samples');
                    } catch (e) {
                        console.warn('Direct WAV parse failed, falling back to Web Audio:', e);
                    }
                }

                // Also load via Web Audio API for playback/visualization
                const audioCtx = getAudioContext();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                state.decodeAudioBuffer = audioBuffer;

                // Display metadata
                const duration = audioBuffer.duration;
                const sampleRate = rawWavData ? rawWavData.sampleRate : audioBuffer.sampleRate;
                const channels = audioBuffer.numberOfChannels;

                document.getElementById('decode-audio-duration').textContent = formatAudioTime(duration);
                document.getElementById('decode-audio-metadata').innerHTML =
                    `${file.name}<br>${sampleRate}Hz | ${channels === 1 ? 'Mono' : 'Stereo'} | ${formatAudioTime(duration)}` +
                    (rawWavData ? '<br><span style="color: #00ff41;">‚úì Direct WAV decode available</span>' : '');

                // Draw waveform
                drawWaveformOn(audioBuffer, 'decode-audio-waveform');

                // Draw spectrogram
                drawSpectrogramOn(audioBuffer, 'decode-audio-spectrogram');

                // Check for audio steg headers using raw samples if available
                const detection = document.getElementById('decode-detection');
                let headerCheck;

                if (rawWavData) {
                    // Use raw 16-bit samples for accurate header check
                    headerCheck = checkAudioStegHeaderRaw(rawWavData.samples);
                } else {
                    const samples = audioBuffer.getChannelData(0);
                    headerCheck = checkAudioStegHeader(samples);
                }

                if (headerCheck.found) {
                    detection.innerHTML = `<div style="color: var(--secondary); background: rgba(0,212,255,0.1); padding: 8px; border: 1px solid var(--secondary); border-radius: 4px;">
                        ‚úì ${headerCheck.type} audio steg detected<br>
                        Method: ${headerCheck.method}<br>
                        Payload: ${formatSize(headerCheck.length)}
                    </div>`;
                } else {
                    detection.innerHTML = `<div style="color: var(--warning); background: rgba(255,255,0,0.1); padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
                        ‚ö† No audio steg header detected - try auto-detect
                    </div>`;
                }

                notify('üéµ Audio loaded for decode!', 'success');
            } catch (e) {
                notify('Error loading audio: ' + e.message, 'error');
            }
        }

        // Check audio steg header from raw 16-bit samples
        function checkAudioStegHeaderRaw(samples) {
            // Extract first 64 bits (8 bytes) using 2 bits per sample
            const bits = [];
            for (let i = 0; i < 32 && i < samples.length; i++) {
                bits.push(samples[i] & 1);
                bits.push((samples[i] >> 1) & 1);
            }

            // Convert to bytes
            const bytes = [];
            for (let i = 0; i + 7 < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }

            // Check for ALSB magic
            if (bytes[0] === 0x41 && bytes[1] === 0x4C && bytes[2] === 0x53 && bytes[3] === 0x42) {
                const length = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];
                return { found: true, type: 'STEG', method: 'Audio LSB', length };
            }

            return { found: false };
        }

        // Load audio file for analyze panel
        async function loadAudioForAnalyze(file) {
            try {
                notify('Loading audio...', 'info');
                const audioCtx = getAudioContext();
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

                state.analyzeAudioBuffer = audioBuffer;

                // Display metadata
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const channels = audioBuffer.numberOfChannels;

                document.getElementById('analyze-audio-duration').textContent = formatAudioTime(duration);
                document.getElementById('analyze-audio-metadata').innerHTML =
                    `${file.name}<br>${sampleRate}Hz | ${channels === 1 ? 'Mono' : 'Stereo'} | ${formatAudioTime(duration)}`;

                // Draw preview waveform
                drawWaveformOn(audioBuffer, 'analyze-audio-waveform');

                notify('üéµ Audio loaded for analysis!', 'success');
            } catch (e) {
                notify('Error loading audio: ' + e.message, 'error');
            }
        }

        // Check for audio steganography headers
        function checkAudioStegHeader(samples) {
            // Convert first few samples to bits and check for magic headers
            const bitStream = [];
            const numSamples = Math.min(samples.length, 512);

            for (let i = 0; i < numSamples; i++) {
                // Convert float sample to 16-bit integer
                const intSample = Math.round(samples[i] * 32767);
                bitStream.push(intSample & 1);
            }

            // Check for ALSB magic (0x41, 0x4C, 0x53, 0x42)
            const magicALSB = [0x41, 0x4C, 0x53, 0x42];
            let foundALSB = true;
            for (let b = 0; b < 4; b++) {
                let byte = 0;
                for (let bit = 0; bit < 8; bit++) {
                    if (bitStream[b * 8 + bit]) byte |= (1 << bit);
                }
                if (byte !== magicALSB[b]) {
                    foundALSB = false;
                    break;
                }
            }

            if (foundALSB) {
                // Read length
                let length = 0;
                for (let b = 0; b < 4; b++) {
                    let byte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        if (bitStream[32 + b * 8 + bit]) byte |= (1 << bit);
                    }
                    length |= (byte << (b * 8));
                }
                return { found: true, type: 'STEG', method: 'Audio LSB', length };
            }

            // Check for AFFT magic (0x41, 0x46, 0x46, 0x54)
            // Would need FFT analysis - simplified check here

            return { found: false };
        }

        // Toggle decode audio playback
        function toggleDecodeAudioPlayback() {
            if (!state.decodeAudioBuffer) return;

            const audioCtx = getAudioContext();

            if (state.decodeAudioIsPlaying) {
                if (state.decodeAudioSource) {
                    state.decodeAudioSource.stop();
                }
                state.decodeAudioIsPlaying = false;
                document.getElementById('decode-audio-play-btn').textContent = '‚ñ∂';
            } else {
                state.decodeAudioSource = audioCtx.createBufferSource();
                state.decodeAudioSource.buffer = state.decodeAudioBuffer;
                state.decodeAudioSource.connect(audioCtx.destination);
                state.decodeAudioSource.start();
                state.decodeAudioIsPlaying = true;
                document.getElementById('decode-audio-play-btn').textContent = '‚è∏';
                state.decodeAudioSource.onended = () => {
                    state.decodeAudioIsPlaying = false;
                    document.getElementById('decode-audio-play-btn').textContent = '‚ñ∂';
                };
            }
        }

        // Toggle analyze audio playback
        function toggleAnalyzeAudioPlayback() {
            if (!state.analyzeAudioBuffer) return;

            const audioCtx = getAudioContext();

            if (state.analyzeAudioIsPlaying) {
                if (state.analyzeAudioSource) {
                    state.analyzeAudioSource.stop();
                }
                state.analyzeAudioIsPlaying = false;
                document.getElementById('analyze-audio-play-btn').textContent = '‚ñ∂';
            } else {
                state.analyzeAudioSource = audioCtx.createBufferSource();
                state.analyzeAudioSource.buffer = state.analyzeAudioBuffer;
                state.analyzeAudioSource.connect(audioCtx.destination);
                state.analyzeAudioSource.start();
                state.analyzeAudioIsPlaying = true;
                document.getElementById('analyze-audio-play-btn').textContent = '‚è∏';
                state.analyzeAudioSource.onended = () => {
                    state.analyzeAudioIsPlaying = false;
                    document.getElementById('analyze-audio-play-btn').textContent = '‚ñ∂';
                };
            }
        }

        // Update audio decode method options
        function updateAudioDecodeMethodOptions() {
            const method = document.getElementById('audio-decode-method').value;

            // Hide all audio decode options
            document.getElementById('audio-decode-lsb-options').classList.add('hidden');
            document.getElementById('audio-decode-fft-options').classList.add('hidden');
            document.getElementById('audio-decode-echo-options').classList.add('hidden');

            // Show selected method options
            const hints = {
                'AUDIO_AUTO': 'Attempts LSB, FFT, and Echo methods automatically',
                'AUDIO_LSB': 'Extract from least significant bits of samples',
                'AUDIO_FFT': 'Extract from frequency domain modifications',
                'AUDIO_ECHO': 'Extract from echo timing patterns'
            };

            document.getElementById('audio-decode-method-hint').textContent = hints[method] || '';

            if (method === 'AUDIO_LSB') {
                document.getElementById('audio-decode-lsb-options').classList.remove('hidden');
            } else if (method === 'AUDIO_FFT') {
                document.getElementById('audio-decode-fft-options').classList.remove('hidden');
            } else if (method === 'AUDIO_ECHO') {
                document.getElementById('audio-decode-echo-options').classList.remove('hidden');
            }
        }

        // Draw waveform on a specific canvas
        function drawWaveformOn(audioBuffer, canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth * 2 || 600;
            canvas.height = canvas.offsetHeight * 2 || 200;

            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const samples = audioBuffer.getChannelData(0);
            const step = Math.ceil(samples.length / width);

            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 1;
            ctx.beginPath();

            const mid = height / 2;

            for (let i = 0; i < width; i++) {
                let min = 1.0, max = -1.0;
                for (let j = 0; j < step; j++) {
                    const idx = i * step + j;
                    if (idx < samples.length) {
                        if (samples[idx] < min) min = samples[idx];
                        if (samples[idx] > max) max = samples[idx];
                    }
                }
                ctx.moveTo(i, (1 + min) * mid);
                ctx.lineTo(i, (1 + max) * mid);
            }

            ctx.stroke();
        }

        // Draw spectrogram on a specific canvas
        function drawSpectrogramOn(audioBuffer, canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            canvas.width = 600;
            canvas.height = 200;

            const width = canvas.width;
            const height = canvas.height;

            const samples = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const fftSize = 512;
            const hopSize = fftSize / 4;
            const numFrames = Math.floor((samples.length - fftSize) / hopSize);

            const imageData = ctx.createImageData(width, height);

            const window = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
            }

            for (let frame = 0; frame < Math.min(numFrames, width); frame++) {
                const frameStart = frame * hopSize;
                const x = Math.floor(frame * width / numFrames);

                const frameData = new Float32Array(fftSize);
                for (let i = 0; i < fftSize; i++) {
                    frameData[i] = (samples[frameStart + i] || 0) * window[i];
                }

                for (let k = 0; k < Math.min(height, fftSize / 2); k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < fftSize; n++) {
                        const angle = -2 * Math.PI * k * n / fftSize;
                        real += frameData[n] * Math.cos(angle);
                        imag += frameData[n] * Math.sin(angle);
                    }
                    const magnitude = Math.sqrt(real * real + imag * imag);
                    const db = 20 * Math.log10(magnitude + 1e-10);
                    const normalized = Math.max(0, Math.min(1, (db + 60) / 60));

                    const y = height - 1 - k;
                    const idx = (y * width + x) * 4;
                    imageData.data[idx] = Math.floor(normalized * 100);
                    imageData.data[idx + 1] = Math.floor(normalized * 200 + 55);
                    imageData.data[idx + 2] = Math.floor(normalized * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Update audio method options UI
        function updateAudioMethodOptions() {
            const method = document.getElementById('audio-encode-method').value;

            // Hide all audio options
            document.getElementById('audio-lsb-options').classList.add('hidden');
            document.getElementById('audio-fft-options').classList.add('hidden');
            document.getElementById('audio-echo-options').classList.add('hidden');
            document.getElementById('audio-specart-options').classList.add('hidden');

            // Show selected method options
            const hints = {
                'AUDIO_LSB': 'Modify least significant bits of audio samples. High capacity.',
                'AUDIO_FFT': 'Hide data in frequency domain. Survives some compression.',
                'AUDIO_ECHO': 'Encode bits as subtle echoes. Robust but low capacity.',
                'AUDIO_SPECART': 'Hide an IMAGE in the audio spectrum! Aphex Twin style.'
            };

            document.getElementById('audio-method-hint').textContent = hints[method] || '';

            if (method === 'AUDIO_LSB') {
                document.getElementById('audio-lsb-options').classList.remove('hidden');
            } else if (method === 'AUDIO_FFT') {
                document.getElementById('audio-fft-options').classList.remove('hidden');
            } else if (method === 'AUDIO_ECHO') {
                document.getElementById('audio-echo-options').classList.remove('hidden');
            } else if (method === 'AUDIO_SPECART') {
                document.getElementById('audio-specart-options').classList.remove('hidden');
            }

            updateAudioCapacity();
        }

        // Toggle audio playback in encode panel
        function toggleEncodeAudioPlayback() {
            if (!state.audioBuffer) return;

            const audioCtx = getAudioContext();

            if (state.audioIsPlaying) {
                if (state.audioSource) {
                    state.audioSource.stop();
                    state.audioSource = null;
                }
                state.audioIsPlaying = false;
                document.getElementById('encode-audio-play-btn').textContent = '‚ñ∂';
            } else {
                state.audioSource = audioCtx.createBufferSource();
                state.audioSource.buffer = state.audioBuffer;
                state.audioSource.connect(audioCtx.destination);
                state.audioSource.start();
                state.audioIsPlaying = true;
                document.getElementById('encode-audio-play-btn').textContent = '‚è∏';

                state.audioSource.onended = () => {
                    state.audioIsPlaying = false;
                    document.getElementById('encode-audio-play-btn').textContent = '‚ñ∂';
                };
            }
        }

        // Initialize Audio Context
        function getAudioContext() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return state.audioContext;
        }

        // Format time as mm:ss
        function formatAudioTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Load audio file (legacy wrapper - calls loadAudioCarrier)
        async function loadAudioFile(file) {
            return loadAudioCarrier(file);
        }

        // Draw waveform visualization
        function drawWaveform(audioBuffer) {
            const canvas = document.getElementById('audio-waveform');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;

            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Get samples (use first channel)
            const samples = audioBuffer.getChannelData(0);
            const step = Math.ceil(samples.length / width);

            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 1;
            ctx.beginPath();

            const mid = height / 2;

            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const idx = i * step + j;
                    if (idx < samples.length) {
                        const sample = samples[idx];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                }

                const y1 = (1 + min) * mid;
                const y2 = (1 + max) * mid;

                ctx.moveTo(i, y1);
                ctx.lineTo(i, y2);
            }

            ctx.stroke();
        }

        // Draw spectrogram
        function drawSpectrogram(audioBuffer) {
            const canvas = document.getElementById('audio-spectrogram');
            const ctx = canvas.getContext('2d');

            canvas.width = 800;
            canvas.height = 256;

            const width = canvas.width;
            const height = canvas.height;

            const samples = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;

            const fftSize = 1024;
            const hopSize = fftSize / 4;
            const numFrames = Math.floor((samples.length - fftSize) / hopSize);

            // Create image data
            const imageData = ctx.createImageData(width, height);

            // Hann window
            const window = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
            }

            // Simple FFT magnitude calculation for visualization
            for (let frame = 0; frame < Math.min(numFrames, width); frame++) {
                const frameStart = frame * hopSize;
                const x = Math.floor(frame * width / numFrames);

                // Extract and window frame
                const frameData = new Float32Array(fftSize);
                for (let i = 0; i < fftSize; i++) {
                    frameData[i] = (samples[frameStart + i] || 0) * window[i];
                }

                // Simple DFT for first half of bins (for visualization)
                for (let k = 0; k < height; k++) {
                    const freq = k * sampleRate / fftSize;
                    let real = 0, imag = 0;

                    for (let n = 0; n < fftSize; n++) {
                        const angle = -2 * Math.PI * k * n / fftSize;
                        real += frameData[n] * Math.cos(angle);
                        imag += frameData[n] * Math.sin(angle);
                    }

                    const magnitude = Math.sqrt(real * real + imag * imag);
                    const db = 20 * Math.log10(magnitude + 1e-10);
                    const normalized = Math.max(0, Math.min(1, (db + 60) / 60));

                    // Map to color (cyan-blue gradient)
                    const y = height - 1 - k;
                    const idx = (y * width + x) * 4;

                    imageData.data[idx] = Math.floor(normalized * 100);
                    imageData.data[idx + 1] = Math.floor(normalized * 200 + 55);
                    imageData.data[idx + 2] = Math.floor(normalized * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Audio playback controls
        function toggleAudioPlayback() {
            if (!state.audioBuffer) return;

            const audioCtx = getAudioContext();

            if (state.audioIsPlaying) {
                // Stop
                if (state.audioSource) {
                    state.audioSource.stop();
                    state.audioSource = null;
                }
                state.audioIsPlaying = false;
                document.getElementById('audio-play-btn').textContent = '‚ñ∂';
            } else {
                // Play
                state.audioSource = audioCtx.createBufferSource();
                state.audioSource.buffer = state.audioBuffer;
                state.audioSource.connect(audioCtx.destination);
                state.audioSource.start();
                state.audioIsPlaying = true;
                document.getElementById('audio-play-btn').textContent = '‚è∏';

                state.audioSource.onended = () => {
                    state.audioIsPlaying = false;
                    document.getElementById('audio-play-btn').textContent = '‚ñ∂';
                };
            }
        }

        function seekAudio(value) {
            // Seeking requires restarting - simplified for now
            const percent = value / 100;
            if (state.audioBuffer) {
                document.getElementById('audio-current-time').textContent =
                    formatAudioTime(state.audioBuffer.duration * percent);
            }
        }

        // Set audio encoding method
        function setAudioMethod(method) {
            state.audioMethod = method;

            // Update buttons
            document.querySelectorAll('.audio-method-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('audio-method-' + method).classList.add('active');

            // Show/hide options
            document.getElementById('audio-lsb-options').classList.toggle('hidden', method !== 'lsb');
            document.getElementById('audio-fft-options').classList.toggle('hidden', method !== 'fft');
            document.getElementById('audio-echo-options').classList.toggle('hidden', method !== 'echo');
            document.getElementById('audio-specart-options').classList.toggle('hidden', method !== 'specart');

            // Update hint
            const hints = {
                'lsb': 'LSB: Modify least significant bits of audio samples. High capacity, fragile.',
                'fft': 'FFT: Hide data in frequency domain. Survives some compression.',
                'echo': 'Echo: Encode bits as subtle echoes. Robust but low capacity.',
                'specart': 'Spectrogram Art: Hide an IMAGE in the audio spectrum! Aphex Twin style.'
            };
            document.getElementById('audio-method-hint').textContent = hints[method];

            updateAudioCapacity();
        }

        // Set audio payload mode
        function setAudioPayloadMode(mode) {
            state.audioPayloadMode = mode;
            document.getElementById('audio-payload-text-mode').classList.toggle('hidden', mode !== 'text');
            document.getElementById('audio-payload-file-mode').classList.toggle('hidden', mode !== 'file');
            document.getElementById('audio-payload-text-btn').classList.toggle('btn-secondary', mode !== 'text');
            document.getElementById('audio-payload-file-btn').classList.toggle('btn-secondary', mode !== 'file');
        }

        // Update audio capacity display
        function updateAudioCapacity() {
            const capacityEl = document.getElementById('encode-capacity');
            if (!capacityEl) return;

            if (!state.audioBuffer) {
                capacityEl.textContent = 'Capacity: Load an audio file';
                return;
            }

            const method = document.getElementById('audio-encode-method')?.value || 'AUDIO_LSB';
            const samples = state.audioBuffer.length;
            const channels = state.audioBuffer.numberOfChannels;
            const bitsPerSample = parseInt(document.getElementById('audio-lsb-bits')?.value || '2');
            let capacity;

            if (method === 'AUDIO_LSB') {
                capacity = Math.floor((samples * channels * bitsPerSample) / 8) - 8; // minus header
            } else if (method === 'AUDIO_FFT') {
                capacity = Math.floor(samples / 2048) * 64; // ~64 bytes per frame
            } else if (method === 'AUDIO_ECHO') {
                capacity = Math.floor(state.audioBuffer.duration * 100); // ~100 bits per second
            } else {
                capacity = 0; // specart doesn't hide data, it hides images
            }

            capacityEl.innerHTML = method === 'AUDIO_SPECART'
                ? '<span style="color: #00d4ff;">üé® Mode: Embed image into spectrogram</span>'
                : `<span style="color: #00d4ff;">üéµ Audio Capacity: ${formatSize(Math.max(0, capacity))}</span>`;
        }

        // WAV encoding
        function encodeWAV(samples, sampleRate, numChannels) {
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = samples.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, 16, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write samples (use 32768 scaling for Web Audio compatibility)
            let offset = 44;
            for (let i = 0; i < samples.length; i++) {
                const s = Math.max(-1, Math.min(1, samples[i]));
                // Scale by 32768 and clamp to valid 16-bit range
                const intSample = Math.round(s * 32768);
                view.setInt16(offset, Math.max(-32768, Math.min(32767, intSample)), true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
        }

        // Audio LSB Encode
        function audioLSBEncode(samples, data, bitsPerSample) {
            const output = new Float32Array(samples);

            // Create header: ALSB + length
            const header = new Uint8Array(8);
            header[0] = 0x41; header[1] = 0x4C; header[2] = 0x53; header[3] = 0x42; // "ALSB"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(8 + data.length);
            fullData.set(header);
            fullData.set(data, 8);

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let b = 7; b >= 0; b--) {
                    bits.push((fullData[i] >> b) & 1);
                }
            }

            // Embed bits into samples
            // Use 32768 for consistency with Web Audio API normalization
            const mask = (1 << bitsPerSample) - 1;
            let bitIdx = 0;

            for (let i = 0; i < output.length && bitIdx < bits.length; i++) {
                // Convert float sample to 16-bit integer (use 32768 for Web Audio compatibility)
                let sample = Math.round(output[i] * 32768);
                // Clamp to valid 16-bit signed range
                sample = Math.max(-32768, Math.min(32767, sample));

                // Clear LSBs and embed data
                let dataBits = 0;
                for (let b = 0; b < bitsPerSample && bitIdx < bits.length; b++) {
                    dataBits |= bits[bitIdx++] << b;
                }

                sample = (sample & ~mask) | dataBits;

                // Convert back to float
                output[i] = sample / 32768;
            }

            return output;
        }

        // Audio LSB Decode
        function audioLSBDecode(samples, bitsPerSample) {
            const bits = [];

            // Extract LSBs (use 32768 for Web Audio compatibility)
            const mask = (1 << bitsPerSample) - 1;

            for (let i = 0; i < samples.length; i++) {
                // Use 32768 to match Web Audio API normalization
                let sample = Math.round(samples[i] * 32768);
                sample = Math.max(-32768, Math.min(32767, sample));
                for (let b = 0; b < bitsPerSample; b++) {
                    bits.push((sample >> b) & 1);
                }
            }

            // Convert bits to bytes
            const bytes = [];
            for (let i = 0; i + 7 < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }

            // Debug: log first 8 bytes
            console.log('Audio decode - first 8 bytes:', bytes.slice(0, 8).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
            console.log('Expected header: 0x41 0x4c 0x53 0x42 (ALSB)');

            // Check header
            if (bytes[0] !== 0x41 || bytes[1] !== 0x4C || bytes[2] !== 0x53 || bytes[3] !== 0x42) {
                throw new Error('No ALSB audio steg header found');
            }

            const length = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

            if (length < 0 || length > bytes.length - 8) {
                throw new Error('Invalid data length');
            }

            return new Uint8Array(bytes.slice(8, 8 + length));
        }

        // Direct WAV file decoder (bypasses Web Audio API resampling)
        function decodeWAVFile(arrayBuffer) {
            const view = new DataView(arrayBuffer);

            // Check RIFF header
            const riff = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
            if (riff !== 'RIFF') throw new Error('Not a valid WAV file');

            const wave = String.fromCharCode(view.getUint8(8), view.getUint8(9), view.getUint8(10), view.getUint8(11));
            if (wave !== 'WAVE') throw new Error('Not a valid WAV file');

            // Find fmt chunk
            let offset = 12;
            let sampleRate, numChannels, bitsPerSample;

            while (offset < arrayBuffer.byteLength) {
                const chunkId = String.fromCharCode(view.getUint8(offset), view.getUint8(offset+1), view.getUint8(offset+2), view.getUint8(offset+3));
                const chunkSize = view.getUint32(offset + 4, true);

                if (chunkId === 'fmt ') {
                    numChannels = view.getUint16(offset + 10, true);
                    sampleRate = view.getUint32(offset + 12, true);
                    bitsPerSample = view.getUint16(offset + 22, true);
                } else if (chunkId === 'data') {
                    // Read samples directly as 16-bit integers
                    const dataOffset = offset + 8;
                    const numSamples = chunkSize / 2; // 16-bit = 2 bytes per sample
                    const samples = new Int16Array(numSamples);

                    for (let i = 0; i < numSamples; i++) {
                        samples[i] = view.getInt16(dataOffset + i * 2, true);
                    }

                    return { samples, sampleRate, numChannels, bitsPerSample };
                }

                offset += 8 + chunkSize;
                if (chunkSize % 2 === 1) offset++; // Pad byte
            }

            throw new Error('No data chunk found in WAV file');
        }

        // Audio LSB Decode from raw 16-bit samples (no precision loss)
        function audioLSBDecodeRaw(samples, bitsPerSample) {
            const bits = [];
            const mask = (1 << bitsPerSample) - 1;

            for (let i = 0; i < samples.length; i++) {
                const sample = samples[i]; // Already 16-bit integer
                for (let b = 0; b < bitsPerSample; b++) {
                    bits.push((sample >> b) & 1);
                }
            }

            // Convert bits to bytes
            const bytes = [];
            for (let i = 0; i + 7 < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }

            // Debug: log first 8 bytes
            console.log('Raw audio decode - first 8 bytes:', bytes.slice(0, 8).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));

            // Check header
            if (bytes[0] !== 0x41 || bytes[1] !== 0x4C || bytes[2] !== 0x53 || bytes[3] !== 0x42) {
                throw new Error('No ALSB audio steg header found');
            }

            const length = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];

            if (length < 0 || length > bytes.length - 8) {
                throw new Error('Invalid data length');
            }

            return new Uint8Array(bytes.slice(8, 8 + length));
        }

        // Main encode function
        async function doAudioEncode() {
            if (!state.audioBuffer) {
                notify('Load an audio file first!', 'error');
                return;
            }

            try {
                const method = document.getElementById('audio-encode-method').value;
                let data;

                if (method === 'AUDIO_SPECART') {
                    if (!state.audioSpecartImage) {
                        notify('Load an image for spectrogram art!', 'error');
                        return;
                    }
                    // Spectrogram art mode - embed image
                    notify('üéµ Embedding image into spectrogram...', 'info');
                    const result = await embedSpectrogramImage();
                    state.audioEncodedSamples = result;
                } else {
                    // Get payload data from standard encode panel
                    if (state.payloadMode === 'text') {
                        const text = document.getElementById('encode-text').value;
                        if (!text) {
                            notify('Enter a message to hide!', 'error');
                            return;
                        }
                        data = new TextEncoder().encode(text);
                    } else {
                        if (!state.payloadFile) {
                            notify('Select a file to hide!', 'error');
                            return;
                        }
                        const fnameBytes = new TextEncoder().encode(state.payloadFileName);
                        data = new Uint8Array(1 + fnameBytes.length + state.payloadFile.length);
                        data[0] = fnameBytes.length;
                        data.set(fnameBytes, 1);
                        data.set(state.payloadFile, 1 + fnameBytes.length);
                    }

                    // Get samples
                    const samples = state.audioBuffer.getChannelData(0);
                    const bitsPerSample = parseInt(document.getElementById('audio-lsb-bits')?.value || '2');

                    notify('üéµ Encoding audio...', 'info');

                    if (method === 'AUDIO_LSB') {
                        state.audioEncodedSamples = audioLSBEncode(samples, data, bitsPerSample);
                        state.audioEncodeBits = bitsPerSample; // Store for verification

                        // Verify encoding worked by trying to decode immediately
                        try {
                            const verifyData = audioLSBDecode(state.audioEncodedSamples, bitsPerSample);
                            console.log('Audio encode verification: SUCCESS, decoded', verifyData.length, 'bytes');
                        } catch (verifyErr) {
                            console.error('Audio encode verification FAILED:', verifyErr);
                            throw new Error('Encoding verification failed: ' + verifyErr.message);
                        }
                    } else if (method === 'AUDIO_FFT') {
                        state.audioEncodedSamples = audioFFTEncode(samples, data, state.audioBuffer.sampleRate);
                    } else if (method === 'AUDIO_ECHO') {
                        state.audioEncodedSamples = audioEchoEncode(samples, data, state.audioBuffer.sampleRate);
                    }
                }

                // Show result in standard encode result panel
                const resultDiv = document.getElementById('encode-result');
                resultDiv.classList.remove('hidden');

                // Hide image preview, show audio result info
                const previewImg = document.getElementById('encode-result-preview');
                const resultInfo = document.getElementById('encode-result-info');
                if (previewImg) previewImg.classList.add('hidden');

                // Create audio result display
                resultInfo.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="color: #00d4ff; font-size: 48px; margin-bottom: 10px;">üéµ</div>
                        <h3 style="color: #00d4ff; margin-bottom: 10px;">Audio Encoded Successfully!</h3>
                        <p class="text-muted">Method: ${method.replace('AUDIO_', '')}</p>
                        <p class="text-muted">Duration: ${formatAudioTime(state.audioBuffer.duration)}</p>
                        <p class="text-muted">Sample Rate: ${state.audioBuffer.sampleRate}Hz</p>
                        <button class="btn btn-primary mt-3" onclick="downloadAudioResult()">Download WAV</button>
                    </div>
                `;

                notify('üéµ Audio encoded! Click Download WAV to save.', 'success');

            } catch (e) {
                notify('Encode error: ' + e.message, 'error');
            }
        }

        // FFT-based encoding (simplified)
        function audioFFTEncode(samples, data, sampleRate) {
            const output = new Float32Array(samples);
            const fftSize = 2048;
            const hopSize = fftSize / 2;

            // Create header
            const header = new Uint8Array(8);
            header[0] = 0x41; header[1] = 0x46; header[2] = 0x46; header[3] = 0x54; // "AFFT"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(8 + data.length);
            fullData.set(header);
            fullData.set(data, 8);

            // Get target frequency range
            const freqRange = document.getElementById('audio-fft-range')?.value || 'high';
            let minFreq, maxFreq;
            if (freqRange === 'high') { minFreq = 14000; maxFreq = 20000; }
            else if (freqRange === 'mid') { minFreq = 8000; maxFreq = 14000; }
            else { minFreq = 4000; maxFreq = 8000; }

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let b = 7; b >= 0; b--) {
                    bits.push((fullData[i] >> b) & 1);
                }
            }

            // Embed bits by modifying high-frequency components
            let bitIdx = 0;
            const strengthVal = document.getElementById('audio-fft-strength')?.value || 'medium';
            const strength = strengthVal === 'high' ? 0.1 : strengthVal === 'medium' ? 0.05 : 0.02;

            for (let frame = 0; frame < (samples.length - fftSize) / hopSize && bitIdx < bits.length; frame++) {
                const start = frame * hopSize;
                const binMin = Math.floor(minFreq * fftSize / sampleRate);
                const binMax = Math.floor(maxFreq * fftSize / sampleRate);

                // Simple: just add/subtract to specific sample based on bit
                for (let bin = binMin; bin < binMax && bitIdx < bits.length; bin++) {
                    const idx = start + bin;
                    if (idx < output.length) {
                        output[idx] += (bits[bitIdx++] ? strength : -strength);
                    }
                }
            }

            return output;
        }

        // Echo-based encoding
        function audioEchoEncode(samples, data, sampleRate) {
            const output = new Float32Array(samples);

            // Create header
            const header = new Uint8Array(8);
            header[0] = 0x41; header[1] = 0x45; header[2] = 0x43; header[3] = 0x48; // "AECH"
            header[4] = (data.length >> 24) & 0xFF;
            header[5] = (data.length >> 16) & 0xFF;
            header[6] = (data.length >> 8) & 0xFF;
            header[7] = data.length & 0xFF;

            const fullData = new Uint8Array(8 + data.length);
            fullData.set(header);
            fullData.set(data, 8);

            const delay0 = Math.floor(parseFloat(document.getElementById('audio-echo-delay')?.value || '0.5') * sampleRate / 1000);
            const delay1 = delay0 * 2;
            const amplitude = parseFloat(document.getElementById('audio-echo-amp')?.value || '0.3');

            // Segment size for each bit
            const segmentSize = Math.floor(sampleRate / 50); // 50 bits per second

            // Convert to bits
            const bits = [];
            for (let i = 0; i < fullData.length; i++) {
                for (let b = 7; b >= 0; b--) {
                    bits.push((fullData[i] >> b) & 1);
                }
            }

            // Embed bits as echoes
            for (let i = 0; i < bits.length; i++) {
                const start = i * segmentSize;
                const delay = bits[i] ? delay1 : delay0;

                for (let j = 0; j < segmentSize && start + j + delay < output.length; j++) {
                    output[start + j + delay] += samples[start + j] * amplitude;
                }
            }

            return output;
        }

        // Spectrogram image embedding
        async function embedSpectrogramImage() {
            const audioBuffer = state.audioBuffer;
            const samples = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const output = new Float32Array(samples);

            const img = state.audioSpecartImage;
            const freqStr = document.getElementById('audio-specart-freq')?.value || '8000-16000';
            const [minFreqStr, maxFreqStr] = freqStr.split('-');
            const minFreq = parseInt(minFreqStr);
            const maxFreq = parseInt(maxFreqStr);
            const intensity = parseInt(document.getElementById('audio-specart-intensity')?.value || '50') / 100;

            const fftSize = 2048;
            const hopSize = fftSize / 4;
            const numFrames = Math.floor((samples.length - fftSize) / hopSize);

            // Get image data
            const imgCanvas = document.createElement('canvas');
            imgCanvas.width = numFrames;
            imgCanvas.height = 256;
            const imgCtx = imgCanvas.getContext('2d');
            imgCtx.drawImage(img, 0, 0, numFrames, 256);
            const imgData = imgCtx.getImageData(0, 0, numFrames, 256);

            // Hann window
            const window = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
            }

            // Generate frequencies for each frame based on image
            for (let frame = 0; frame < numFrames; frame++) {
                const start = frame * hopSize;

                // Get image column
                for (let y = 0; y < 256; y++) {
                    const imgIdx = (y * numFrames + frame) * 4;
                    const brightness = (imgData.data[imgIdx] + imgData.data[imgIdx + 1] + imgData.data[imgIdx + 2]) / (3 * 255);

                    if (brightness > 0.1) {
                        // Map y to frequency
                        const freq = minFreq + (1 - y / 256) * (maxFreq - minFreq);
                        const period = sampleRate / freq;

                        // Add sinusoid at this frequency
                        for (let i = 0; i < hopSize; i++) {
                            const idx = start + i;
                            if (idx < output.length) {
                                output[idx] += Math.sin(2 * Math.PI * (idx / period)) * brightness * intensity * 0.1;
                            }
                        }
                    }
                }
            }

            // Normalize to prevent clipping
            let maxVal = 0;
            for (let i = 0; i < output.length; i++) {
                maxVal = Math.max(maxVal, Math.abs(output[i]));
            }
            if (maxVal > 1) {
                for (let i = 0; i < output.length; i++) {
                    output[i] /= maxVal;
                }
            }

            return output;
        }

        // Decode audio - works with integrated decode panel
        async function doAudioDecode() {
            if (!state.decodeAudioBuffer && !state.decodeRawSamples) {
                notify('Load an audio file to decode!', 'error');
                return;
            }

            try {
                const method = document.getElementById('audio-decode-method').value;
                const hasRawSamples = state.decodeRawSamples && state.decodeRawSamples.length > 0;
                const floatSamples = state.decodeAudioBuffer ? state.decodeAudioBuffer.getChannelData(0) : null;
                let data;

                console.log('Audio decode: hasRawSamples =', hasRawSamples, ', method =', method);

                if (method === 'AUDIO_AUTO') {
                    notify('üéµ Scanning for hidden data...', 'info');

                    // Try LSB with different bit depths (2, 1, 4)
                    const bitDepths = [2, 1, 4];
                    let found = false;

                    for (const bits of bitDepths) {
                        try {
                            // Prefer raw samples for accurate decoding
                            if (hasRawSamples) {
                                data = audioLSBDecodeRaw(state.decodeRawSamples, bits);
                                console.log('Raw decode succeeded with', bits, 'bits');
                            } else {
                                data = audioLSBDecode(floatSamples, bits);
                            }
                            notify(`Decoded using LSB method (${bits} bits)!`, 'success');
                            found = true;
                            break;
                        } catch (e) {
                            console.log('LSB decode failed with', bits, 'bits:', e.message);
                            // Try next bit depth
                        }
                    }

                    if (!found) {
                        // Try FFT
                        try {
                            data = audioFFTDecode(floatSamples, state.decodeAudioBuffer.sampleRate);
                            notify('Decoded using FFT method!', 'success');
                            found = true;
                        } catch (e2) {
                            // Try Echo
                            try {
                                data = audioEchoDecode(floatSamples, state.decodeAudioBuffer.sampleRate);
                                notify('Decoded using Echo method!', 'success');
                                found = true;
                            } catch (e3) {
                                throw new Error('No hidden data found (tried LSB, FFT, Echo)');
                            }
                        }
                    }
                } else if (method === 'AUDIO_LSB') {
                    const bitsPerSample = parseInt(document.getElementById('audio-decode-bits').value);
                    if (hasRawSamples) {
                        data = audioLSBDecodeRaw(state.decodeRawSamples, bitsPerSample);
                    } else {
                        data = audioLSBDecode(floatSamples, bitsPerSample);
                    }
                    notify('Decoded using LSB method!', 'success');
                } else if (method === 'AUDIO_FFT') {
                    data = audioFFTDecode(floatSamples, state.decodeAudioBuffer.sampleRate);
                    notify('Decoded using FFT method!', 'success');
                } else if (method === 'AUDIO_ECHO') {
                    data = audioEchoDecode(floatSamples, state.decodeAudioBuffer.sampleRate);
                    notify('Decoded using Echo method!', 'success');
                }

                state.decodedData = data;

                // Display in standard decode result area
                const { filename, fileData } = extractFileFromData(data);

                const resultDiv = document.getElementById('decode-result');
                const resultContent = document.getElementById('decode-result-content');
                resultDiv.classList.remove('hidden');

                if (filename) {
                    resultContent.innerHTML = `<pre style="color: #00d4ff;">üéµ AUDIO DECODE RESULT

File: ${filename}
Size: ${formatSize(fileData.length)}

(Click Download to save)</pre>`;
                    state.decodedData = fileData;
                    state.decodedFilename = filename;
                } else {
                    try {
                        const text = new TextDecoder().decode(data);
                        resultContent.innerHTML = `<pre style="color: #00d4ff;">üéµ AUDIO DECODE RESULT

${text}</pre>`;
                        state.decodedFilename = 'decoded.txt';
                    } catch (e) {
                        resultContent.innerHTML = `<pre style="color: #00d4ff;">üéµ AUDIO DECODE RESULT

Binary data (${formatSize(data.length)})

(Click Download to save)</pre>`;
                        state.decodedFilename = 'decoded.bin';
                    }
                }

                // Also show in quick result
                const quickResult = document.getElementById('quick-decode-result');
                const quickContent = document.getElementById('quick-decode-content');
                quickResult.classList.remove('hidden');
                quickContent.style.color = '#00d4ff';
                if (filename) {
                    quickContent.textContent = `File: ${filename} (${formatSize(fileData.length)})`;
                } else {
                    quickContent.textContent = new TextDecoder('utf-8', { fatal: false }).decode(data).slice(0, 500);
                }

            } catch (e) {
                notify('Decode error: ' + e.message, 'error');
            }
        }

        // FFT decode (simplified)
        function audioFFTDecode(samples, sampleRate) {
            // Look for AFFT header in high frequencies
            // Simplified: check if header present
            throw new Error('AFFT header not found');
        }

        // Echo decode (simplified)
        function audioEchoDecode(samples, sampleRate) {
            // Look for AECH header in echo patterns
            throw new Error('AECH header not found');
        }

        // Audio analysis - works with integrated analyze panel
        function doAudioAnalyze() {
            if (!state.analyzeAudioBuffer) {
                notify('Load an audio file to analyze!', 'error');
                return;
            }

            const audioBuffer = state.analyzeAudioBuffer;
            const samples = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;

            let output = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       üéµ AUDIO STEGANALYSIS REPORT    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Sample Rate: ${sampleRate}Hz
‚ïë Duration: ${formatAudioTime(audioBuffer.duration)}
‚ïë Channels: ${audioBuffer.numberOfChannels}
‚ïë Total Samples: ${samples.length.toLocaleString()}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;

            // Check for LSB patterns
            let lsbZeros = 0, lsbOnes = 0;
            for (let i = 0; i < Math.min(samples.length, 100000); i++) {
                const sample = Math.round(samples[i] * 32767);
                if (sample & 1) lsbOnes++;
                else lsbZeros++;
            }

            const lsbRatio = lsbOnes / (lsbZeros + lsbOnes);
            const lsbAnomaly = Math.abs(lsbRatio - 0.5) > 0.05;

            output += `‚ïë LSB DISTRIBUTION:
‚ïë   0s: ${lsbZeros.toLocaleString()} (${(100 - lsbRatio * 100).toFixed(1)}%)
‚ïë   1s: ${lsbOnes.toLocaleString()} (${(lsbRatio * 100).toFixed(1)}%)
‚ïë   Status: ${lsbAnomaly ? '‚ö†Ô∏è ANOMALY DETECTED' : '‚úì Normal'}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
`;

            // Check for headers
            output += `‚ïë HEADER SCAN:\n`;
            const headerCheck = checkAudioStegHeader(samples);
            if (headerCheck.found) {
                output += `‚ïë   ‚úì ${headerCheck.method} header found!
‚ïë   Payload: ${formatSize(headerCheck.length)}
`;
            } else {
                output += `‚ïë   No known audio steg headers found
`;
            }

            // Frequency analysis
            output += `‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë HIGH FREQUENCY ANALYSIS:
`;
            // Check for unusual high-frequency energy
            let highFreqEnergy = 0;
            let totalEnergy = 0;
            // Simplified: just check sample variance
            for (let i = 1; i < Math.min(samples.length, 50000); i++) {
                const diff = Math.abs(samples[i] - samples[i-1]);
                if (diff > 0.1) highFreqEnergy++;
                totalEnergy++;
            }
            const highFreqRatio = highFreqEnergy / totalEnergy;
            output += `‚ïë   High-freq activity: ${(highFreqRatio * 100).toFixed(1)}%
‚ïë   Status: ${highFreqRatio > 0.3 ? '‚ö†Ô∏è Unusual HF energy' : '‚úì Normal'}
`;

            output += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`;

            // Display in analyze results
            document.getElementById('analyze-result').innerHTML = `<pre style="color: #00d4ff;">${output}</pre>`;

            // Draw analysis visualizations
            drawWaveformOn(audioBuffer, 'analyze-waveform-large');
            drawSpectrogramOn(audioBuffer, 'analyze-spectrogram-large');
            drawAudioLSBHistogram(samples);
            drawAudioFrequencySpectrum(samples, sampleRate);

            notify('üéµ Audio analysis complete!', 'success');
        }

        // Draw audio LSB histogram
        function drawAudioLSBHistogram(samples) {
            const canvas = document.getElementById('analyze-audio-lsb-hist');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth * 2 || 300;
            canvas.height = canvas.offsetHeight * 2 || 200;

            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Count LSB values
            const lsbCounts = [0, 0];
            const numSamples = Math.min(samples.length, 100000);
            for (let i = 0; i < numSamples; i++) {
                const sample = Math.round(samples[i] * 32767);
                lsbCounts[sample & 1]++;
            }

            const maxCount = Math.max(lsbCounts[0], lsbCounts[1]);

            // Draw bars
            const barWidth = width / 4;
            for (let i = 0; i < 2; i++) {
                const barHeight = (lsbCounts[i] / maxCount) * (height - 40);
                const x = width / 4 + i * barWidth;
                const y = height - 20 - barHeight;

                ctx.fillStyle = i === 0 ? '#00d4ff' : '#00ff41';
                ctx.fillRect(x, y, barWidth - 10, barHeight);

                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + barWidth/2 - 5, height - 5);
                ctx.fillText(`${(lsbCounts[i]/numSamples*100).toFixed(1)}%`, x + barWidth/2 - 5, y - 5);
            }
        }

        // Draw frequency spectrum
        function drawAudioFrequencySpectrum(samples, sampleRate) {
            const canvas = document.getElementById('analyze-audio-freq');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth * 2 || 300;
            canvas.height = canvas.offsetHeight * 2 || 200;

            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Simple DFT for first 256 bins
            const fftSize = 512;
            const magnitudes = [];

            for (let k = 0; k < fftSize / 2; k++) {
                let real = 0, imag = 0;
                for (let n = 0; n < fftSize; n++) {
                    const angle = -2 * Math.PI * k * n / fftSize;
                    real += (samples[n] || 0) * Math.cos(angle);
                    imag += (samples[n] || 0) * Math.sin(angle);
                }
                magnitudes.push(Math.sqrt(real * real + imag * imag));
            }

            const maxMag = Math.max(...magnitudes);

            // Draw spectrum
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < magnitudes.length; i++) {
                const x = (i / magnitudes.length) * width;
                const y = height - (magnitudes[i] / maxMag) * (height - 20);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#555';
            ctx.font = '10px monospace';
            ctx.fillText('0Hz', 5, height - 5);
            ctx.fillText(`${Math.round(sampleRate/4)}Hz`, width/2, height - 5);
            ctx.fillText(`${Math.round(sampleRate/2)}Hz`, width - 40, height - 5);
        }

        // Download encoded audio
        function downloadAudioResult() {
            if (!state.audioEncodedSamples || !state.audioBuffer) {
                notify('No encoded audio to download!', 'error');
                return;
            }

            const blob = encodeWAV(state.audioEncodedSamples, state.audioBuffer.sampleRate, 1);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stego_audio_${state.audioMethod}.wav`;
            a.click();
            URL.revokeObjectURL(url);

            notify('WAV file downloaded!', 'success');
        }

        // Download decoded audio data
        function downloadAudioDecoded() {
            if (!state.audioDecodedData) {
                notify('No decoded data!', 'error');
                return;
            }

            const blob = new Blob([state.audioDecodedData]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'audio_decoded.bin';
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============== EVENT LISTENERS ==============
        document.addEventListener('DOMContentLoaded', () => {
            // Hatching stegosaurus animation
            const hatchFrames = [
                // Peaceful egg
                { art: `  ____
 /    \\
(      )
(      )
 \\____/`, delay: 1400 },
                // Wobble left
                { art: ` ____
/    \\
(     )
(     )
\\____/`, delay: 100, shake: true },
                // Wobble right
                { art: `   ____
  /    \\
 (      )
 (      )
  \\____/`, delay: 100, shake: true },
                // Back to center
                { art: `  ____
 /    \\
(      )
(      )
 \\____/`, delay: 100, shake: true },
                // Crack appears
                { art: `  ____
 / *  \\
(      )
(      )
 \\____/`, delay: 500 },
                // More cracks
                { art: `  _**_
 /* * \\
(  *   )
(      )
 \\____/`, delay: 300, shake: true },
                // Breaking open!
                { art: ` \\**/
 (o.o)
  )_(
  / \\`, delay: 250 },
                // Baby dino emerges
                { art: `  __
 (o.o)
/)__(\\
" "" "`, delay: 350 },
                // Happy dino!
                { art: `  ^^
 (^.^)
/)__(\\
" "" "`, delay: 2500 },
            ];

            const hatchEl = document.getElementById('hatch-animation');
            if (hatchEl) {
                let frameIndex = 0;

                function showFrame() {
                    const frame = hatchFrames[frameIndex];
                    hatchEl.textContent = frame.art;

                    // Add shake class for shake frames
                    if (frame.shake) {
                        hatchEl.classList.add('egg-shaking');
                    } else {
                        hatchEl.classList.remove('egg-shaking');
                    }

                    frameIndex++;
                    if (frameIndex >= hatchFrames.length) {
                        frameIndex = 0;
                    }

                    setTimeout(showFrame, frame.delay);
                }

                showFrame();
            }

            // Tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab + '-panel').classList.add('active');
                });
            });

            // Initialize Text Lab Easter Egg (triple-click on egg animation)
            initTextLabEasterEgg();

            // Global paste handler for images
            document.addEventListener('paste', e => {
                const items = e.clipboardData?.items;
                if (!items) return;

                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        e.preventDefault();
                        const file = item.getAsFile();
                        if (!file) return;

                        // Determine active panel and route accordingly
                        const activePanel = document.querySelector('.panel.active');
                        if (!activePanel) return;

                        const panelId = activePanel.id;
                        const img = new Image();
                        img.onload = () => {
                            const canvas = imageToCanvas(img);

                            if (panelId === 'encode-panel') {
                                state.carrierCanvas = canvas;
                                document.getElementById('encode-carrier-preview').src = img.src;
                                document.getElementById('encode-carrier-preview').classList.remove('hidden');
                                document.getElementById('encode-carrier-info').textContent = `Pasted | ${img.width}x${img.height}`;
                                updateCapacity();
                                notify('Image pasted as carrier', 'success');
                            } else if (panelId === 'decode-panel') {
                                state.decodeCanvas = canvas;
                                document.getElementById('decode-image-preview').src = img.src;
                                document.getElementById('decode-image-preview').classList.remove('hidden');
                                document.getElementById('decode-image-info').textContent = `Pasted | ${img.width}x${img.height}`;
                                // Check for header
                                const headerBytes = extractRawBits(canvas, [0, 1, 2], 1, HEADER_SIZE);
                                const header = parseHeader(headerBytes);
                                const detection = document.getElementById('decode-detection');
                                if (header) {
                                    detection.innerHTML = `<div style="color: var(--primary); background: rgba(0,255,65,0.1); padding: 8px; border: 1px solid var(--primary); border-radius: 4px;">
                                        ‚úì STEG v${header.version} detected<br>
                                        Channels: ${header.channels.map(c => ['R','G','B','A'][c]).join('')}<br>
                                        Payload: ${formatSize(header.originalLength)}
                                    </div>`;
                                } else {
                                    detection.innerHTML = `<div style="color: var(--warning); background: rgba(255,255,0,0.1); padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
                                        ‚ö† No STEG header - use Smart Scan
                                    </div>`;
                                }
                                notify('Image pasted for decoding', 'success');
                            } else if (panelId === 'analyze-panel') {
                                state.analyzeCanvas = canvas;
                                document.getElementById('analyze-image-preview').src = img.src;
                                document.getElementById('analyze-image-preview').classList.remove('hidden');
                                document.getElementById('analyze-image-info').textContent = `Pasted | ${img.width}x${img.height}`;
                                notify('Image pasted for analysis', 'success');
                            } else if (panelId === 'matryoshka-panel') {
                                // Use as outer carrier or decode input based on context
                                state.matryoshkaOuterCarrier = canvas;
                                document.getElementById('matryoshka-outer-preview').src = img.src;
                                document.getElementById('matryoshka-outer-preview').classList.remove('hidden');
                                document.getElementById('matryoshka-outer-info').textContent = `Pasted | ${img.width}x${img.height}`;
                                updateMatryoshkaSizeInfo();
                                notify('Image pasted as Nested Stegg carrier', 'success');
                            }
                        };
                        img.src = URL.createObjectURL(file);
                        break;
                    }
                }
            });

            // Drop zones
            function setupDropZone(dropId, inputId, callback) {
                const drop = document.getElementById(dropId);
                const input = document.getElementById(inputId);
                if (!drop || !input) return;

                drop.addEventListener('click', () => input.click());
                drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('dragover'); });
                drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));
                drop.addEventListener('drop', e => {
                    e.preventDefault();
                    drop.classList.remove('dragover');
                    if (e.dataTransfer.files.length > 0) callback(e.dataTransfer.files[0]);
                });
                input.addEventListener('change', e => {
                    if (e.target.files.length > 0) {
                        callback(e.target.files[0]);
                        // Reset input so the same file can be selected again
                        e.target.value = '';
                    }
                });
            }

            // Make preview images clickable to allow re-uploading
            document.querySelectorAll('.image-preview').forEach(preview => {
                preview.style.cursor = 'pointer';
                preview.title = 'Click to upload a new image';
            });

            // Click on encode preview to re-upload
            document.getElementById('encode-carrier-preview')?.addEventListener('click', () => {
                document.getElementById('encode-carrier-input')?.click();
            });

            // Click on decode preview to re-upload
            document.getElementById('decode-image-preview')?.addEventListener('click', () => {
                document.getElementById('decode-image-input')?.click();
            });

            // Click on analyze preview to re-upload
            document.getElementById('analyze-image-preview')?.addEventListener('click', () => {
                document.getElementById('analyze-image-input')?.click();
            });

            setupDropZone('encode-carrier-drop', 'encode-carrier-input', file => {
                // Check if it's an audio file
                const isAudio = file.type.startsWith('audio/') ||
                    /\.(wav|mp3|ogg|flac|m4a|aac)$/i.test(file.name);

                if (isAudio) {
                    // Handle audio file
                    switchToAudioMode('encode');
                    loadAudioCarrier(file);
                } else {
                    // Handle image file
                    switchToImageMode('encode');
                    const img = new Image();
                    const isGif = file.type === 'image/gif' || file.name.toLowerCase().endsWith('.gif');
                    img.onload = () => {
                        state.carrierCanvas = imageToCanvas(img);
                        state.carrierOriginalType = file.type;
                        document.getElementById('encode-carrier-preview').src = img.src;
                        document.getElementById('encode-carrier-preview').classList.remove('hidden');
                        document.getElementById('encode-carrier-info').textContent =
                            `${file.name} | ${img.width}x${img.height}`;
                        updateCapacity();

                        // Warn about GIF limitations
                        if (isGif) {
                            notify('GIF loaded: Animation will be lost. Output will be PNG.', 'warning');
                        }
                    };
                    img.src = URL.createObjectURL(file);
                }
            });

            setupDropZone('encode-file-drop', 'encode-file-input', file => {
                const reader = new FileReader();
                reader.onload = e => {
                    state.payloadFile = new Uint8Array(e.target.result);
                    state.payloadFileName = file.name;
                    document.getElementById('encode-file-info').textContent =
                        `${file.name} (${formatSize(file.size)})`;
                    updateCapacity();
                };
                reader.readAsArrayBuffer(file);
            });

            setupDropZone('decode-image-drop', 'decode-image-input', file => {
                // Detect if it's an audio file
                const isAudio = file.type.startsWith('audio/') ||
                    /\.(wav|mp3|ogg|flac|m4a|aac)$/i.test(file.name);

                if (isAudio) {
                    switchToAudioMode('decode');
                    loadAudioForDecode(file);
                } else {
                    switchToImageMode('decode');

                    // For F5: Store raw JPEG data if it's a JPEG file
                    const isJpeg = file.type === 'image/jpeg' ||
                        /\.(jpg|jpeg)$/i.test(file.name);
                    // For PNG Chunk: Store raw PNG data if it's a PNG file
                    const isPng = file.type === 'image/png' ||
                        /\.png$/i.test(file.name);

                    if (isJpeg) {
                        const reader = new FileReader();
                        reader.onload = () => {
                            state.decodeJpegData = new Uint8Array(reader.result);
                        };
                        reader.readAsArrayBuffer(file);
                        state.decodePngData = null;
                    } else if (isPng) {
                        const reader = new FileReader();
                        reader.onload = () => {
                            state.decodePngData = new Uint8Array(reader.result);
                        };
                        reader.readAsArrayBuffer(file);
                        state.decodeJpegData = null;
                    } else {
                        state.decodeJpegData = null;
                        state.decodePngData = null;
                    }

                    const img = new Image();
                    img.onload = () => {
                        state.decodeCanvas = imageToCanvas(img);
                        document.getElementById('decode-image-preview').src = img.src;
                        document.getElementById('decode-image-preview').classList.remove('hidden');
                        let formatInfo = '';
                        if (isJpeg) formatInfo = ' (JPEG - F5 ready)';
                        else if (isPng) formatInfo = ' (PNG - Chunk ready)';
                        document.getElementById('decode-image-info').textContent =
                            `${file.name} | ${img.width}x${img.height}${formatInfo}`;

                        // Check for header
                        const headerBytes = extractRawBits(state.decodeCanvas, [0, 1, 2], 1, HEADER_SIZE);
                        const header = parseHeader(headerBytes);

                        const detection = document.getElementById('decode-detection');
                        if (header) {
                            detection.innerHTML = `<div style="color: var(--primary); background: rgba(0,255,65,0.1); padding: 8px; border: 1px solid var(--primary); border-radius: 4px;">
                                ‚úì STEG v${header.version} detected<br>
                                Channels: ${header.channels.map(c => ['R','G','B','A'][c]).join('')}<br>
                                Payload: ${formatSize(header.originalLength)}
                            </div>`;
                        } else {
                            detection.innerHTML = `<div style="color: var(--warning); background: rgba(255,255,0,0.1); padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
                                ‚ö† No STEG header - use Smart Scan${isJpeg ? ' or try F5 with password' : ''}
                            </div>`;
                        }
                    };
                    img.src = URL.createObjectURL(file);
                }
            });

            setupDropZone('analyze-image-drop', 'analyze-image-input', file => {
                // Detect if it's an audio file
                const isAudio = file.type.startsWith('audio/') ||
                    /\.(wav|mp3|ogg|flac|m4a|aac)$/i.test(file.name);

                if (isAudio) {
                    switchToAudioMode('analyze');
                    loadAudioForAnalyze(file);
                } else {
                    switchToImageMode('analyze');
                    state.analyzeFile = file; // Store file for structure analysis
                    const img = new Image();
                    img.onload = () => {
                        state.analyzeCanvas = imageToCanvas(img);
                        document.getElementById('analyze-image-preview').src = img.src;
                        document.getElementById('analyze-image-preview').classList.remove('hidden');
                        document.getElementById('analyze-image-info').textContent =
                            `${file.name} | ${img.width}x${img.height}`;
                    };
                    img.src = URL.createObjectURL(file);
                }
            });

            // Matryoshka decode drop zone - uses its own canvas
            setupDropZone('matryoshka-decode-drop', 'matryoshka-decode-input', file => {
                const img = new Image();
                img.onload = () => {
                    state.matryoshkaDecodeCanvas = imageToCanvas(img);
                    document.getElementById('matryoshka-decode-preview').src = img.src;
                    document.getElementById('matryoshka-decode-preview').classList.remove('hidden');
                    notify('Image loaded for Nested Stegg decode', 'success');
                };
                img.src = URL.createObjectURL(file);
            });

            // Matryoshka outer carrier drop zone
            setupDropZone('matryoshka-outer-drop', 'matryoshka-outer-input', file => {
                const img = new Image();
                img.onload = () => {
                    state.matryoshkaOuterCarrier = imageToCanvas(img);
                    document.getElementById('matryoshka-outer-preview').src = img.src;
                    document.getElementById('matryoshka-outer-preview').classList.remove('hidden');
                    document.getElementById('matryoshka-outer-info').textContent =
                        `${file.name} | ${img.width}x${img.height}`;
                    notify('Outer carrier loaded', 'success');
                    updateMatryoshkaSizeInfo();
                };
                img.src = URL.createObjectURL(file);
            });

            // Matryoshka payload file drop zone
            setupDropZone('matryoshka-file-drop', 'matryoshka-file-input', file => {
                const reader = new FileReader();
                reader.onload = e => {
                    state.matryoshkaPayloadFile = new Uint8Array(e.target.result);
                    state.matryoshkaPayloadFileName = file.name;
                    document.getElementById('matryoshka-file-info').textContent =
                        `${file.name} (${formatSize(file.size)})`;
                    updateMatryoshkaSizeInfo();
                };
                reader.readAsArrayBuffer(file);
            });

            // GODMODE carrier drop zone
            setupDropZone('godmode-carrier-drop', 'godmode-carrier-input', file => {
                const img = new Image();
                img.onload = () => {
                    state.godmodeCarrierCanvas = imageToCanvas(img);
                    document.getElementById('godmode-carrier-preview').src = img.src;
                    document.getElementById('godmode-carrier-preview').classList.remove('hidden');
                    document.getElementById('godmode-carrier-info').textContent =
                        `${file.name} | ${img.width}x${img.height}`;
                };
                img.src = URL.createObjectURL(file);
            });

            // GODMODE payload file drop zone
            setupDropZone('godmode-file-drop', 'godmode-file-input', file => {
                const reader = new FileReader();
                reader.onload = e => {
                    state.godmodePayloadFile = new Uint8Array(e.target.result);
                    state.godmodePayloadFileName = file.name;
                    document.getElementById('godmode-file-info').textContent =
                        `${file.name} (${formatSize(file.size)})`;
                };
                reader.readAsArrayBuffer(file);
            });

            // GODMODE decode drop zone
            setupDropZone('godmode-decode-drop', 'godmode-decode-input', file => {
                const img = new Image();
                img.onload = () => {
                    state.godmodeDecodeCanvas = imageToCanvas(img);
                    document.getElementById('godmode-decode-preview').src = img.src;
                    document.getElementById('godmode-decode-preview').classList.remove('hidden');
                };
                img.src = URL.createObjectURL(file);
            });

            // Audio spectrogram art image drop zone (for encode panel)
            setupDropZone('audio-specart-drop', 'audio-specart-input', file => {
                const img = new Image();
                img.onload = () => {
                    state.audioSpecartImage = img;
                    document.getElementById('audio-specart-preview').src = img.src;
                    document.getElementById('audio-specart-preview').classList.remove('hidden');
                    notify('Image loaded for spectrogram art!', 'success');
                };
                img.src = URL.createObjectURL(file);
            });

            // Audio LSB bits change
            document.getElementById('audio-lsb-bits')?.addEventListener('change', updateAudioCapacity);

            // Capacity updates
            document.getElementById('encode-text').addEventListener('input', updateCapacity);
            document.getElementById('encode-channels').addEventListener('change', updateCapacity);
            document.getElementById('encode-bits').addEventListener('change', updateCapacity);

            // Matryoshka decode depth slider
            document.getElementById('matryoshka-depth').addEventListener('input', e => {
                state.matryoshkaDepth = parseInt(e.target.value);
                document.getElementById('matryoshka-depth-value').textContent = state.matryoshkaDepth;
            });

            // Matryoshka encode depth slider (updates display and recalculates size)
            document.getElementById('matryoshka-encode-depth').addEventListener('input', e => {
                document.getElementById('matryoshka-encode-depth-value').textContent = e.target.value;
                updateMatryoshkaSizeInfo();
            });

            // Matryoshka text input - update size info as user types
            document.getElementById('matryoshka-text')?.addEventListener('input', updateMatryoshkaSizeInfo);

            // Matryoshka auto-size checkbox
            document.getElementById('matryoshka-autosize')?.addEventListener('change', updateMatryoshkaSizeInfo);

            // Matryoshka encoding options
            document.getElementById('matryoshka-channels')?.addEventListener('change', updateMatryoshkaSizeInfo);
            document.getElementById('matryoshka-bits')?.addEventListener('change', updateMatryoshkaSizeInfo);

            // Matryoshka embed mode - show/hide LSB options
            document.getElementById('matryoshka-embed-mode')?.addEventListener('change', (e) => {
                const isDCT = e.target.value === 'dct';
                document.getElementById('matryoshka-channels-group').style.display = isDCT ? 'none' : '';
                document.getElementById('matryoshka-bits-group').style.display = isDCT ? 'none' : '';
                updateMatryoshkaSizeInfo();
            });

            // Easter egg trigger
            document.getElementById('matryoshka-trigger').addEventListener('click', toggleMatryoshka);

            // Bitplane slider for channel visualization
            document.getElementById('bitplane-slider')?.addEventListener('input', (e) => {
                currentBitPlane = parseInt(e.target.value);
                const labels = ['0 (LSB)', '1', '2', '3', '4', '5', '6', '7 (MSB)'];
                document.getElementById('bitplane-value').textContent = labels[currentBitPlane];
                renderChannelLayers();
            });

            // File structure analysis input
            document.getElementById('file-structure-input')?.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    analyzeFileStructure(e.target.files[0]);
                }
            });
        });
    </script>
</body>
</html>
